<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>进程间任何通信？</title>
    <url>/uncategorized/%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BB%BB%E4%BD%95%E9%80%9A%E4%BF%A1%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="进程之间究竟有哪些通信方式？如何通信？"><a href="#进程之间究竟有哪些通信方式？如何通信？" class="headerlink" title="进程之间究竟有哪些通信方式？如何通信？"></a>进程之间究竟有哪些通信方式？如何通信？</h3><h6 id="1、管道"><a href="#1、管道" class="headerlink" title="1、管道"></a>1、管道</h6><p>我们来看一条 Linux 的语句</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">netstat -tulnp | grep <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>学过 Linux 命名的估计都懂这条语句的含义，其中”|“是管道的意思，它的作用就是把前一条命令的输出作为后一条命令的输入。在这里就是把 netstat -tulnp 的输出结果作为 grep 8080 这条命令的输入。如果两个进程要进行通信的话，就可以用这种管道来进行通信了，并且我们可以知道这条竖线是没有名字的，所以我们把这种通信方式称之为匿名管道。</p>
<p>并且这种通信方式是单向的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。<a id="more"></a></p>
<p>居然有匿名管道，那也意味着有命名管道，下面我们来创建一个命名管道。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mkfifo  test</span><br></pre></td></tr></table></figure>

<p>这条命令创建了一个名字为 test 的命名管道。</p>
<p>接下来我们用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"this is a pipe"</span> &gt; <span class="built_in">test</span>   // 写数据</span><br></pre></td></tr></table></figure>


<p>这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束。接下来我们用另外一个进程来读取</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> &lt; <span class="keyword">test</span>  <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure>


<p>我们可以看到，test 里面的数据被读取出来了。上一条命令也执行结束了。</p>
<p>从上面的例子可以看出，管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是单向传输的。</p>
<p>这种通信方式有什么缺点呢？显然，这种通信方式效率低下，你看，a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。</p>
<p>所以管道不适合频繁通信的进程。当然，他也有它的优点，例如比较简单，能够保证我们的数据已经真的被其他进程拿走了。我们平时用 Linux 的时候，也算是经常用。</p>
<h6 id="2、消息队列"><a href="#2、消息队列" class="headerlink" title="2、消息队列"></a>2、消息队列</h6><p>那我们能不能把进程的数据放在某个内存之后就马上让进程返回呢？无需等待其他进程来取就返回呢？</p>
<p>答是可以的，我们可以用消息队列的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的<br>消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于缓存吧。</p>
<p>这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味<strong>发送消息（拷贝）</strong>这个过程需要花很多时间来读内存。</p>
<p>哪有没有什么解决方案呢？答是有的，请继续往下看。</p>
<h6 id="3、共享内存"><a href="#3、共享内存" class="headerlink" title="3、共享内存"></a>3、共享内存</h6><p>共享内存这个通信方式就可以很好着解决拷贝所消耗的时间了。</p>
<p>这个可能有人会问了，每个进程不是有自己的独立内存吗？两个进程怎么就可以共享一块内存了？</p>
<p>我们都知道，系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。</p>
<h6 id="4、信号量"><a href="#4、信号量" class="headerlink" title="4、信号量"></a>4、信号量</h6><p>共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的线程安全问题。如何解决这个问题？这个时候我们的信号量就上场了。</p>
<p>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p>
<h6 id="5、Socket"><a href="#5、Socket" class="headerlink" title="5、Socket"></a>5、Socket</h6><p>上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？</p>
<p>答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p>
<p>总结<br>所以，进程之间的通信方式有：</p>
<p>1、管道</p>
<p>2、消息队列</p>
<p>3、共享内存</p>
<p>4、信号量</p>
<p>5、Socket</p>
]]></content>
  </entry>
  <entry>
    <title>vue拦截器</title>
    <url>/Vue/vue%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Vue-router的beforeEach"><a href="#Vue-router的beforeEach" class="headerlink" title="Vue:router的beforeEach"></a>Vue:router的beforeEach</h1><h6 id="在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。"><a href="#在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。" class="headerlink" title="在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。"></a>在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。</h6><h6 id="定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。"><a href="#定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。" class="headerlink" title="定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。"></a>定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。</h6><p>两种函数：</p>
<p>​            1.Vue.beforeEach(function(to,form,next){}) /<em>在跳转之前执行</em>/</p>
<p>​            2.Vue.afterEach(function(to,form))/<em>在跳转之后判断</em>/</p>
<h3 id="beforeEach函数有三个参数："><a href="#beforeEach函数有三个参数：" class="headerlink" title="beforeEach函数有三个参数："></a>beforeEach函数有三个参数：</h3><ul>
<li>to:router即将进入的路由对象</li>
<li>from:当前导航即将离开的路由</li>
<li>next:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航。<a id="more"></a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//我们可以在main.js中定义一个白名单</span><br><span class="line">var witelist=[<span class="string">'Detail'</span>,<span class="string">'Order'</span>]  //定义白名单 需要登陆后访问页面</span><br><span class="line">//  router.beforEach  访问路由前</span><br><span class="line">// to:Route :即将要进入的路由对象</span><br><span class="line">// <span class="keyword">from</span> :Route:  当前导航正要离开的路由</span><br><span class="line">// next : Funcation  进行管道中的下一个钩子</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">router.beforeEach((to,from,next)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">	//我们取出存取的token</span><br><span class="line">  let token = sessionStorage.getItem(<span class="string">'token'</span>);</span><br><span class="line">	//判断它是否存在并且白名单定义的路由存在</span><br><span class="line">  <span class="keyword">if</span>(token|| whitelist.indexOf(to.name) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    console.log(<span class="string">'下一页！'</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">'请登陆后访问详情页'</span>)</span><br><span class="line">   </span><br><span class="line">    router.push(&#123;name:<span class="string">'Login'</span>&#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>一万快的火腿</title>
    <url>/Django/%E4%B8%80%E4%B8%87%E5%BF%AB%E7%9A%84%E7%81%AB%E8%85%BF/</url>
    <content><![CDATA[<h1 id="订单支付页面-支付方式-结账，优惠劵"><a href="#订单支付页面-支付方式-结账，优惠劵" class="headerlink" title="订单支付页面  支付方式(结账，优惠劵)"></a>订单支付页面  支付方式(结账，优惠劵)</h1><p>前言：支付宝沙箱环境(Beta)是协助开发者进行接口功能开发及主要功能联调的辅助环境。沙箱环境模拟了开放平台部分产品的主要功能和主要逻辑。在开发者应用上线审核前，开发者可以根据自身需求，先在沙箱环境中了解、组合和调试各种开放接口，进行开发调通工作，从而帮助开发者在应用上线审核完成后，能更快速、更顺利的进行线上调试和验收工作。<br>一、开通支付宝沙箱环境<br>沙箱环境地址：<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=info" target="_blank" rel="noopener">https://openhome.alipay.com/platform/appDaily.htm?tab=info</a><br>访问上面url，支付宝扫码登录，实名认证，根据提示创建应用，生成相应的沙箱应用环境。生成并上传RSA2(SHA256)的应用公钥，详见生成RSA密钥； <a id="more"></a></p>
<h3 id="生成优惠码脚本"><a href="#生成优惠码脚本" class="headerlink" title="生成优惠码脚本"></a>生成优惠码脚本</h3><h6 id="生成一个随机的串，用户输入到输入框中，使用优惠卷，价格打折！与库里对比，打折"><a href="#生成一个随机的串，用户输入到输入框中，使用优惠卷，价格打折！与库里对比，打折" class="headerlink" title="生成一个随机的串，用户输入到输入框中，使用优惠卷，价格打折！与库里对比，打折"></a>生成一个随机的串，用户输入到输入框中，使用优惠卷，价格打折！与库里对比，打折</h6><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">code = string.ascii_letters + string.digits</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> Code():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.<span class="keyword">join</span>(random.sample(code, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(Code())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> Mycode(<span class="keyword">group</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'-'</span>.<span class="keyword">join</span>(Code() <span class="keyword">for</span> i in range(<span class="keyword">group</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mycode = Mycode(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span>(Mycode)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> pymsql</span><br><span class="line"></span><br><span class="line"><span class="comment">#连接数据库</span></span><br><span class="line">conn=pymysql.connet(host=<span class="string">''</span>,user=<span class="string">''</span>,password=<span class="string">''</span>,db=<span class="string">''</span>,charset=<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string.ascii_letters  <span class="comment">#字符串</span></span><br><span class="line">string.digits <span class="comment">#数字 0-9</span></span><br><span class="line"><span class="comment">#定义随机串元素</span></span><br><span class="line">code=string.ascii_letters + string.digits      <span class="comment">#(字母+数字)</span></span><br><span class="line"><span class="comment">#随机码不能太短，定义获取四位的随机码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getcode</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">''</span>.join(random.sample(code,<span class="number">4</span>))  <span class="comment">#定义字符  定义字符长度</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">#定义4列4位码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key</span><span class="params">(group)</span>:</span></span><br><span class="line">	<span class="keyword">return</span>  <span class="string">'-'</span>.join([getcode() <span class="keyword">for</span> i <span class="keyword">in</span> range(group)])</span><br><span class="line">	</span><br><span class="line">print(key(<span class="number">4</span>))</span><br><span class="line">mycode=key(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建游标对象</span></span><br><span class="line">cursor=conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义sql语句</span></span><br><span class="line">sql=<span class="string">"insert into 表名 (code,discount) values ('%s',%s)"</span> % (mycode,<span class="string">'0.8'</span>)</span><br><span class="line">print(sql)  <span class="comment">#展示sql语言，看是否完整</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#入库操作 ，执行sql</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line"><span class="comment">#提交事务 </span></span><br><span class="line">conn.commit()</span><br><span class="line"><span class="comment">#关闭游标</span></span><br><span class="line">cursor.close()</span><br><span class="line"><span class="comment">#关闭数据库连接</span></span><br><span class="line">conn.close</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#优惠卷表</span><br><span class="line">class Codes(models.Model):</span><br><span class="line">	#主键</span><br><span class="line">	id=models.AutoField(primary_key=True)</span><br><span class="line">	#随机码</span><br><span class="line">	code=models.CharField(max_length=100)</span><br><span class="line">	#折扣  每种随机码对应相应的折扣</span><br><span class="line">	discount=models.FloatField()   #打折，浮点</span><br><span class="line">	#是否过期</span><br><span class="line">	status=models.IntegerFiels(default=1)  #默认为一，1为可以使用</span><br><span class="line">	</span><br><span class="line">	#表名</span><br><span class="line">	class Meta:</span><br><span class="line">		db_table=&apos;codes&apos;</span><br></pre></td></tr></table></figure>

<p>ok,你会发现我们的优惠卷已经入库了！</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#序列化器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodesSer</span><span class="params">(serializer.ModelSerializer)</span>:</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">		model=model.Code</span><br><span class="line">		fields=<span class="string">'__all__'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#优惠卷使用接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCode</span><span class="params">(APIbiew)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">		<span class="comment">#获取前端用户输入的优惠码</span></span><br><span class="line">		code=request.GET.get(<span class="string">'code'</span>)</span><br><span class="line">		<span class="comment">#与表中数据进行匹配获取单商品详情</span></span><br><span class="line">		codes=Codes.objects.filter(code=code).first()</span><br><span class="line">		<span class="comment">#序列化</span></span><br><span class="line">		codes_ser=CoderSer(codes)   <span class="comment">#一条数据，所以我们不用加many=True</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">#判断优惠劵使用状态</span></span><br><span class="line">		如果为一可以使用，当为<span class="number">0</span>时则优惠劵已被使用过！</span><br><span class="line">		<span class="keyword">if</span> 优惠劵未被使 用 ==<span class="number">0</span>:</span><br><span class="line">			</span><br><span class="line">			优惠劵被使用过，无效 Code码</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			codes.statiss=<span class="number">0</span> </span><br><span class="line">			codes.save()</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> HttpResponse(codes_ser.data)</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#优惠价:myprice</span><br><span class="line">#原价:price</span><br><span class="line"></span><br><span class="line">#前端输入Code码</span><br><span class="line">优惠劵:&lt;input type=&apos;text&apos; v-model=&apos;discount&apos;/&gt;  </span><br><span class="line">&lt;button @click=&apos;usecode&apos;&gt;使用优惠劵&lt;/button&gt;  #绑定事件我们把数据传到后代</span><br><span class="line">#实际上订单页面并不会只显示优惠劵的价格，还有商品原价。这样可以给用户视觉上的一个冲击，看优惠了多少！  优惠价 以及原价  当用户没有使用优惠卷的时候我们把优惠价隐藏</span><br><span class="line">&lt;span  v-show=&apos;myprice&apos;&gt;优惠价:&#123;&#123;myprice&#125;&#125;&lt;span&gt;</span><br><span class="line"></span><br><span class="line">#使用优惠劵</span><br><span class="line">usecode()&#123;</span><br><span class="line">	//调用接口，数据传给后台</span><br><span class="line">	//设置优惠价</span><br><span class="line">	var totalprice=this.totalprice;</span><br><span class="line">	this.myprice= totalprice * 优惠折扣   #优惠价=商品原价*后台返回的折扣</span><br><span class="line">	</span><br><span class="line">	//这有一个判断，当用户在此输入用过的优惠码时，显示当前优惠码已被使用</span><br><span class="line">	if 优惠码使用状态为0时&#123;</span><br><span class="line">		显示该优惠劵已被使用过</span><br><span class="line">		return    #返回，不做任何处理</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="所谓的重置按钮就是当你点击事件时把你当前输入的数据反空"><a href="#所谓的重置按钮就是当你点击事件时把你当前输入的数据反空" class="headerlink" title="所谓的重置按钮就是当你点击事件时把你当前输入的数据反空"></a>所谓的重置按钮就是当你点击事件时把你当前输入的数据反空</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&apos;rest&apos;&gt;重置&lt;button&gt;</span><br><span class="line"></span><br><span class="line">rest()&#123;</span><br><span class="line">	this.username ==&apos;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="订单"><a href="#订单" class="headerlink" title="订单"></a>订单</h3><p>订单id  价格  订单用户 订单号</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#订单表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orders</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">	<span class="comment">#主键</span></span><br><span class="line">	id=models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">	<span class="comment">#订单id 一般来说订单id由时间戳(订单涉及钱财，如果用户订单出错，技术人员通过订单号来判断这是那个具体时间的订单)一般来说，大点的公司会进行分表这样存储， 方便(那张表，那个月份)</span></span><br><span class="line">	orderid=models.CharField()</span><br><span class="line">	<span class="comment">#用户id</span></span><br><span class="line">	uid=models.IntegerField()</span><br><span class="line">	<span class="comment">#价格</span></span><br><span class="line">	price=models.IntegerField()</span><br><span class="line">	<span class="comment">#支付状态</span></span><br><span class="line">	status=models.IntegerField(default=<span class="number">0</span>)  <span class="comment">#0:待支付</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">		db_table=<span class="string">'orders'</span></span><br></pre></td></tr></table></figure>



<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="comment">#订单入库,当调用这个方法时，即使用时间戳并生成顶单id</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orders</span><span class="params">(APIview)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">		<span class="comment">#接收参数   用户id  价格</span></span><br><span class="line">		<span class="comment">#后台验证签名，验签</span></span><br><span class="line">		sign=request.GET.get(<span class="string">'sign'</span>,<span class="string">''</span>)</span><br><span class="line">		md5=hashlib.md5()</span><br><span class="line">		<span class="comment">#定义加密对象</span></span><br><span class="line">		sign_str=<span class="string">''</span>  我们在前台生成的md5-js对象  <span class="comment">#要与前台加密对象一致</span></span><br><span class="line">		<span class="comment">#转码</span></span><br><span class="line">		sign_utf8=str(sign_str).encode(encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">		<span class="comment">#加密</span></span><br><span class="line">		md5.update(sign_utf<span class="number">-8</span>)</span><br><span class="line">		<span class="comment">#生成密文</span></span><br><span class="line">		md5_server=md5.hexdigest()</span><br><span class="line">		print(md5_server)</span><br><span class="line">		<span class="comment">#然后我们比对在前端加密和后端的md5加密，如果相同下一步，否则信息已被纂改</span></span><br><span class="line">		<span class="comment">#比对签名</span></span><br><span class="line">		<span class="keyword">if</span> 前端加密 ！= 后台加密:</span><br><span class="line">			订单信息被纂改</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			数据一致，进行订单入库操作</span><br><span class="line">		<span class="comment">#订单号是我们自己生成的</span></span><br><span class="line">		<span class="comment">#根据时间戳生成订单号</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">#进行入库逻辑</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">订单号的用处:</span><br><span class="line">	1.方便我们好查</span><br><span class="line">	2.防止订单号重复(使用时间戳)</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">#定义订单号</span><br><span class="line">def get_order_code():</span><br><span class="line">	#注意 Y：year m:month  d:day  H:小时   M：分钟 S：秒</span><br><span class="line">	order_no=time.strftime(&apos;%Y%m%d%H%M%S&apos;,time.localtime(time.time()))</span><br><span class="line">	</span><br><span class="line">	return order_no</span><br></pre></td></tr></table></figure>



<h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h3><p>初始化订单数据，展示我的订单详情页面、也就是说当我们在购物车中点击去支付的时候展示当前订单信息</p>
<h5 id="前端MD5加密——js-md5"><a href="#前端MD5加密——js-md5" class="headerlink" title="前端MD5加密——js-md5"></a>前端MD5加密——js-md5</h5><h6 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h6><p>是通过前台js加密的方式对密码等私密信息进行加密的工具</p>
<h6 id="2-js加密的好处"><a href="#2-js加密的好处" class="headerlink" title="2.js加密的好处"></a>2.js加密的好处</h6><p>（1）用js对私密信息加密可避免在网络中传输明文信息,被人截取数据包而造成数据泄露。<br>（2）避免缓存中自动缓存密码。比如在使用谷歌浏览器登陆时,输入的用户名和密码会自动缓存,下次登陆时无需输入密码就可以实现登陆,这样就给别人留下漏洞,当别人用你电脑登陆或把input的type改为test 那么你的密码就泄露了.使用js加密时,缓存的加密后的密文,用密文做密码登陆是不成功的,即使泄露也是泄露的密文,对密码不会造成威胁，缺点是每次登陆时都要手动输入密码，较麻烦。<br>（3）使用js加密,减少了服务器加密时的资源消耗,从理论上提高了服务器的性能。为了安全,很有必要再做服务器端的加密.无论从理论还是实际,两道门比一道门要安全些.至少给攻击者造成了一个障碍。</p>
<h6 id="3-安装使用"><a href="#3-安装使用" class="headerlink" title="3.安装使用"></a>3.安装使用</h6><p>（1）安装</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">npm install js-md5</span><br></pre></td></tr></table></figure>



<p>（2）main.js中引入</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">md5</span> <span class="keyword">from</span> 'js-<span class="built_in">md5</span>';</span><br><span class="line">Vue.prototype.$<span class="built_in">md5</span> = <span class="built_in">md5</span>;</span><br></pre></td></tr></table></figure>

<p>（3）使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$md5(<span class="string">"加密内容"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="支付签名"><a href="#支付签名" class="headerlink" title="支付签名"></a>支付签名</h5><h6 id="进行签名验证-价签-md5-js-不可逆，防止恶意纂改数据，进行入库操作"><a href="#进行签名验证-价签-md5-js-不可逆，防止恶意纂改数据，进行入库操作" class="headerlink" title="进行签名验证(价签) md5-js 不可逆，防止恶意纂改数据，进行入库操作"></a>进行签名验证(价签) md5-js 不可逆，防止恶意纂改数据，进行入库操作</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    //结账</span><br><span class="line">    checkout(totalprice)&#123;</span><br><span class="line">        //判断是否优惠劵</span><br><span class="line">        <span class="keyword">if</span>(this.myprice !=<span class="number">0</span>)&#123;</span><br><span class="line">            totalprice=this.myprice</span><br><span class="line">        &#125;</span><br><span class="line">        //进行签名验证(价签)</span><br><span class="line">        var sign =<span class="string">'mysign'</span> + <span class="string">'price='</span>+totalprice;</span><br><span class="line">        sign = md5(sign)</span><br><span class="line">        console.log(sign)</span><br><span class="line">        //使用箭头函数吧参数传过去</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="沙箱应用"><a href="#沙箱应用" class="headerlink" title="沙箱应用"></a>沙箱应用</h5><p>网页登陆支付宝—&gt;开发者中心—–&gt;沙箱环境—–&gt;沙箱应用—&gt;查看appid 应用公钥  私钥等配置信息。</p>
<p>我们用沙箱账号中的买家信息登陆 沙箱版钱包。</p>
<p> 支付宝加密RSA 所以我们也用RSA加密和支付宝的所匹配以防纂改信息</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> cryptography      <span class="comment">#这是一个库，加密搞的</span></span><br></pre></td></tr></table></figure>



<h5 id="支付宝支付接口：一万的火腿"><a href="#支付宝支付接口：一万的火腿" class="headerlink" title="支付宝支付接口：一万的火腿"></a>支付宝支付接口：一万的火腿</h5><h6 id="RSA签名验签工具-—-gt-非Java使用—-gt-生成public-key-和-private-key-俩个文件加头尾标识我们用工具生成的公钥与私钥。把商户应用公钥放到应用公钥，公钥上传成功后，会自动生成支付宝公钥，我们把支付宝公钥放到本地的public-key-公钥-，私钥不变。"><a href="#RSA签名验签工具-—-gt-非Java使用—-gt-生成public-key-和-private-key-俩个文件加头尾标识我们用工具生成的公钥与私钥。把商户应用公钥放到应用公钥，公钥上传成功后，会自动生成支付宝公钥，我们把支付宝公钥放到本地的public-key-公钥-，私钥不变。" class="headerlink" title="RSA签名验签工具 —&gt; 非Java使用—&gt;生成public_key   和 private_key. 俩个文件加头尾标识我们用工具生成的公钥与私钥。把商户应用公钥放到应用公钥，公钥上传成功后，会自动生成支付宝公钥，我们把支付宝公钥放到本地的public_key(公钥)，私钥不变。"></a>RSA签名验签工具 —&gt; 非Java使用—&gt;生成public_key   和 private_key. 俩个文件加头尾标识我们用工具生成的公钥与私钥。把商户应用公钥放到应用公钥，公钥上传成功后，会自动生成支付宝公钥，我们把支付宝公钥放到本地的public_key(公钥)，私钥不变。</h6><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">#公钥</span><br><span class="line"></span><br><span class="line">-----<span class="keyword">BEGIN</span> <span class="keyword">PUBLIC</span> KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApF51QND1p2rOvjx90zERrkDyRyEvdAzijGyjzch1fHgmrYVWMU9DboyWHKACLutwjSV5etTK90cN6rqs64KzRtWzgarjcUpzXpdxTINpn2KsUXHJQYHaz6tvodNdEIf4OB1PKzmNkMWMlBh0Z+KK5RQlU0yGedXbcGvh1dJqCdqhakppRa+DumIdC6IIgagT/Dz3X6kSw9mdxcn73JyJ6XGCSkifUJUtfX94oXg01L1jmtXPV5HJH/wzLVXVJVuRRmRNug6TssmRwowbsFIAiq9rX/mH1tIWbnc/MEPzJMWeKb<span class="comment">//JlNPPXbocAJaH17taDGOF2cyOgTtWomMUxgouQIDAQAB</span></span><br><span class="line">-----<span class="keyword">END</span> <span class="keyword">PUBLIC</span> KEY-----</span><br></pre></td></tr></table></figure>



<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">#私钥</span><br><span class="line">-----<span class="keyword">BEGIN</span> RSA <span class="keyword">PRIVATE</span> KEY-----</span><br><span class="line">MIIEowIBAAKCAQEAxckxbXy+we5P7xFoeEK7DmWPpC2vlpFHUhpS8ZA7omHAx4O0</span><br><span class="line">S6sW+ZijxLUcMKOhCNI78bQQwRkRwwXIEaVl9ob1j1ysCRDXxOmvvMntV6WFoWRe</span><br><span class="line">bJ2suGBwvmaeE+dgdSLdFdCvalVMHWhEJGOv/UbD6uuS3zL6fBPMpr2Tcm7gs/h5</span><br><span class="line">fPA8hBAekYRHP5yZk4+<span class="number">3</span>vh3LZxGVzWZU6AstOdCdXDEtYEx5bbKj035d6Yr9UEHy</span><br><span class="line">FWULy+Jp50a+HyDqNQcCAH3V0Ty+/wYk7H8/Oong4N4V+eZOgBcgYIeQaTkgsfMT</span><br><span class="line">UKOsGZgxJMCu7UT0yDJ0q9DakJqbGxZKdfXrAwIDAQABAoIBAE/hq2HiARVIT+Zp</span><br><span class="line">bH0tzmjJIhOYFBPGxzxkv10q+Lrjqj2qdtYc2qGiQXp<span class="comment">//0uxuqdaabV8GUwz+NWA</span></span><br><span class="line">b0aZO64u4dyt/BmJQOwZyc2A7Kf6hRci93P81rZ81OxBe9TkHTQSCaL27vIOUziJ</span><br><span class="line">VQQxcvHjc9tcm6wj5cDZKk2pwXR0l+tGkThuwb/fwycREZ7YB8lA8gKQ519KgC3T</span><br><span class="line">eTkWepiinl7S00D/plAANnjj6xbn16mQG1/Vx4yXG1CC/xemfpMiOh4BN9urrvqe</span><br><span class="line">etueSKr7we5rBy9IAyxqeXfCTg2FlS7w19/+Y7ToZhWEXuHc4CiaMrI9tu9os51C</span><br><span class="line">TDmer3ECgYEA4/JMKjO1MzEJmhKKA1ye8Qxaw7feVh1pa8rTcY175MWbe5Dt7NFA</span><br><span class="line">EVK37BQUgm3S872UbdkvuVASpiPTvnH3HPClROendIGalOA87qvzSaGYgBOx0gHH</span><br><span class="line">bZNH8fFakd0gIw+s5sfQHdUbFlE1JS79scc8tJVrgAjfrZb2N7zDLrkCgYEA3iCn</span><br><span class="line">cKdEyKJKKT7I0R0SntWZN5ODcOoLNRS7HLiF54/T6/n3JRfHMWpUnI9BHtG9VP0n</span><br><span class="line"><span class="number">2</span>rhS2J3jZi8SokLOxQpEOlfa3ARTDbE2AREJui6AdkLgts7SEkGVx/Dsd3RqSL+<span class="number">0</span></span><br><span class="line">btrW+<span class="number">38</span>qc1omueV4bDhJy2E4yOb/<span class="number">9</span>s+dGqU1KZsCgYBz81etC/p7XNFuj0mnJiEv</span><br><span class="line">qsIs1sYBdhqfG2BtXbQNDjvmIjX1BggaB8LJEvnP0v/AvsnXCuiM0l96JbVbJeu2</span><br><span class="line">y+<span class="number">6120</span>TCLf8tBdfY7Jzn8ox5cgs9MWx5n7a0KrqQgjQLwbiI+FE0K6gItSxcise/</span><br><span class="line">/AI0NeGmEl19ltIOTjXW+QKBgDbvPHnP5GL6P/<span class="number">0</span>TWfbdic1eZhYolUlHmJ34Eo53</span><br><span class="line"><span class="number">1</span>CYAnBiwKT8zMkA2W9acVy6YEIsEUOb2zwZjhemvmpwmiZyRfW4wbCAdsayhNwns</span><br><span class="line">fMte1MZqo8iSPcHmFnTsUI76a46yWp1P4fsw5/<span class="number">6</span>/PPScm7un8BgsYy7McmFH10LP</span><br><span class="line">uOYhAoGBAJQ8+XlmOxdrmrzWRPfA/FJoDu1OGr8alSKHdkHmKc/r7vmnUXmhDEBl</span><br><span class="line"><span class="number">4</span>IU64GqPCS0gFCoRz/vo0JwcDBvSdMnD0Gj9IgzTyYvzxLRL8G4cAH9EXbp1hjSC</span><br><span class="line">pJpenui4fA7HsFdNJDLRxkg2yONiXFnpK55ylFGyk4NHGqqXmAIU</span><br><span class="line">-----<span class="keyword">END</span> RSA <span class="keyword">PRIVATE</span> KEY-----</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1577353504404.png" alt="1577353504404"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> alipay</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> alipay <span class="keyword">import</span> AliPay</span><br><span class="line"><span class="keyword">from</span> web.settings <span class="keyword">import</span> BASE_DIR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">appid=<span class="string">'2016092600603658'</span></span><br><span class="line"><span class="keyword">def</span> Alpay():</span><br><span class="line">    <span class="keyword">ali</span> = AliPay(</span><br><span class="line">        appid=<span class="string">'2016092600603658'</span>,</span><br><span class="line">        app_notify_url=<span class="keyword">None</span>,</span><br><span class="line">        alipay_public_key_path=os.path.join(BASE_DIR,<span class="string">'public_key.txt'</span>),</span><br><span class="line">        app_private_key_path=os.path.join(BASE_DIR,<span class="string">'private_key.txt'</span>),</span><br><span class="line">        debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> = &#123;</span><br><span class="line">        <span class="string">'subject'</span>: <span class="string">'大火腿'</span>,</span><br><span class="line">        <span class="string">'out_trade_no'</span>: <span class="keyword">str</span>(random.randint(<span class="number">10000000000</span>,<span class="number">99999999999</span>)),</span><br><span class="line">        <span class="string">'total_amount'</span>: <span class="keyword">str</span>(<span class="number">9999999.99</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    order_str = ali.api_alipay_trade_page_pay(**<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">    request_url = <span class="string">'https://openapi.alipaydev.com/gateway.do?'</span> + order_str</span><br><span class="line"></span><br><span class="line">    print(request_url)</span><br><span class="line"></span><br><span class="line">Alpay()</span><br></pre></td></tr></table></figure>





<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render, redirect, HttpResponse</span><br><span class="line">from utils.pay import AliPay</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def ali():</span><br><span class="line">    # 沙箱环境地址：https:<span class="comment">//openhome.alipay.com/platform/appDaily.htm?tab=info</span></span><br><span class="line">    app_id = "2016092400583356"</span><br><span class="line">    # 支付宝收到用户的支付,会向商户（我）发两个请求,一个get请求,一个post请求 - 用于表示支付成功<span class="keyword">or</span>失败</span><br><span class="line">    # POST请求，用于最后的检测</span><br><span class="line">    notify_url = "http://42.56.89.12:80/page2/"</span><br><span class="line">    # GET请求，用于页面的跳转展示</span><br><span class="line">    return_url = "http://42.56.89.12:80/page2/"</span><br><span class="line">    # 私钥文件</span><br><span class="line">    merchant_private_key_path = "keys/app_private_2048.txt"</span><br><span class="line">    # 阿里公钥文件</span><br><span class="line">    alipay_public_key_path = "keys/alipay_public_2048.txt"</span><br><span class="line">    # 生成一个AliPay的对象</span><br><span class="line">    alipay = AliPay(</span><br><span class="line">        appid=app_id,</span><br><span class="line">        app_notify_url=notify_url,</span><br><span class="line">        return_url=return_url,</span><br><span class="line">        app_private_key_path=merchant_private_key_path,</span><br><span class="line">        alipay_public_key_path=alipay_public_key_path,  # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥</span><br><span class="line">        debug=True,  # 默认False,</span><br><span class="line">    )</span><br><span class="line">    return alipay</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def page1(request):</span><br><span class="line">    if request.method == "GET":</span><br><span class="line">        return render(request, <span class="string">'page1.html'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        money = float(request.POST.get(<span class="string">'money'</span>))</span><br><span class="line">        # 执行支付配置方法，生成一个对象</span><br><span class="line">        alipay = ali()</span><br><span class="line">        # 生成支付的url</span><br><span class="line">        # query_params:对象调用direct_pay</span><br><span class="line">        query_params = alipay.direct_pay(</span><br><span class="line">            subject="TEST商品",  # 商品简单描述</span><br><span class="line">            out_trade_no="x2" + str(time.time()),  # 商户订单号</span><br><span class="line">            total_amount=money,  # 交易金额(单位: 元 保留俩位小数)</span><br><span class="line">        )</span><br><span class="line">        # alipaydev,！！带着dev的都是沙箱环境！！</span><br><span class="line">        pay_url = "https://openapi.alipaydev.com/gateway.do?&#123;&#125;".format(query_params)</span><br><span class="line">        print(pay_url)</span><br><span class="line">        # 朝这个地址发get请求</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>cenos7下安装Python3.7</title>
    <url>/Installs/cenos7%E4%B8%8B%E5%AE%89%E8%A3%85Python3-7/</url>
    <content><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>需要先sudo到root用户<a id="more"></a></p>
<h4 id="安装相关编译工具"><a href="#安装相关编译工具" class="headerlink" title="安装相关编译工具"></a>安装相关编译工具</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y groupinstall &quot;Development tools&quot;</span><br><span class="line">yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span><br><span class="line">yum install libffi-devel -y</span><br></pre></td></tr></table></figure>

<h4 id="下载并解压安装包"><a href="#下载并解压安装包" class="headerlink" title="下载并解压安装包"></a>下载并解压安装包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd 你自己的目录</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz</span><br><span class="line">tar -xvJf  Python-3.7.0.tar.xz</span><br></pre></td></tr></table></figure>

<h4 id="编译及安装"><a href="#编译及安装" class="headerlink" title="编译及安装"></a>编译及安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/python3 <span class="comment">#创建编译安装目录</span></span><br><span class="line"><span class="built_in">cd</span> Python-3.7.0</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h4 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/<span class="built_in">local</span>/bin/python3</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3 /usr/<span class="built_in">local</span>/bin/pip3</span><br></pre></td></tr></table></figure>

<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -V</span><br><span class="line">pip3 -V</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Installs</category>
      </categories>
      <tags>
        <tag>Installs</tag>
      </tags>
  </entry>
  <entry>
    <title>Firewalld未运行</title>
    <url>/Linux/Firewalld%E6%9C%AA%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<p>最近在阿里云服务器centos上安装了mysql数据库，默认是不开启远端访问功能，需要设置一下防火墙，在开放默认端口号 3306时提示FirewallD is not running，经过排查发现是防火墙就没打开造成的，出于安装考虑还是把防火墙开上吧，以下步骤仅供参考啦。<a id="more"></a></p>
<h2 id="工具-原料"><a href="#工具-原料" class="headerlink" title="工具/原料"></a>工具/原料</h2><ul>
<li>阿里云服务器centos</li>
</ul>
<h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h2><ol>
<li><p>执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示FirewallD is not running</p>
</li>
</ol>
<ol start="2">
<li><p>通过systemctl status firewalld查看firewalld状态，发现当前是dead状态，即防火墙未开启。</p>
</li>
</ol>
<ol start="3">
<li><p>通过systemctl start firewalld开启防火墙，没有任何提示即开启成功。</p>
</li>
</ol>
<ol start="4">
<li><p>再次通过systemctl status firewalld查看firewalld状态，显示running即已开启了。</p>
</li>
</ol>
<ol start="5">
<li><p>如果要关闭防火墙设置，可能通过systemctl stop firewalld这条指令来关闭该功能。</p>
</li>
</ol>
<ol start="6">
<li><p>再次执行执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示success，表示设置成功，这样就可以继续后面的设置了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis简介</title>
    <url>/Redis/Redis/</url>
    <content><![CDATA[<h2 id="Reids的特点"><a href="#Reids的特点" class="headerlink" title="Reids的特点"></a>Reids的特点</h2><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p>
<p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。<a id="more"></a></p>
<p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。</p>
<p>比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。</p>
<p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<h3 id="使用redis有哪些好处？"><a href="#使用redis有哪些好处？" class="headerlink" title="使用redis有哪些好处？"></a>使用redis有哪些好处？</h3><p>1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p>
<p>2.支持丰富数据类型，支持string，list，set，sorted set，hash</p>
<p>3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p>
<p>4.丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p>
<h3 id="为什么redis需要把所有数据放到内存中"><a href="#为什么redis需要把所有数据放到内存中" class="headerlink" title="为什么redis需要把所有数据放到内存中?"></a>为什么redis需要把所有数据放到内存中?</h3><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p>
<p>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<h3 id="Redis是单进程单线程的"><a href="#Redis是单进程单线程的" class="headerlink" title="Redis是单进程单线程的"></a>Redis是单进程单线程的</h3><p>redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销</p>
<h3 id="单线程的redis为什么这么快"><a href="#单线程的redis为什么这么快" class="headerlink" title="单线程的redis为什么这么快"></a>单线程的redis为什么这么快</h3><p>回答:主要是以下三点</p>
<p>(一)纯内存操作</p>
<p>(二)单线程操作，避免了频繁的上下文切换</p>
<p>(三)采用了非阻塞I/O多路复用机制</p>
<h3 id="redis持久化的几种方式"><a href="#redis持久化的几种方式" class="headerlink" title="redis持久化的几种方式"></a>redis持久化的几种方式</h3><p>1、快照（snapshots）</p>
<p>缺省情况情况下，Redis把数据快照存放在磁盘上的二进制文件中，文件名为dump.rdb。你可以配置Redis的持久化策略，例如数据集中每N秒钟有超过M次更新，就将数据写入磁盘；或者你可以手工调用命令SAVE或BGSAVE。</p>
<p>工作原理</p>
<p>Redis forks.</p>
<p>子进程开始将数据写到临时RDB文件中。</p>
<p>当子进程完成写RDB文件，用新文件替换老文件。</p>
<p>这种方式可以使Redis使用copy-on-write技术。</p>
<p>2、AOF</p>
<p>快照模式并不十分健壮，当系统停止，或者无意中Redis被kill掉，最后写入Redis的数据就会丢失。</p>
<p>这对某些应用也许不是大问题，但对于要求高可靠性的应用来说，Redis就不是一个合适的选择。Append-only文件模式是另一种选择。你可以在配置文件中打开AOF模式</p>
<p>3、虚拟内存方式</p>
<p>当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大.</p>
<p>当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value.</p>
<p>vm-max-threads这个参数,可以设置访问swap文件的线程数,设置最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证.</p>
<p>自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库。</p>
<h3 id="使用过Redis分布式锁么，"><a href="#使用过Redis分布式锁么，" class="headerlink" title="使用过Redis分布式锁么，"></a>使用过Redis分布式锁么，</h3><p>它是什么回事？先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p>
<h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h3 id="使用过Redis做异步队列么，你是怎么用的？"><a href="#使用过Redis做异步队列么，你是怎么用的？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？"></a>使用过Redis做异步队列么，你是怎么用的？</h3><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。 如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p>
<h3 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h3><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<h3 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h3><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p>
<h3 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h3><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<h3 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h3><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p>
<h3 id="什么是Redis的并发竞争问题"><a href="#什么是Redis的并发竞争问题" class="headerlink" title="什么是Redis的并发竞争问题"></a>什么是Redis的并发竞争问题</h3><p>Redis的并发竞争问题，主要是发生在并发写竞争。</p>
<p>考虑到redis没有像db中的sql语句，update val = val + 10 where …，无法使用这种方式进行对数据的更新。</p>
<p>假如有某个key = “price”， value值为10，现在想把value值进行+10操作。正常逻辑下，就是先把数据key为price的值读回来，加上10，再把值给设置回去。如果只有一个连接的情况下，这种方式没有问题，可以工作得很好，但如果有两个连接时，两个连接同时想对还price进行+10操作，就可能会出现问题了。</p>
<p>例如：两个连接同时对price进行写操作，同时加10，最终结果我们知道，应该为30才是正确。</p>
<p>考虑到一种情况：</p>
<p>T1时刻，连接1将price读出，目标设置的数据为10+10 = 20。</p>
<p>T2时刻，连接2也将数据读出，也是为10，目标设置为20。</p>
<p>T3时刻，连接1将price设置为20。</p>
<p>T4时刻，连接2也将price设置为20，则最终结果是一个错误值20。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用乐观锁的方式进行解决（成本较低，非阻塞，性能较高）</p>
<p>如何用乐观锁方式进行解决？</p>
<p>本质上是假设不会进行冲突，使用redis的命令watch进行构造条件。伪代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">watch price</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">get</span> price <span class="variable">$price</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$price</span> = <span class="variable">$price</span> + 10</span><br><span class="line"></span><br><span class="line">multi</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> price <span class="variable">$price</span></span><br><span class="line"></span><br><span class="line">exec</span><br></pre></td></tr></table></figure>

<p>watch这里表示监控该key值，后面的事务是有条件的执行，如果从watch的exec语句执行时，watch的key对应的value值被修改了，则事务不会执行。</p>
<p>方案2 这个是针对客户端来的，在代码里要对redis操作的时候，针对同一key的资源，就先进行加锁（java里的synchronized或lock）。</p>
<p>方案3 利用redis的setnx实现内置的锁。</p>
<h3 id="redis和memcached的区别（总结）"><a href="#redis和memcached的区别（总结）" class="headerlink" title="redis和memcached的区别（总结）"></a>redis和memcached的区别（总结）</h3><p>1、Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；</p>
<p>2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；</p>
<p>3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；</p>
<p>4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10；</p>
<p>5、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从；</p>
<p>6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；</p>
<p>7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；</p>
<p>8、Redis支持数据的备份，即master-slave模式的数据备份；</p>
<p>应用场景</p>
<p>redis：数据量较小的更性能操作和运算上</p>
<p>memcache：用于在动态系统中减少数据库负载，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）</p>
<p>MongoDB:主要解决海量数据的访问效率问题</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>八大查找</title>
    <url>/Python/%E5%85%AB%E5%A4%A7%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>算法简介 顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。 基本思路 从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。 优缺点 缺点：是当n 很大时，平均查找长度较大，效率低； 优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。 算法实现 <a id="more"></a></p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">def sequential_search(lis, <span class="meta">key</span>):</span><br><span class="line">  <span class="meta">length</span> = l<span class="meta">en(</span>lis)</span><br><span class="line">  for i <span class="meta">in</span><span class="meta"> range(</span><span class="meta">length</span>):</span><br><span class="line">    <span class="meta">if</span> lis[i] == <span class="meta">key</span>:</span><br><span class="line">      <span class="meta">return</span> i</span><br><span class="line">    <span class="meta">else</span>:</span><br><span class="line">      <span class="meta">return</span> False</span><br></pre></td></tr></table></figure>

<h1 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h1><p>二分查找（Binary Search），是一种在有序数组中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。 这种查找算法每一次比较都使查找范围缩小一半。</p>
<p>算法描述 给予一个包含 个带值元素的数组A 1、 令 L为0 ， R为 n-1 2、 如果L&gt;R，则搜索以失败告终 3、 令 m (中间值元素)为 ⌊(L+R)/2⌋ 4、 如果 AmT，令 R为 m - 1 并回到步骤二 复杂度分析 时间复杂度：折半搜索每次把搜索区域减少一半，时间复杂度为 O(logn) 空间复杂度：O(1)</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">def binary_search(lis, key):</span><br><span class="line">  low = <span class="number">0</span></span><br><span class="line">  high = <span class="built_in">len</span>(lis) - <span class="number">1</span></span><br><span class="line">  <span class="built_in">time</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> low &lt; high:</span><br><span class="line">    <span class="built_in">time</span> += <span class="number">1</span></span><br><span class="line">    <span class="keyword">mid</span> = int((low + high) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> key &lt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">    elif key &gt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 打印折半的次数</span></span><br><span class="line">      print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">      <span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">  print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">  <span class="literal">return</span> False</span><br></pre></td></tr></table></figure>

<h1 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h1><p>算法简介</p>
<p>插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。 时间复杂度o(logn)但对于表长较大而关键字分布比较均匀的查找表来说，效率较高。</p>
<p>算法思想 基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。 注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p>
<p>复杂度分析 时间复杂性：如果元素均匀分布，则O（log log n）），在最坏的情况下可能需要O（n）。 空间复杂度：O（1）。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">def binary_search(lis, key):</span><br><span class="line">  low = <span class="number">0</span></span><br><span class="line">  high = <span class="built_in">len</span>(lis) - <span class="number">1</span></span><br><span class="line">  <span class="built_in">time</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> low &lt; high:</span><br><span class="line">    <span class="built_in">time</span> += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 计算mid值是插值算法的核心代码</span></span><br><span class="line">    <span class="keyword">mid</span> = low + int((high - low) * (key - lis[low])/(lis[high] - lis[low]))</span><br><span class="line">    print(<span class="string">"mid=%s, low=%s, high=%s"</span> % (<span class="keyword">mid</span>, low, high))</span><br><span class="line">    <span class="keyword">if</span> key &lt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">    elif key &gt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 打印查找的次数</span></span><br><span class="line">      print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">      <span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">  print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">  <span class="literal">return</span> False</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  LIST = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">  <span class="built_in">result</span> = binary_search(LIST, <span class="number">444</span>)</span><br><span class="line">  print(<span class="built_in">result</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝与浅拷贝的区别</title>
    <url>/Python/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="深拷贝和浅拷贝之间的区别是什么？"><a href="#深拷贝和浅拷贝之间的区别是什么？" class="headerlink" title="深拷贝和浅拷贝之间的区别是什么？"></a>深拷贝和浅拷贝之间的区别是什么？</h1><p>对象的赋值就是简单的引用,a = [1,2,3], b=a, 在上述情况下,a和b是一样的,他们指向同一片内存,b不过是a的别名,是引用,我们可以使用b is a 去判断,返回True,表名他们地址相同内容也相同,也可以使用id()函数来查看.看两个列表地址是否相同.<a id="more"></a></p>
<p>深拷贝就是将一个对象拷贝到另一个对象中，这意味着如果你对一个对象的拷贝做出改变时，不会影响原对象。在Python中，我们使用函数deepcopy()执行深拷贝</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">copy</span></span><br><span class="line">b=<span class="built_in">copy</span>.deepcopy(a)</span><br></pre></td></tr></table></figure>

<p><img src="https://v3u.cn/book/img/deepcopy.jpg" alt="avatar"></p>
<p>而浅拷贝则是将一个对象的引用拷贝到另一个对象上，所以如果我们在拷贝中改动，会影响到原对象。我们使用函数function()执行浅拷贝</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">b=<span class="keyword">copy</span>.<span class="keyword">copy</span>(a)</span><br></pre></td></tr></table></figure>

<p><img src="https://v3u.cn/book/img/copy.jpg" alt="img"></p>
<p>切片操作是浅拷贝</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下yum Mongodb安装</title>
    <url>/Mongodb/Mongodb/</url>
    <content><![CDATA[<h1 id="CentOS下yum-Mongodb安装？"><a href="#CentOS下yum-Mongodb安装？" class="headerlink" title="CentOS下yum Mongodb安装？"></a>CentOS下yum Mongodb安装？</h1><a id="more"></a>
<p>MongoDB的安装<br>CentOS 中使用yum安装：</p>
<p>touch /etc/yum.repos.d/mongodb-org-4.2.repo<br>vim /etc/yum.repos.d/mongodb-org-4.2.repo<br>添加如下内容：<br>[mongodb-org-4.2]<br>name=MongoDB Repository<br>baseurl=<a href="https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/" target="_blank" rel="noopener">https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/</a><br>gpgcheck=1<br>enabled=1<br>gpgkey=<a href="https://www.mongodb.org/static/pgp/server-4.2.asc" target="_blank" rel="noopener">https://www.mongodb.org/static/pgp/server-4.2.asc</a><br>使用yum安装：<br>yum install -y mongodb-org<br>启动时指定配置文件：</p>
<p>mongod -f /etc/mongo/mongod.conf</p>
<p>参考：</p>
<p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</a></p>
<p>MongoDB如何导入数据？<br>wget <a href="http://labfile.oss.aliyuncs.com/courses/1196/monkey_source_docs_json.dat" target="_blank" rel="noopener">http://labfile.oss.aliyuncs.com/courses/1196/monkey_source_docs_json.dat</a><br>mongoimport -d monkey -c source_docs monkey_source_docs_json.dat<br>MongoDB如何导出数据？<br>Mongodb中的mongoexport工具可以把一个collection导出成JSON格式或CSV格式的文件。可以通过参数指定导出的数据项，也可以根据指定的条件导出数据。<br>MongoDB如何备份数据？<br>mongodump -h dbhost -d dbname -o dbdirectory<br>-h：MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017<br>-d：需要备份的数据库实例，例如：test<br>-o：备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。<br>MongoDB如何恢复数据<br>mongorestore -h <hostname>&lt;:port&gt; -d dbname <path><br>–host &lt;:port&gt;, -h &lt;:port&gt;：<br>MongoDB所在服务器地址，默认为： localhost:27017<br>–db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2<br>–drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！<br><path>：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。你不能同时指定 <path> 和 –dir 选项，–dir也可以设置备份目录。<br>–dir：指定备份的目录,你不能同时指定 <path> 和 –dir 选项。<br>结巴分词<br>参考资料：</p>
<p><a href="https://www.cnblogs.com/clsn/p/8244206.html#auto_id_9" target="_blank" rel="noopener">https://www.cnblogs.com/clsn/p/8244206.html#auto_id_9</a></p>
<p><a href="https://motor.readthedocs.io/en/stable/tutorial-asyncio.html" target="_blank" rel="noopener">https://motor.readthedocs.io/en/stable/tutorial-asyncio.html</a></p>
]]></content>
      <categories>
        <category>Mongodb</category>
      </categories>
      <tags>
        <tag>Mongdb</tag>
      </tags>
  </entry>
  <entry>
    <title>随机验证码</title>
    <url>/Python/%E9%9A%8F%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<h1 id="验证码的书写"><a href="#验证码的书写" class="headerlink" title="验证码的书写"></a>验证码的书写</h1><p>​    验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分<a href="https://baike.baidu.com/item/计算机" target="_blank" rel="noopener">计算机</a>和人类的<a href="https://baike.baidu.com/item/图灵测试" target="_blank" rel="noopener">图灵测试</a>）的缩写，是一种区分用户是计算机还是人的公共全自动<a href="https://baike.baidu.com/item/程序/71525" target="_blank" rel="noopener">程序</a>。可以防止：恶意破解密码、<a href="https://baike.baidu.com/item/刷票/6540942" target="_blank" rel="noopener">刷票</a>、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。<a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Django</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> make_password,check_password</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> web.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入图片库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入绘画库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageDraw</span><br><span class="line"><span class="comment">#字体库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont</span><br><span class="line"><span class="comment">#随机库</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#图片库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="comment">#文件流</span></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取随机6位字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_str</span><span class="params">()</span>:</span></span><br><span class="line">    a_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>)])  <span class="comment">#小写字母</span></span><br><span class="line">    A_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>)])   <span class="comment">#大写字母</span></span><br><span class="line">    num_=[str(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>)]   <span class="comment">#数字 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(a_+A_+num_,<span class="number">4</span>))  <span class="comment">#返回随机4位字符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义验证码类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mycode</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment">#定义随机取色方法,混淆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_random_color</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#三原色</span></span><br><span class="line">        R=random.randrange(<span class="number">255</span>)</span><br><span class="line">        G=random.randrange(<span class="number">255</span>)</span><br><span class="line">        B=random.randrange(<span class="number">255</span>)</span><br><span class="line">        <span class="keyword">return</span> (R,G,B)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#定义画布</span></span><br><span class="line">        image_size=(<span class="number">120</span>,<span class="number">60</span>)</span><br><span class="line">        <span class="comment">#定义图像 颜色种类  画布  背景颜色</span></span><br><span class="line">        image=Image.new(<span class="string">'RGB'</span>,image_size,<span class="string">'white'</span>)</span><br><span class="line">        <span class="comment">#定义画笔</span></span><br><span class="line">        draw=ImageDraw.Draw(image,<span class="string">'RGB'</span>)</span><br><span class="line">        <span class="comment">#随机字符串的组成</span></span><br><span class="line">        source=get_random_str()</span><br><span class="line">        <span class="comment">#定义一个容器，接收</span></span><br><span class="line">        code_str=<span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="comment">#取色</span></span><br><span class="line">            text_color=self.get_random_color()</span><br><span class="line">            <span class="comment">#获取一个字符串</span></span><br><span class="line">            tmp_num=random.randrange(len(source))</span><br><span class="line">            <span class="comment">#获取字符集</span></span><br><span class="line">            random_str=source[tmp_num]</span><br><span class="line">            <span class="comment">#将随机生成的字符串放入定义好的容器</span></span><br><span class="line">            code_str+=random_str</span><br><span class="line">            <span class="comment">#将文字输入绘图</span></span><br><span class="line">            <span class="comment">#宽高，字符，颜色</span></span><br><span class="line">            draw.text((<span class="number">10</span>+<span class="number">30</span>*i,<span class="number">20</span>),random_str,text_color)</span><br><span class="line">        <span class="comment">#建立io文件流</span></span><br><span class="line">        buf=io.BytesIO()</span><br><span class="line">        <span class="comment">#将图片内容保存在内存中</span></span><br><span class="line">        image.save(buf,<span class="string">'png'</span>)</span><br><span class="line">        <span class="comment">#将验证码放入session</span></span><br><span class="line">        request.session[<span class="string">'code'</span>]=code_str</span><br><span class="line">        <span class="comment">#可以存入redis中   建立连接   存key  取key</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(buf.getvalue(),<span class="string">'image/png'</span>)   <span class="comment">#从内存中获取数据</span></span><br></pre></td></tr></table></figure>





<h4 id="点击图片且刷新"><a href="#点击图片且刷新" class="headerlink" title="点击图片且刷新"></a>点击图片且刷新</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">&lt;image <span class="string">":src=src"</span> <span class="meta">@click</span>=<span class="string">'changecode'</span>&gt;</span><br><span class="line">src=<span class="string">'http://127.0.0.1:8000/api/mycode/'</span></span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">	<span class="comment">//点击刷新验证码</span></span><br><span class="line">	<span class="comment">//每次给它传一个随机字符,只要传了参数，就不会缓存，直接刷新</span></span><br><span class="line">	<span class="comment">//在js中随机生成字符</span></span><br><span class="line">	<span class="keyword">let</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">this</span>.src=<span class="keyword">this</span>.src+<span class="string">'?code='</span>+num;</span><br><span class="line">	</span><br><span class="line">	changecode()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>&#39;hexo快速搭建博客&#39;</title>
    <url>/Python/hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>使用Hexo建立一个轻量、简易、高逼格的博客</p>
<pre><code>在之前的一篇文章中，介绍了如何使用Hugo在三分钟之内建立一个简单的个人博客系统，它是基于go lang的，其实，市面上还有一款类似的静态页生成器，就是Hexo 读音/hækso/ ，它是基于node.js的，和Hugo一样，Hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。</code></pre><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">首先安装Hexo，在此之前，请确保电脑里已经安装好新版的<span class="keyword">node</span>.<span class="title">js</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>npm install -g hexo-cli</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">如果感觉安装速度比较慢，可以为<span class="built_in">npm</span>指定国内的源</span><br></pre></td></tr></table></figure>

<p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装完成后，创建博客项目</span><br></pre></td></tr></table></figure>

<p>hexo init blog</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">这样，就建立起了一个<span class="keyword">blog文件夹，进入到blog目录下 </span>cd <span class="keyword">blog，建立第一篇文章</span></span><br></pre></td></tr></table></figure>

<p>hexo new myfirst</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">然后运行hexo服务</span><br></pre></td></tr></table></figure>

<p>hexo server</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">就可以在本地访问你的博客网站了，默认端口号是<span class="number">4000</span></span><br><span class="line"></span><br><span class="line">那么如何将博客网站打包呢？直接运行打包命令，这样就能使用 Hexo 引擎将 Markdown 格式的文件解析成可以使用浏览器查看的 HTML 文件，HTML 文件存储在 blog/<span class="keyword">public</span> 目录下</span><br></pre></td></tr></table></figure>

<p>hexo generate</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">下面我们可以配置一下hexo主题，Hexo 提供了默认主题 landscape，主题的位置在 blog -&gt;themes 文件夹下。主题根据自己喜好可以在网上找到<span class="symbol">:https</span><span class="symbol">://hexo</span>.io/themes/</span><br><span class="line"></span><br><span class="line">主题都放在blog/themes文件夹下面，这我们下载一个新的主题</span><br></pre></td></tr></table></figure>

<p>mkdir themes/next<br>git clone –branch v5.1.2 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">然后在修改 <span class="regexp">/blog/</span>config.yml 文件，将其中的 theme 改成 <span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">如果没有自己的域名和服务器怎么办？没关系，可以申请 <span class="selector-tag">Github</span> 免费静态内容空间，在<span class="selector-tag">github</span><span class="selector-class">.com</span>注册一个账号，然后创建一个新的仓库</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">仓库名称一定要定义成 账号名<span class="selector-class">.github</span><span class="selector-class">.io</span>，这种形式，注意账号名一定要和你的<span class="selector-tag">github</span>当前登录的账号吻合</span><br></pre></td></tr></table></figure>

<p>​      </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">这样你的静态内容空间就已经创建好了，在浏览器输入你的 <span class="string">https:</span><span class="comment">//你的账号.github.io/ 就可以访问了。</span></span><br><span class="line"></span><br><span class="line">将之前打包好的<span class="keyword">public</span>中的文件push到刚刚创建好的github仓库中去</span><br><span class="line"></span><br><span class="line">访问静态空间网址<span class="string">https:</span><span class="comment">//仓库名.github.io</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>没有问题，搞定收工</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>send_verify</title>
    <url>/Python/send-verify/</url>
    <content><![CDATA[<h1 id="Django-vue-验证码发送"><a href="#Django-vue-验证码发送" class="headerlink" title="Django +vue 验证码发送"></a>Django +vue 验证码发送</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> web.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL   <span class="comment">#settings里的一些配置</span></span><br><span class="line"><span class="keyword">import</span> random </span><br><span class="line"></span><br><span class="line"><span class="comment">#settings配置具体如下:</span></span><br><span class="line">	EMAIL_USE_SSL = <span class="literal">True</span> <span class="comment"># Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议</span></span><br><span class="line">    EMAIL_HOST = <span class="string">'smtp.qq.com'</span>  <span class="comment"># 邮件服务器地址</span></span><br><span class="line">    EMAIL_PORT = <span class="number">465</span> <span class="comment"># 邮件服务器端口</span></span><br><span class="line"> </span><br><span class="line">    EMAIL_HOST_USER = <span class="string">'1315532054@qq.com'</span> <span class="comment"># 登陆邮件服务器的账号</span></span><br><span class="line">    EMAIL_HOST_PASSWORD = <span class="string">'ownkpkdkumubhdjg'</span>  <span class="comment"># 登陆邮件服务器的密码</span></span><br><span class="line">    DEFAULT_FROM_EMAIL = EMAIL_HOST_USER <span class="comment"># 邮件的发送者</span></span><br></pre></td></tr></table></figure>

<!-- < !--more--> 

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取随机6位字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_str</span><span class="params">()</span>:</span></span><br><span class="line">    a_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>)])</span><br><span class="line">    A_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>)])</span><br><span class="line">    num_=[str(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(a_+A_+num_,<span class="number">6</span>))</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#邮件发送</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">send_verify</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">           1. 先检查 对应邮件是否再memcache里已经存在了验证码</span></span><br><span class="line"><span class="string">           2. 发现没有存在,那么需要生成6位随机字符</span></span><br><span class="line"><span class="string">           3. 存储入到memcache里,并设置60s的过期时间</span></span><br><span class="line"><span class="string">               email: 6str :60s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           遇到了同步发送邮件的问题,应该怎么办</span></span><br><span class="line"><span class="string">       '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        email=request.data[<span class="string">'email'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># email=request.POST.get('email')</span></span><br><span class="line">        <span class="comment"># 1. 先检查 对应邮件是否再memcache里已经存在了验证码</span></span><br><span class="line">        token=men.get(email)</span><br><span class="line">        <span class="comment">#2.如果没有存在，那么需要生成随机字符</span></span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'code'</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="string">'message'</span>:<span class="string">'该邮箱已存在验证码'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#该邮箱没有，生成随机字符</span></span><br><span class="line">            token=get_random_str()  <span class="comment">#随机字符</span></span><br><span class="line">            subject=<span class="string">'实验楼。。。。。。。。。。。'</span></span><br><span class="line">            message=<span class="string">'你的验证码是:%s'</span>%token</span><br><span class="line">            men.set(email,token,<span class="number">100</span>)  <span class="comment">#存储到memcache</span></span><br><span class="line">            <span class="comment"># print(men.get(token))</span></span><br><span class="line">            send_mail(subject,message,DEFAULT_FROM_EMAIL,[email])</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'code'</span>:<span class="number">1</span>,</span><br><span class="line">                <span class="string">'message'</span>:<span class="string">'验证码已发送'</span></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>





<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">send_verify()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!this.email)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        let form_data=new FormData()</span><br><span class="line">        form_data.append(<span class="string">'email'</span>,this.email)</span><br><span class="line"></span><br><span class="line">        axios(&#123;</span><br><span class="line">            url:<span class="string">'http://127.0.0.1:8000/api/send_verify/'</span>,</span><br><span class="line">            method:<span class="string">'post'</span>,</span><br><span class="line">            data:form_data</span><br><span class="line">        &#125;).then(res=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.data.code==<span class="number">1</span>)&#123;</span><br><span class="line">                alert(res.data.message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="关于数据结构"><a href="#关于数据结构" class="headerlink" title="关于数据结构"></a>关于数据结构</h1><h5 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h5><p>简单地说，数据结构是以某种特定的布局方式存储数据的容器。这种“布局方式”决定了数据结构对于某些操作是高效的，而对于其他操作则是低效的。首先我们需要理解各种数据结构，才能在处理实际问题时选取最合适的数据结构。<a id="more"></a></p>
<h5 id="为什么我们需要数据结构？"><a href="#为什么我们需要数据结构？" class="headerlink" title="为什么我们需要数据结构？"></a>为什么我们需要数据结构？</h5><p>数据是计算机科学当中最关键的实体，而数据结构则可以将数据以某种组织形式存储，因此，数据结构的价值不言而喻。</p>
<p>无论你以何种方式解决何种问题，你都需要处理数据——无论是涉及员工薪水、股票价格、购物清单，还是只是简单的电话簿问题。</p>
<p>数据需要根据不同的场景，按照特定的格式进行存储。有很多数据结构能够满足以不同格式存储数据的需求。</p>
<h5 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h5><p>首先列出一些最常见的数据结构，我们将逐一说明：</p>
<p>数组 栈 队列 链表 树 字典树（这是一种高效的树形结构，但值得单独说明） 散列表（哈希表）</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均由数组演变而来。下图是一个包含元素（1，2，3和4）的简单数组，数组长度为4。</p>
<p>每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。</p>
<p>以下是数组的两种类型：</p>
<p>一维数组（如上所示） 多维数组（数组的数组）</p>
<p>数组的基本操作</p>
<p>Insert——在指定索引位置插入一个元素 Get——返回指定索引位置的元素 Delete——删除指定索引位置的元素 Size——得到数组所有元素的数量</p>
<p>面试中关于数组的常见问题</p>
<p>寻找数组中第二小的元素 找到数组中第一个不重复出现的整数 合并两个有序数组 重新排列数组中的正值和负值</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>著名的撤销操作几乎遍布任意一个应用。但你有没有思考过它是如何工作的呢？这个问题的解决思路是按照将最后的状态排列在先的顺序，在内存中存储历史工作状态（当然，它会受限于一定的数量）。这没办法用数组实现。但有了栈，这就变得非常方便了。</p>
<p>可以把栈想象成一列垂直堆放的书。为了拿到中间的书，你需要移除放置在这上面的所有书。这就是LIFO（后进先出）的工作原理。</p>
<p>下图是包含三个数据元素（1，2和3）的栈，其中顶部的3将被最先移除：</p>
<h5 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h5><p>Push——在顶部插入一个元素 Pop——返回并移除栈顶元素 isEmpty——如果栈为空，则返回true Top——返回顶部元素，但并不移除它</p>
<h5 id="面试中关于栈的常见问题"><a href="#面试中关于栈的常见问题" class="headerlink" title="面试中关于栈的常见问题"></a>面试中关于栈的常见问题</h5><p>使用栈计算后缀表达式 对栈的元素进行排序 判断表达式是否括号平衡</p>
<p>应用场景：逆序输出，语法检查，进制转换</p>
<p>在我们日常编程中，括号都是成对出现的，比如“()”“[]”“{}”“&lt;&gt;”这些成对出现的符号</p>
<p>那么具体处理的方法就是:凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p>
<p>将十进制的数转换为2-9的任意进制的数</p>
<p>我们都知道，通过求余法，可以将十进制数转换为其他进制，比如要转为八进制，将十进制数除以8，记录余数，然后继续将商除以8，一直到商等于0为止，最后将余数倒着写数来就可以了。</p>
<p>比如100的八进制，100首先除以8商12余4,4首先进栈，然后12除以8商1余4，第二个余数4进栈，接着1除以8，商0余1，第三个余数1进栈，最后将三个余数出栈，就得到了100的八进制数144,</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>与栈相似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO，即先进先出。</p>
<p>一个完美的队列现实例子：售票亭排队队伍。如果有新人加入，他需要到队尾去排队，而非队首——排在前面的人会先拿到票，然后离开队伍。</p>
<p>下图是包含四个元素（1，2，3和4）的队列，其中在顶部的1将被最先移除：</p>
<p>移除先入队的元素、插入新元素</p>
<h5 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h5><p>Enqueue()——在队列尾部插入元素 Dequeue()——移除队列头部的元素 isEmpty()——如果队列为空，则返回true Top()——返回队列的第一个元素</p>
<p>面试中关于队列的常见问题</p>
<p>使用队列表示栈 对队列的前k个元素倒序 使用队列生成从1到n的二进制数</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是另一个重要的线性数据结构，乍一看可能有点像数组，但在内存分配、内部结构以及数据插入和删除的基本操作方面均有所不同。</p>
<p>链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。 链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。</p>
<p>链表一般用于实现文件系统、哈希表和邻接表。</p>
<p>这是链表内部结构的展示：</p>
<p>链表包括以下类型：</p>
<p>单链表（单向） 双向链表（双向）</p>
<h5 id="链表的基本操作："><a href="#链表的基本操作：" class="headerlink" title="链表的基本操作："></a>链表的基本操作：</h5><p>InsertAtEnd - 在链表的末尾插入指定元素 InsertAtHead - 在链接列表的开头/头部插入指定元素 Delete - 从链接列表中删除指定元素 DeleteAtHead - 删除链接列表的第一个元素 Search - 从链表中返回指定元素 isEmpty - 如果链表为空，则返回true</p>
<p>面试中关于链表的常见问题</p>
<p>反转链表 检测链表中的循环 返回链表倒数第N个节点 删除链表中的重复项</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树形结构是一种层级式的数据结构，由顶点（节点）和连接它们的边组成。 树类似于图，但区分树和图的重要特征是树中不存在环路。</p>
<p>树形结构被广泛应用于人工智能和复杂算法，它可以提供解决问题的有效存储机制。</p>
<p>这是一个简单树的示意图，以及树数据结构中使用的基本术语：</p>
<p>Root - 根节点</p>
<p>Parent - 父节点</p>
<p>Child - 子节点</p>
<p>Leaf - 叶子节点</p>
<p>Sibling - 兄弟节点</p>
<p>以下是树形结构的主要类型：</p>
<p>N元树 平衡树 二叉树 二叉搜索树 AVL树 红黑树 2-3树</p>
<p>其中，二叉树和二叉搜索树是最常用的树。</p>
<h5 id="面试中关于树结构的常见问题："><a href="#面试中关于树结构的常见问题：" class="headerlink" title="面试中关于树结构的常见问题："></a>面试中关于树结构的常见问题：</h5><p>求二叉树的高度 在二叉搜索树中查找第k个最大值 查找与根节点距离k的节点 在二叉树中查找给定节点的祖先节点</p>
<p>字典树（Trie）</p>
<p>字典树，也称为“前缀树”，是一种特殊的树状数据结构，对于解决字符串相关问题非常有效。它能够提供快速检索，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于IP的路由。</p>
<p>这些单词以顶部到底部的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“theirs”的底部。</p>
<p>面试中关于字典树的常见问题</p>
<p>计算字典树中的总单词数 打印存储在字典树中的所有单词 使用字典树对数组的元素进行排序 使用字典树从字典中形成单词 构建T9字典（字典树+ DFS ）</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键（key）”）中的过程。因此，对象以键值对的形式存储，这些键值对的集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。</p>
<p>哈希表通常使用数组实现。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql事务</title>
    <url>/Mysql/Mysql%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h1><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！<a id="more"></a></p>
<ul>
<li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li>
<li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li>
<li>事务用来管理 insert,update,delete 语句</li>
</ul>
<p>一般来说，事务是必须满足4个条件（ACID）：：原子性（<strong>A</strong>tomicity，或称不可分割性）、一致性（<strong>C</strong>onsistency）、隔离性（<strong>I</strong>solation，又称独立性）、持久性（<strong>D</strong>urability）。</p>
<ul>
<li><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<hr>
<p>‘- 显示数据库：show databases;</p>
<h5 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h5><p>​    sql server（微软）windows 专有数据<br>​    mysql    默认端口:3306<br>​    oracle（重点）甲骨文<br>​    access<br>​    sqlite<br>​    ibm db2<br>​    关系型数据库管理系统</p>
<p>-查看 mysql 版本： select version();<br>primary key 主键   auto_increment 自动递增   not null ,要求该约束所修饰的字段，不能为null或空    unsigned 约束的字段，会去掉负值，添加到正值，范围 x 2 + 1</p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>命令格式：select * from 表名 order by 字段名 asc(升序)|desc（降序）;<br>多字段排序<br>select * from department order by groups desc,kpi desc;<br>多字段排序时，先按第一字段排序，第一段相同的，再按第二字段排序。</p>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ul>
<li>创建数据库命令格式： <code>create database 数据库名字 charset=字符集</code></li>
<li>创建表命令格式: <code>create table 表名( 字段 属性 );</code></li>
</ul>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul>
<li>删除表<br>命令格式：drop table 表名;</li>
<li>删库<br>格式: <code>drop database 库名;</code><br>删除主键<br>alter table 表名 drop 主键字段名;<br>删除数据<br>命令格式<br>delete from 表名 where 【条件】</li>
</ul>
<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>-修改已创建的表名<br>命令格式：alter table 原表名 rename to  新表名;</p>
<p>旧改法：<br>      alter user ‘root’@’localhost’ identified by ‘mysql’;</p>
<p>-10.1.38-MariaDB 修改密码：<br>    update mysql.user set Password = password(‘1999’) where             user=’(root）’;<br>    flush privileges;<br>    exit;</p>
<p>远程链接:<br>    GRANT ALL PRIVILEGES ON * .* TO ‘root’@’%’ IDENTIFIED BY ‘root’ WITH GRANT OPTION;</p>
<p>mysql 配置文件：<br>     windows -&gt; mysql/bin/my.ini<br>     linux -&gt; mysq/my.cnf</p>
<h5 id="修改创建好的表字"><a href="#修改创建好的表字" class="headerlink" title="修改创建好的表字"></a>修改创建好的表字</h5><p>段命令格式: alter table 表名 change 原字段名 新字段名 字段类型 字段属性（约束）;<br>添加新的字段<br>命令格式: alter table 表名 add 字段名 字段类型 字段属性（约束）;<br>修改表名<br>命令格式：alter table 旧表名 rename to 新表名;<br>创建表后修改主键<br>alter table 表名 change 原字段名（要设为主键的字段） 新字段名 int primary key auto_incremnt not null;<br>修改数据<br>update 表名 set 字段名1=要修改值1,字段名2=要修改值2 where [条件]</p>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>基本查询<br>命令格式：select [要查询的字段，如果是所有字段，就是*;如果单个，写字段名] from 【表名】 where 【条件】<br>范围查询<br>命令格式： select [字段] from 表名 where 字段名 between 开始 and 结束<br>in ( ) 在 … 里 not in<br>模糊查询<br>命令格式： select [字段] from 表名 where 字段 like …%…<br>内联接查询<br>命令格式:select [字段] from 表名1 inner join 表名2 on 表名1.连接字段=表名2.连接字段<br>右链接<br>select * from student s right join class c on s.cls_id=c.id<br>左连接<br>select *  from class c left join student s on s.cls_id=c.id;<br>全联接<br> select * from class c left join student s on c.id=s.cls_id<br> union<br> select * from class c right join student s on c.id=s.cls_id;<br>自联接（自查询)<br>表和自身的连接，使用 inner join 来完成</p>
<h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><p>命令格式:<br>insert into 表名（字段名1,字段名2,字段名3…..）values(值1,值2,值3…);<br>另外一种形式<br>insert into 表名 values(字段1的值，字段2的值，字段3的值。。。。);</p>
<p>-分组<br>group by 分组<br>分组  group_concat()+group by </p>
<h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="-聚合函数"></a>-聚合函数</h5><p>统计函数 count（）<br>命令格式： select count(要统计的字段) from 表名 where [条件]<br>求最大值<br>命令格式：select max(求最大值的字段) from 表名;<br>求最小值<br>命令格式：select min(要计算最小值的字段) from 表名;<br>求和<br>命令格式:<br>select sum(要求和/总数的字段) from 表名;<br>求平均值<br>select avg(要求平均值字段) from 表名;</p>
<p>having<br>having 和 where 都 可以对记录进行筛选；但是having跟在group by 后面，group by 跟在 where 后面；having 后面条件必须在 select 字段中出现，没有，就会报错；where 是必须是表中字段<br>where … group by … having</p>
<h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p>命令格式：<br>create view 视图名字 as select语句;<br>查看视图<br>命令格式：show tables;<br>删除视图<br>drop view 视图名字<br>修改视图<br>create or replace view 视图名字 as select语句;</p>
<h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>查看索引<br>命令格式：<br>show index from 表名；<br>创建索引的命令<br>格式：<br>create index idx_索引名  on 表名（字段名（索引长度））<br>删除索引<br>命令格式:<br>drop index 索引名称 on 表名;</p>
<h5 id="三范式："><a href="#三范式：" class="headerlink" title="三范式："></a>三范式：</h5><p>1：确保每列保持原子性<br>2：确保表中每列都和主键直接相关<br>3：确保每列都和主键列直接相关，而不是间接相关</p>
<h5 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h5><p>​    是一个操作序列，这些操作要么都执行，要么都不执行，它是一个完整的，不可分割的工作单位。<br>事务具有的特性：原子性 ，一致，隔离，持久<br>开启事务：start transaction   / begin<br>提交         commit</p>
<p>当前时间加1天<br>select date_add(now(),interyal 1day)</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器</title>
    <url>/uncategorized/%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器本质上是一个Python函数，它可以让其它哈桑农户在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。比如：插入日志，性能测试，事务处理，缓存，权限校验等。有了装饰器我们就可以抽离处大量的与函数功能无关的雷同代码进行重用。装饰器其实就是一个闭包，把一个函数当做参数返回一个替代版函数。 <a id="more"></a> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrr</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="string">'111'</span>)</span><br><span class="line">		func()</span><br><span class="line">	<span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@wrr</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'222'</span>)</span><br><span class="line">my()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算函数执行时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">		strat=time.time()</span><br><span class="line">		print(<span class="string">'信任'</span>)</span><br><span class="line">		func()</span><br><span class="line">		last=time.time()</span><br><span class="line">		print(last-strat)</span><br><span class="line">	<span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@out</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ll</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'理解'</span>)</span><br><span class="line">	time.sleep(<span class="number">3</span>)</span><br><span class="line">ll()</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#带参装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_code</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> func(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wraper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_code()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'%s是歌手'</span> % name)</span><br><span class="line">sing(<span class="string">'张三'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#定义反扒装饰器,定义形参，一秒允许请求一次</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">limit</span><span class="params">(seconds=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment">#定义内部方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rate_limit</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func_limit</span><span class="params">(request)</span>:</span></span><br><span class="line">            <span class="comment">#获取当前时间</span></span><br><span class="line">            now = time.time()</span><br><span class="line">            <span class="comment">#获取首次来访时间</span></span><br><span class="line">            request_time = request.session.get(<span class="string">'req_time'</span>,<span class="number">0</span>)</span><br><span class="line">            <span class="comment">#做减法</span></span><br><span class="line">            in_time = int(now) - request_time</span><br><span class="line">            <span class="comment">#判断访问者在一秒内来了不止一次</span></span><br><span class="line">            <span class="keyword">if</span> in_time &lt; seconds:</span><br><span class="line">                <span class="comment">#抛出异常 ,使用第二个参数来指定异常</span></span><br><span class="line">                <span class="keyword">return</span> HttpResponse(<span class="string">'你是爬虫，不要来了'</span>,status=<span class="number">403</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#来的时间点存储</span></span><br><span class="line">                request.session[<span class="string">'req_time'</span>] = time.time()</span><br><span class="line">                <span class="comment">#让访问者继续访问</span></span><br><span class="line">                ret = func(request)</span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> func_limit</span><br><span class="line">    <span class="keyword">return</span> rate_limit</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个验证登录的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_login</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warpper</span><span class="params">(request,*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="comment">#is_login = request.session.get("username",False)</span></span><br><span class="line">        is_login = request.COOKIES.get(<span class="string">"username"</span>,<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> is_login:</span><br><span class="line">            ret = func(request,*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(<span class="string">"/supermarket"</span>)</span><br><span class="line">    <span class="keyword">return</span> warpper</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>八大排序</title>
    <url>/Python/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序；首先将第一个作为已经排好序的，然后每次从后的取出插入到前面并排序；<a id="more"></a></p>
<p>时间复杂度：O(n²)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">def insert_sort(<span class="keyword">ilist</span>):</span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="keyword">ilist</span>)):</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">ilist</span>[i] &lt; <span class="keyword">ilist</span>[<span class="keyword">j</span>]:</span><br><span class="line">                <span class="keyword">ilist</span>.<span class="keyword">insert</span>(<span class="keyword">j</span>, <span class="keyword">ilist</span>.<span class="keyword">pop</span>(i))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">ilist</span></span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成</p>
<p>时间复杂度：O(n²)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">def <span class="keyword">bubble_sort(blist):</span></span><br><span class="line"><span class="keyword"> </span>   <span class="built_in">count</span> = len(<span class="keyword">blist)</span></span><br><span class="line"><span class="keyword"> </span>   for i in range(<span class="number">0</span>, <span class="built_in">count</span>):</span><br><span class="line">        for <span class="keyword">j </span>in range(i + <span class="number">1</span>, <span class="built_in">count</span>):</span><br><span class="line">            if <span class="keyword">blist[i] </span>&gt; <span class="keyword">blist[j]:</span></span><br><span class="line"><span class="keyword"> </span>               <span class="keyword">blist[i], </span><span class="keyword">blist[j] </span>= <span class="keyword">blist[j], </span><span class="keyword">blist[i]</span></span><br><span class="line"><span class="keyword"> </span>   return <span class="keyword">blist</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">blist </span>= <span class="keyword">bubble_sort([4,5,6,7,3,2,6,9,8])</span></span><br><span class="line"><span class="keyword">print(blist)</span></span><br></pre></td></tr></table></figure>

<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p>
<p>时间复杂度：O(nlog₂n)</p>
<p>空间复杂度：O(nlog₂n)</p>
<p>稳定性：不稳定</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">def quick<span class="constructor">_sort(<span class="params">qlist</span>)</span>:</span><br><span class="line">    <span class="keyword">if</span> qlist<span class="operator"> == </span><span class="literal">[]</span>:</span><br><span class="line">        return <span class="literal">[]</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        qfirst = qlist<span class="literal">[<span class="number">0</span>]</span></span><br><span class="line">        qless = quick<span class="constructor">_sort([<span class="params">l</span> <span class="params">for</span> <span class="params">l</span> <span class="params">in</span> <span class="params">qlist</span>[1:] <span class="params">if</span> <span class="params">l</span> &lt; <span class="params">qfirst</span>])</span></span><br><span class="line">        qmore = quick<span class="constructor">_sort([<span class="params">m</span> <span class="params">for</span> <span class="params">m</span> <span class="params">in</span> <span class="params">qlist</span>[1:] <span class="params">if</span> <span class="params">m</span> &gt;= <span class="params">qfirst</span>])</span></span><br><span class="line">        return qless + <span class="literal">[<span class="identifier">qfirst</span>]</span> + qmore</span><br><span class="line"></span><br><span class="line">qlist = quick<span class="constructor">_sort([4,5,6,7,3,2,6,9,8])</span></span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕</p>
<p>时间复杂度：O(n²)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：不稳定</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">def select_sort(slist):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(slist)):</span><br><span class="line">        x = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(slist)):</span><br><span class="line">            <span class="keyword">if</span> slist[j] &lt; slist[x]:</span><br><span class="line">                x = j</span><br><span class="line">        slist[i], slist[x] = slist[x], slist[i]</span><br><span class="line">    <span class="keyword">return</span> slist</span><br><span class="line"></span><br><span class="line">slist = select_sort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序：采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并</p>
<p>时间复杂度：O(nlog₂n)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">def merge_sort(array):</span><br><span class="line">    def merge_arr(arr_l, arr_r):</span><br><span class="line">       <span class="built_in"> array </span>= []</span><br><span class="line">        while len(arr_l)<span class="built_in"> and </span>len(arr_r):</span><br><span class="line">           <span class="built_in"> if </span>arr_l[0] &lt;= arr_r[0]:</span><br><span class="line">                array.append(arr_l.pop(0))</span><br><span class="line">            elif arr_l[0] &gt; arr_r[0]:</span><br><span class="line">                array.append(arr_r.pop(0))</span><br><span class="line">       <span class="built_in"> if </span>len(arr_l) != 0:</span><br><span class="line">           <span class="built_in"> array </span>+= arr_l</span><br><span class="line">        elif len(arr_r) != 0:</span><br><span class="line">           <span class="built_in"> array </span>+= arr_r</span><br><span class="line">       <span class="built_in"> return </span>array</span><br><span class="line"></span><br><span class="line">    def recursive(array):</span><br><span class="line">       <span class="built_in"> if </span>len(array) == 1:</span><br><span class="line">           <span class="built_in"> return </span>array</span><br><span class="line">        mid = len(array) // 2</span><br><span class="line">        arr_l = recursive(array[:mid])</span><br><span class="line">        arr_r = recursive(array[mid:])</span><br><span class="line">       <span class="built_in"> return </span>merge_arr(arr_l, arr_r)</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> return </span>recursive(array)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟环境</title>
    <url>/Linux/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="构建爬虫系统"><a href="#构建爬虫系统" class="headerlink" title="构建爬虫系统"></a>构建爬虫系统</h1><h2 id="一、实现目的"><a href="#一、实现目的" class="headerlink" title="一、实现目的"></a>一、实现目的</h2><p>爬虫是文档的重要来源，所以这一节也比较重要，我会从爬虫的基础讲起，爬虫的构成如何编写爬虫等等，希望大家能跟着文档一步步动手做下去。<a id="more"></a></p>
<h4 id="1-1-实验知识点"><a href="#1-1-实验知识点" class="headerlink" title="1.1 实验知识点"></a>1.1 实验知识点</h4><ul>
<li>爬虫的基本概念</li>
<li>异步爬虫框架ruia的使用介绍</li>
<li>基于ruia构造异步爬虫系统</li>
</ul>
<h4 id="1-2-实验环境"><a href="#1-2-实验环境" class="headerlink" title="1.2 实验环境"></a>1.2 实验环境</h4><ul>
<li>Python 3.6+</li>
<li>MongoDB</li>
</ul>
<h2 id="二、开发准备"><a href="#二、开发准备" class="headerlink" title="二、开发准备"></a>二、开发准备</h2><h5 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建项目代码目录</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">-p ~/Code/monkey</span></span><br><span class="line"><span class="comment"># 进入项目根目录</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">~/Code/monkey</span></span><br><span class="line"><span class="comment"># 创建一个名叫env的虚拟环境(注：Python3自带pyenv)</span></span><br><span class="line"><span class="attr">python3</span> <span class="string">-m venv env  </span></span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line"><span class="attr">source</span> <span class="string">env/bin/activate</span></span><br><span class="line"><span class="comment"># 安装项目依赖的包</span></span><br><span class="line"><span class="attr">pip</span> <span class="string">install -r requirements.txt</span></span><br></pre></td></tr></table></figure>

<h2 id="三、小试牛刀"><a href="#三、小试牛刀" class="headerlink" title="三、小试牛刀"></a>三、小试牛刀</h2><h3 id="3-1-使用requests-lxml爬取网页"><a href="#3-1-使用requests-lxml爬取网页" class="headerlink" title="3.1 使用requests + lxml爬取网页"></a>3.1 使用requests + lxml爬取网页</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注：以下代码未经过运行测试，只是手写思路</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://movie.douban.com/subject/1292052/'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>:<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Safari/605.1.15"</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(url,headers=headers)</span><br><span class="line">tree = etree.HTML(r.text)</span><br><span class="line">el = tree.xpath(<span class="string">'//*[@id="content"]/h1/span[1]/text()'</span>)</span><br><span class="line">print(el)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-使用ruia框架爬取网页"><a href="#3-2-使用ruia框架爬取网页" class="headerlink" title="3.2 使用ruia框架爬取网页"></a>3.2 使用ruia框架爬取网页</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ruia <span class="keyword">import</span> Item, TextField</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanItem</span><span class="params">(Item)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    定义爬虫的目标字段</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    title = TextField(css_select=<span class="string">'#content &gt; h1 &gt; span:nth-child(1)'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async_func = DoubanItem.get_item(url=<span class="string">"https://movie.douban.com/subject/1292052/"</span>)</span><br><span class="line">item = asyncio.get_event_loop().run_until_complete(async_func)</span><br><span class="line">print(item.title)</span><br></pre></td></tr></table></figure>



<h2 id="上午主要内容总结"><a href="#上午主要内容总结" class="headerlink" title="上午主要内容总结"></a>上午主要内容总结</h2><ul>
<li><p>掌握快速学习的能力，任何框架都是那么容易</p>
</li>
<li><p>做项目时，一定要用虚拟环境，学会使用pip freeze &gt;&gt; requirements.txt命令，学会使用pip install -r requirements.txt</p>
<p>我们通常会把项目依赖的环境命名为“requirements.txt”</p>
</li>
<li><p>学会借力：例如，借助浏览器的copy xpath功能快速定位元素位置</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>四十岁的吃鸡玩家</title>
    <url>/Live/%E5%9B%9B%E5%8D%81%E5%B2%81%E7%9A%84%E5%90%83%E9%B8%A1%E7%8E%A9%E5%AE%B6/</url>
    <content><![CDATA[<p>四十岁的吃鸡玩家<br>我从家里出来，在马路边四处张望，寻找我叫的那辆滴滴快车。<br>司机已经来过电话，我拜托他多等一会儿，但现在已经过去了十多分钟，不知道他会不会已经取消订单。<br>情况并没有那么糟，我最终找到了那辆车。我上车之后才发现，司机居然在玩“刺激战场”。我看了一眼，三级包三级头，还挺肥。<br> <a id="more"></a><br>司机没有埋怨我的姗姗来迟，反而问我急不急着赶路。我连忙摆手，说道：“不急不急，你好好玩吧，这把有望吃鸡啊。”<br>司机一听，兴奋的说：“你也玩这个啊？”<br>“我就没事儿瞎玩玩。”<br>“你们年轻人玩这个应该挺厉害，我连前十都没进过几次。”<br>“哪有，你这把就很稳啊，这不马上就进前十了嘛。”<br>“哈哈，这把运气好…”<br>他话还没说完，就听见了一声枪响。他立刻集中精神，趴在草里，转动视角观察周围。<br>我也不再说话，静静的看他冲进决赛圈。</p>
<p>这时我才注意到，这位吃鸡玩家已经长了不少白发，脸上也有了皱纹。没想到这个年纪的大叔，也会热衷于吃鸡。</p>
<p>最后他止步于第二名，被一个穿着吉利服的“伏地魔”给淘汰了，只差一步就能吃鸡。我还觉得有些遗憾，他却十分满足。我忽然很好奇，他是因为什么开始玩这个游戏，他笑容一滞，随后说道：“因为我儿子喜欢玩这个，我就想着，要是我也玩的话，就能和他多说上几句话。”</p>
<p>我一时语塞，愣了片刻才缓缓开口：“你儿子真幸运，有你这样贴心的父亲。”<br>司机笑了笑：“嗐，天下哪个父母不是为了儿女操碎了心。”<br>“也是。你儿子多大了啊？”<br>“刚中考完，马上就高一了。”<br>他顿了顿，继续说道：“小时候还挺爱说话，上初中之后就不怎么和我聊天了。”<br>我安慰着：“叛逆期嘛，过了这段时间就好了。平时多陪陪他吧，比如一起吃鸡什么的。”<br>“现在每天晚上我都拉着他一起玩游戏，”他有些无奈，“但他嫌我技术差，不爱和我玩。每次都是我去睡的时候，他才能真正的和他的朋友玩。”</p>
<p>我忽然知道他为什么不会因为第二名而遗憾了，因为他在乎的从来都不是名次。第二名，意味着他的技术有了进步，意味着他能和儿子玩得更久。</p>
<p>我不知该如何接话。就在我沉默的时候，他又说道：“嘿嘿，我还打算下个‘王者荣耀’，我儿子也喜欢玩这个。”</p>
]]></content>
      <categories>
        <category>Live</category>
      </categories>
      <tags>
        <tag>Live</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础</title>
    <url>/Python/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h6 id="解释下Python中的三元运算？"><a href="#解释下Python中的三元运算？" class="headerlink" title="解释下Python中的三元运算？"></a>解释下Python中的三元运算？</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[on true <span class="keyword">if</span> [expression] <span class="keyword">else</span> [on false]]</span><br><span class="line"><span class="comment">#如果表达式为True,就执行[on true]中的语句。否则，就执行[on false]中的语句</span></span><br><span class="line">a,b=<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">min=a <span class="keyword">if</span> a&lt;b <span class="keyword">else</span> b</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h6 id="Python中的继承"><a href="#Python中的继承" class="headerlink" title="Python中的继承?"></a>Python中的继承?</h6><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">#当一个类继承自另一个类，它就被称为一个子类/派生类，继承自父类/基类/超类。它会继承/获取所有类成员(属性和方法)。继承能让我们重新使用代码，也能更容易的创建个维护使用。</span><br><span class="line">Python支持如下种类的继承：</span><br><span class="line">	<span class="number">1</span>.单继承：一个类继承自单个基类</span><br><span class="line">	<span class="number">2</span>.多继承:一个类继承自多个基类</span><br><span class="line">	<span class="number">3</span>.多级继承:一个类继承自单个基类，后者则继承自另一个基类</span><br><span class="line">	<span class="number">4</span>.分层继承:多个类继承自单个基类</span><br><span class="line">	<span class="number">5</span>.混合继承:俩种或多种类型继承的混合</span><br></pre></td></tr></table></figure>

<h6 id="解释Python中的help-和dir-函数"><a href="#解释Python中的help-和dir-函数" class="headerlink" title="解释Python中的help()和dir()函数"></a>解释Python中的help()和dir()函数</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">help()函数是一个内置函数，用于查看函数或模块用途的详细说明</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">help(copy.copy)</span><br><span class="line">dir()函数也是Python内置函数，dir()函数不带参数时，返回当前范围内的变量，方法和定义的类型列表；带参数时，返回参数的属性，方法列表</span><br><span class="line">dir(copy.copy)</span><br></pre></td></tr></table></figure>

<h6 id="什么是猴子补丁"><a href="#什么是猴子补丁" class="headerlink" title="什么是猴子补丁"></a>什么是猴子补丁</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在运行期间动态修改一个类或模块。通常功能是添加模块或者是修改功能</span></span><br></pre></td></tr></table></figure>

<h6 id="解释使用args和-kwargs的含义"><a href="#解释使用args和-kwargs的含义" class="headerlink" title="解释使用args和*kwargs的含义"></a>解释使用args和*kwargs的含义</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">当我们不知道向函数传递多少参数时，比如我们先传递一个列表或元组，我们就使用*args</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        print(i)  </span><br><span class="line">func(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">在我们不知道该传递多少关键字参数时，使用**kwargs来手机关键字参数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> kwargs:</span><br><span class="line">        print(i,kwargs[i])</span><br><span class="line">func(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<h6 id="什么是负索引"><a href="#什么是负索引" class="headerlink" title="什么是负索引"></a>什么是负索引</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">负索引和正索引不同，它是从右边开始检索。</span><br><span class="line">它也能用于列表中的切片：</span><br><span class="line">mylist=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">mylist[<span class="number">-3</span>]  <span class="number">3</span></span><br><span class="line">mylist[<span class="number">-6</span>:<span class="number">-1</span>]    <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span></span><br></pre></td></tr></table></figure>

<h6 id="Python中的join-和split-函数"><a href="#Python中的join-和split-函数" class="headerlink" title="Python中的join()和split()函数"></a>Python中的join()和split()函数</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Join()能让我们将指定字符添加至字符串中。</span><br><span class="line">Split()能让我们用指定字符分割字符串。</span><br></pre></td></tr></table></figure>

<h6 id="怎么移除一个字符串中的前导空格"><a href="#怎么移除一个字符串中的前导空格" class="headerlink" title="怎么移除一个字符串中的前导空格"></a>怎么移除一个字符串中的前导空格</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串中的前导空格就是出现在字符串中第一个非空格字符前的空格。我们使用方法lstrip()可以将之移除</span><br><span class="line"><span class="string">'  Hello World ! '</span>.lstrip()</span><br><span class="line">当然也有后缀字符，调用rstrip()将之移除</span><br><span class="line"><span class="string">'  Hello World ! '</span>.rstrip()</span><br></pre></td></tr></table></figure>

<h6 id="python中的pass语句是什么"><a href="#python中的pass语句是什么" class="headerlink" title="python中的pass语句是什么"></a>python中的pass语句是什么</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在使用python写代码时，有时可能还没想好函数怎么写，只写了函数声明，但为了保证语法正确，必须输入一些东西，在这种情况下，我们会使用<span class="keyword">pass</span>语句。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">同样，<span class="keyword">break</span>语句能让我们跳出循环</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">3</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(i)    <span class="comment">#0,1,2</span></span><br><span class="line">最后，<span class="keyword">continue</span>语句能让我们跳到一个循环</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">3</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(i)   <span class="comment">#0,1,2,4</span></span><br></pre></td></tr></table></figure>

<h6 id="python中的闭包是什么"><a href="#python中的闭包是什么" class="headerlink" title="python中的闭包是什么"></a>python中的闭包是什么</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">但一个嵌套函数在其外部区域引用了一个值时，该嵌套函数就是一个闭包。其意义就是会记录这个值</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line">     <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>

<h6 id="python的装饰器"><a href="#python的装饰器" class="headerlink" title="python的装饰器"></a>python的装饰器</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'先过我这一关！'</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@out</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">My</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'哈哈哈'</span>)</span><br><span class="line">My()</span><br><span class="line">装饰器本质上是一个python函数，它可以让其他函数在不做任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。比如：插入日志、性能测试、事务处理、缓存、权限校验等。有了装饰器我们就可以抽离出大量的与函数功能无关的雷同代码进行重用。</span><br><span class="line">装饰器其实就是一个闭包，把一个函数当做参数然后返回一个替代版函数</span><br></pre></td></tr></table></figure>

<h6 id="python中的逻辑运算符"><a href="#python中的逻辑运算符" class="headerlink" title="python中的逻辑运算符"></a>python中的逻辑运算符</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="keyword">or</span> <span class="keyword">not</span></span><br></pre></td></tr></table></figure>

<h6 id="python支持什么数据类型"><a href="#python支持什么数据类型" class="headerlink" title="python支持什么数据类型"></a>python支持什么数据类型</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Number(数字) 用于保存数值</span><br><span class="line">String(字符串) 字符串是一个字符序列。我们用单引号或双引号来声明字符串</span><br><span class="line">List(列表) 列表就是一些值的有序集合，我们用方括号声明列表。</span><br><span class="line">Tuples（元组）——元组和列表一样，也是一些值的有序集合，区别是元组是不可变的，意味着我们无法改变元组内的值。</span><br><span class="line">Dictionary（字典）——字典是一种数据结构，含有键值对。我们用大括号声明字典</span><br></pre></td></tr></table></figure>

<h6 id="什么是切片"><a href="#什么是切片" class="headerlink" title="什么是切片"></a>什么是切片</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">切片是python中的一种方法，能让我们只检索列表，元素或字符串的一部分。在切片时，我们使用切片操作符[]</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)[<span class="number">2</span>:<span class="number">4</span>]    <span class="comment">#(3,4)</span></span><br></pre></td></tr></table></figure>

<h6 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span>函数是一个简短的匿名函数</span><br><span class="line"><span class="keyword">lambda</span>函数可以接收任意数量的参数，但只能包含一个表达式</span><br><span class="line">接收参数，执行表达式，返回结果</span><br><span class="line">x= <span class="keyword">lambda</span> a: a+<span class="number">10</span>    <span class="comment">#一个lambda函数，把参数加10，然后返回结果</span></span><br><span class="line">print(x(<span class="number">5</span>))  <span class="comment">#15</span></span><br><span class="line">x=<span class="keyword">lambda</span> a,b :a+b  <span class="comment">#一个lambda函数，将参数a与b相加</span></span><br><span class="line">print(x(<span class="number">5</span>,<span class="number">6</span>))  <span class="comment">#11</span></span><br><span class="line">fib = <span class="keyword">lambda</span> n : n <span class="keyword">if</span> n &lt;= <span class="number">2</span> <span class="keyword">else</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>)  <span class="comment">#斐波那契</span></span><br></pre></td></tr></table></figure>

<h6 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在调用一个函的过程中，直接或间接的调用了函数本身这个就叫做递归，为了避免出现死循环，必须要有结束条件。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">facto</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n*facto(n<span class="number">-1</span>)</span><br><span class="line">print(facto(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion</span><span class="params">(n)</span>:</span>  <span class="comment"># 定义递归函数</span></span><br><span class="line">    print(n)  <span class="comment"># 打印n</span></span><br><span class="line">    recursion(n+<span class="number">1</span>)  <span class="comment"># 在函数的运行种调用递归 要有结束条件，负责无限递归</span></span><br><span class="line">    <span class="comment">#可为什么执行了900多次就报错了呢?还说超过了最大递归深度限制,为什么要限制呢?</span></span><br><span class="line">	<span class="comment">#通俗来讲,是因为每个函数在调用自己的时候,还没有退出,占内存,多了肯定会导致内存崩溃.</span></span><br><span class="line">recursion(<span class="number">1</span>)  <span class="comment"># 调用函数</span></span><br></pre></td></tr></table></figure>

<h6 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在 Python 中，使用了 <span class="keyword">yield</span> 的函数被称为生成器（generator）。</span><br><span class="line">生成器会生成一系列的值用于迭代，这样看它又是一种可迭代对象。它是在<span class="keyword">for</span>循环的过程中不断计算出下一个元素，并在适当的条件下结束循环。</span><br><span class="line">生成器也是一种迭代器，但是你只能对其迭代一次 [<span class="number">1</span>]  。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。你通过遍历来使用它们，要么用一个“<span class="keyword">for</span>”循环，要么将它们传递给任意可以进行迭代的函数和结构。大多数时候生成器是以函数来实现的。然而，它们并不返回一个值，而是<span class="keyword">yield</span>(暂且译作“生出”)一个值。</span><br></pre></td></tr></table></figure>

<h6 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">类中实现俩个方法__iter__() 与__next__()</span><br><span class="line">迭代器只能返回不能后退</span><br><span class="line">__init__() 它会在对象初始化的时候执行</span><br><span class="line">__iter__()返回一个特殊的迭代器对象，这个迭代器对象实现了__next__()方法并通过stoplteration异常标识迭代的完成。</span><br><span class="line">__next__()方法 会返回下一个迭代器对象。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br></pre></td></tr></table></figure>

<h6 id="迭代器和生成器的区别"><a href="#迭代器和生成器的区别" class="headerlink" title="迭代器和生成器的区别"></a>迭代器和生成器的区别</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在使用生成器时，我们创建一个函数；在使用迭代器时，我们使用内置函数iter()和next()。 在生成器中，我们使用关键字‘<span class="keyword">yield</span>’来每次生成/返回一个对象。 生成器中有多少‘<span class="keyword">yield</span>’语句，你可以自定义。 每次‘<span class="keyword">yield</span>’暂停循环时，生成器会保存本地变量的状态。而迭代器并不会使用局部变量，它只需要一个可迭代对象进行迭代。 使用类可以实现你自己的迭代器，但无法实现生成器。 生成器运行速度快，语法简洁，更简单。 迭代器更能节约内存。</span><br></pre></td></tr></table></figure>

<h6 id="如何在python中创建自己的包"><a href="#如何在python中创建自己的包" class="headerlink" title="如何在python中创建自己的包"></a>如何在python中创建自己的包</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python中创建包是比较方便的，只需在当前目录建立一个文件夹，文件夹中包含一个init.py文件和若干个模块文件，其中init.py可以是一个空文件，但还是建议将包中所有需要导出的变量放到all中，这样可以确保包的接口清晰明了，易于使用。</span><br></pre></td></tr></table></figure>

<h6 id="什么是元类"><a href="#什么是元类" class="headerlink" title="什么是元类"></a>什么是元类</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元类是类的类对象，换言之类是元类的实列，python中默认的元类为type,可以自定义元类的方法实现对类创建的空中。</span><br></pre></td></tr></table></figure>

<h6 id="在python中是如何管理内存的"><a href="#在python中是如何管理内存的" class="headerlink" title="在python中是如何管理内存的"></a>在python中是如何管理内存的</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python有一个私有堆空间来保存所有的对象和数据结构。</span><br><span class="line">python采用的是引用计数为主，分代回收为辅(引用计数，标记-清楚，分代回收)</span><br><span class="line">从三个方面来说</span><br><span class="line">一.对象的引用计数机制</span><br><span class="line">	引用计数增加的情况:</span><br><span class="line">        <span class="number">1.</span>一个对象分配一个新名称</span><br><span class="line">        <span class="number">2.</span>将其放入一个容器中(如列表，元组或字典)</span><br><span class="line">    引用计数减少的情况:</span><br><span class="line">        <span class="number">1.</span>使用<span class="keyword">del</span>语句对对象别名显示的销毁</span><br><span class="line">        <span class="number">2.</span>引用超出作用域或被重新赋值</span><br><span class="line">     sys.getrefcount()函数可以获得对象的当前引用计数</span><br><span class="line">二.垃圾回收机制</span><br><span class="line">	<span class="number">1.</span>当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。</span><br><span class="line">    <span class="number">2.</span>当俩个对象a和b相互引用时，<span class="keyword">del</span>语句可以减少a和b的引用计数，并销毁用于底层对象的名称</span><br><span class="line">三.内存机制</span><br><span class="line">	python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统</span><br><span class="line">    <span class="number">1.</span>pumalloc机制，为了加速python的执行效率，python引入了一个内存池机制，用于管理对小块内存的申请和施放</span><br><span class="line">    <span class="number">2.</span>对于python对象，如整数，浮点数，list都具有独立的私有的内存池，对详见不共享他们的内存池，也就是说如果你分配了又施放了大量的整数，用于缓存这些整数的内存就不再分配给浮点数。</span><br></pre></td></tr></table></figure>

<h6 id="深拷贝和浅拷贝之间的区别是什么"><a href="#深拷贝和浅拷贝之间的区别是什么" class="headerlink" title="深拷贝和浅拷贝之间的区别是什么"></a>深拷贝和浅拷贝之间的区别是什么</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">深拷贝就是将一个对象拷贝到另一个对象中，这意味着如果你对一个对象的拷贝做出改变时，不会影响原对象。</span><br><span class="line">浅拷贝是将一个对象的引用拷贝到另一个对象上，所以我们在拷贝中改动，会影响原对象。是对对象的顶层拷贝</span><br></pre></td></tr></table></figure>

<h6 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">普通实例方法，第一个参数需要是self,它表示一个具体的实例本身。</span><br><span class="line">如果用了staticmethod,那么就可以无视这个self.而将这个方法当成一个普通的函数使用。不需要任何参数，当然它也不能传递任何实列的属性和方法。静态方法，参数随意</span><br><span class="line">classmethod第一个参数必须是当前类的cls参数，通常它被预定为cls，通过它来调用类的属性和方法</span><br></pre></td></tr></table></figure>

<h6 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>是一种上下文管理协议，目的在于从流程图 中把<span class="keyword">try</span>,excerpt和<span class="keyword">finally</span>关键字和资源分配施放相关代码统统去掉，简化<span class="keyword">try</span>....excerpt...<span class="keyword">finally</span>的处理流程。<span class="keyword">with</span>通过enter方法初始化，然后在exit中做善后及处理异常。所以使用<span class="keyword">with</span>处理的对象必须又enter()和exit()这俩个方法。<span class="keyword">with</span>语句适用于对资源进行访问的场合。</span><br><span class="line"><span class="keyword">with</span>的使用场景 如果某项工作后完成需要有施放资源或者其他清理工作，比如说文件操作时，就可以适用<span class="keyword">with</span>优雅的处理，不用自己手动关闭文件包炳，而且<span class="keyword">with</span>还能很好的管理上下文异常。</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'demo.py'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">        print(i,end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<h6 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__new__是在一个对象实例化的时候所调用的第一个方法。它的第一个参数是这个类</span><br><span class="line">__init__用来构建初始化函数</span><br><span class="line">__str__如果类定义__Str__方法，那么就会打印从这个方法中<span class="keyword">return</span>的数据</span><br><span class="line">__del__当删除对象时，python解释器会调用</span><br><span class="line">__doc__打印当前类的描述信息，也就是注释部分</span><br><span class="line">__dict__ 打印类中的属性</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django相关</title>
    <url>/Django/Django/</url>
    <content><![CDATA[<h1 id="Django-、Flask、Tornado的对比"><a href="#Django-、Flask、Tornado的对比" class="headerlink" title="Django 、Flask、Tornado的对比"></a>Django 、Flask、Tornado的对比</h1><p>1.Django走的是大而全的方向,开发效率高。它的MTV框架,自带的ORM,admin后台管理,自带的sqlite数据库和开发测试用的服务器 给开发者提高了超高的开发效率</p>
<p>2.Flask是轻量级的框架,自由,灵活,可扩展性很强,核心基于Werkzeug WSGI工具和jinja2模板引擎</p>
<p>3.Tornado走的是少而精的方向,性能优越。它最出名的是异步非阻塞的设计方式</p>
<p>Tornado的两大核心模块： 1.iostraem：对非阻塞式的socket进行简单的封装 2.ioloop：对I/O多路复用的封装，它实现了一个单例<a id="more"></a></p>
<h2 id="什么是wsgi？"><a href="#什么是wsgi？" class="headerlink" title="什么是wsgi？"></a>什么是wsgi？</h2><p>WSGI，描述web server如何与web application通信的一种规范</p>
<p>WSGI协议主要包括server和application两部分：</p>
<p>WSGI server负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端； WSGI application接收由server转发的request，处理请求，并将处理结果返回给server。</p>
<p>application中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现server与application，因此可以在WSGI服务器与WSGI应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。</p>
<h2 id="简述什么是FBV和CBV？"><a href="#简述什么是FBV和CBV？" class="headerlink" title="简述什么是FBV和CBV？"></a>简述什么是FBV和CBV？</h2><p>FBV（function base views） 基于函数的视图 CBV（class base views） 基于类的视图</p>
<p>使用fbv的模式,在url匹配成功之后,会直接执行对应的视图函数</p>
<p>使用cbv模式,在url匹配成功之后,会找到视图函数中对应的类,然后这个类回到请求头中找到对应的Request Method</p>
<p>用户发送url请求,Django会依次遍历路由映射表中的所有记录,一旦路由映射表其中的一条匹配成功了,就执行视图函数中对应的函数名,这是fbv的执行流程</p>
<p>当服务端使用cbv模式的时候,用户发给服务端的请求包含url和method,这两个信息都是字符串类型 服务端通过路由映射表匹配成功后会自动去找dispatch方法,然后Django会通过dispatch反射的方式找到类中对应的方法并执行 类中的方法执行完毕之后,会把客户端想要的数据返回给dispatch方法,由dispatch方法把数据返回经客户端</p>
<h2 id="django请求的生命周期"><a href="#django请求的生命周期" class="headerlink" title="django请求的生命周期"></a>django请求的生命周期</h2><p>1.wsgi,请求封装后交给web框架 （Flask、Django）</p>
<p>2.中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf、request.session</p>
<p>3.路由匹配 根据浏览器发送的不同url去匹配不同的视图函数</p>
<p>4.视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm、templates =&gt; 渲染</p>
<p>5.中间件，对响应的数据进行处理。</p>
<p>6.wsgi,将响应的内容发送给浏览器。</p>
<h2 id="说一下Django，MIDDLEWARES中间件的作用和应用场景？"><a href="#说一下Django，MIDDLEWARES中间件的作用和应用场景？" class="headerlink" title="说一下Django，MIDDLEWARES中间件的作用和应用场景？"></a>说一下Django，MIDDLEWARES中间件的作用和应用场景？</h2><p>中间件是介于request与response处理之间的一道处理过程,用于在全局范围内改变Django的输入和输出。</p>
<p>简单的来说中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作</p>
<p>例如：</p>
<p>1.Django项目中默认启用了csrf保护,每次请求时通过CSRF中间件检查请求中是否有正确#token值</p>
<p>2.当用户在页面上发送请求时，通过自定义的认证中间件，判断用户是否已经登陆，未登陆就去登陆。</p>
<p>3.当有用户请求过来时，判断用户是否在白名单或者在黑名单里</p>
<p>其内置的五个方法:</p>
<p>1.process_request : 请求进来时,权限认证</p>
<p>2.process_view : 路由匹配之后,能够得到视图函数</p>
<p>3.process_exception : 异常时执行</p>
<p>4.process_template_responseprocess : 模板渲染时执行</p>
<p>5.process_response : 请求有响应时执行</p>
<p>如果你想修改请求，例如被传送到view中的HttpRequest对象</p>
<p>或者你想修改view返回的HttpResponse对象，这些都可以通过中间件来实现</p>
<p>可能你还想在view执行之前做一些操作，这种情况也可以用 middleware来实现。 比如我们写一个判断浏览器来源，是pc还是手机，这里手机我们采用iphone，因为暂时没有其他设备。我们有不想把这个逻辑加到视图函数里，想作为一个通用服务，作为一个可插拔的组件被使用，最好的方法就是实现为中间件</p>
<p>或者说做一个拦截器，发现一定的时间内某个ip对网页的访问次数过多，则将其加入黑名单</p>
<h2 id="使用orm和原生sql的优缺点？"><a href="#使用orm和原生sql的优缺点？" class="headerlink" title="使用orm和原生sql的优缺点？"></a>使用orm和原生sql的优缺点？</h2><p>使用 ORM 最大的优点就是快速开发，让我们将更多的精力放在业务上而不是数据库上，下面是 ORM 的几个优点</p>
<p>隐藏了数据访问细节，使通用数据库交互变得简单易行。同时 ORM 避免了不规范、冗余、风格不统一的 SQL 语句，可以避免很多人为的 bug，方便编码风格的统一和后期维护。 将数据库表和对象模型关联，我们只需针对相关的对象模型进行编码，无须考虑对象模型和数据库表之间的转化，大大提高了程序的开发效率。 方便数据库的迁移。当需要迁移到新的数据库时，不需要修改对象模型，只需要修改数据库的配置。 ORM 的最令人诟病的地方就是性能问题，不过现在已经提高了很多，下面是 ORM 的几个缺点</p>
<p>性能问题 自动化进行数据库关系的映射需要消耗系统资源 程序员编码 在处理多表联查、where 条件复杂的查询时，ORM 可能会生成的效率低下的 SQL 通过 Lazy load 和 Cache 很大程度上改善了性能问题 SQL 调优，SQL 语句是由 ORM 框架自动生成，虽然减少了 SQL 语句错误的发生，但是也给 SQL 调优带来了困难。 越是功能强大的 ORM 越消耗内存，因为一个 ORM Object 会带有很多成员变量和成员函数。 对象和关系之间并不是完美映射 一般来说 ORM 足以满足我们的需求，如果对性能要求特别高或者查询十分复杂，可以考虑使用原生 SQL 和 ORM 共用的方式 使用原生sql优点：</p>
<p>进行复杂的查询时更加灵活 可以根据需要编写特殊的sql语句 使用原生sql缺点：</p>
<p>需要对输入进行严格的检测 自己写的sql语句，很多时候使用的是字符串拼接，可能会有sql注入的漏洞 不能使用django orm相关的一些特性</p>
<p>Django,Flask,tornado的对比</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Django走的是大而全的方向，开发效率高。它的MTV框架，自带的ORM，admin后台管理，自带的sqlite数据库和开发测试用的服务器给开发者提高了超高的开发效率</span><br><span class="line"></span><br><span class="line">Flask是轻量级的框架，自由，灵活，可扩展性很强，核心基于werkzeug wsgi 工具和jinja2模板引擎</span><br><span class="line"></span><br><span class="line">tornado走的是少而精的方向，性能优越。它最出名的是异步非阻塞的设以方式</span><br><span class="line">tornado的两大核心模块:</span><br><span class="line">    <span class="number">1.</span>iostraem:对非阻塞式的socket进行简单的封装</span><br><span class="line">    <span class="number">2.</span>ioloop: 对I/O多路复用的封装</span><br></pre></td></tr></table></figure>

<h6 id="什么是WSGI"><a href="#什么是WSGI" class="headerlink" title="什么是WSGI"></a>什么是WSGI</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">WSGI 描述web server如何与 web application通信的一种规范</span><br><span class="line"></span><br><span class="line">WSGI server负责从客户端接收请求，将request转发给application.将application返回的response返回给客户端</span><br></pre></td></tr></table></figure>

<h6 id="FBV和CBV"><a href="#FBV和CBV" class="headerlink" title="FBV和CBV"></a>FBV和CBV</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FBV基于函数的视图  CBV基于类的视图</span><br><span class="line">使用fbv的模式，在url匹配成功之后，会直接执行对应的视图函数</span><br><span class="line">使用cbv模式，在url匹配成功之后，会找到视图函数中对应的类，然后这个类回到请求头中找到对应的RequestMethod</span><br><span class="line">用户发送url请求，Django会依此遍历路由映射表中的所有记录，一旦路由映射表其中的一条匹配成功了，就执行视图函数中对应的函数名，这是fbv的执行流程</span><br><span class="line"></span><br><span class="line">当服务端使用cbv模式的时候，用户发给服务端的请求包含url，method这俩个信息都是字符串类型 服务端通过路由映射表匹配成功后会自动去找dispatch方法，然后Django会通过dispatch反射的方法找到类中对应的方法并执行类中的方法执行完毕之后，会把客户端想要的数据返回给dispatch方法，由dispatch方法把数据返回客户端</span><br></pre></td></tr></table></figure>

<h6 id="Django请求的生命周期"><a href="#Django请求的生命周期" class="headerlink" title="Django请求的生命周期"></a>Django请求的生命周期</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">WSGI（Web Server Gateway Interface）python web开发的标准，它定义了Web服务器和Web应用程序之间通信的接口规范。</span><br><span class="line"><span class="number">1.</span>wsgi,请求封装后交给web框架(flask,django)  </span><br><span class="line"><span class="number">2.</span>中间件，对请求进行校验或在请求对象中添加其他相关数据  列如:(csrf,request.session)</span><br><span class="line"><span class="number">3.</span>路由匹配 根据浏览器发送的不同url去匹配不同的视图函数</span><br><span class="line"><span class="number">4.</span>视图函数 在视图函数中进行业务逻辑的处理</span><br><span class="line"><span class="number">5.</span>中间件 对响应的数据进行处理</span><br><span class="line"><span class="number">6.</span>wsgi 将响应内容发送给浏览器</span><br></pre></td></tr></table></figure>

<h6 id="说一下Django，MIDDLEWARES中间件的作用和应用场景？-1"><a href="#说一下Django，MIDDLEWARES中间件的作用和应用场景？-1" class="headerlink" title="说一下Django，MIDDLEWARES中间件的作用和应用场景？"></a>说一下Django，MIDDLEWARES中间件的作用和应用场景？</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">中间件是介于request和response处理之间的一道处理过程，用于在全局范围内改变DJANGO的输入和输出。</span><br><span class="line">简单的来说中间件是帮助我们在视图函数执行前和执行之后都可以做一些额外操作</span><br><span class="line">列如：</span><br><span class="line">	<span class="number">1.</span>django项目中默认启用了csrf保护，每次请求时通过csrf中间件检查请求中是否有正确token值</span><br><span class="line">    <span class="number">2.</span>当用户在页面发送请求时，通过自定义的认证中间件，判断用户是否已经登陆，未登陆就去登陆</span><br><span class="line">    <span class="number">3.</span>当有用户请求过来时，判断用户是否在白名单或者黑名单</span><br><span class="line">    </span><br><span class="line">其内置的五个方法:</span><br><span class="line">    <span class="number">1.</span>process_request：请求进来时，权限认证</span><br><span class="line">    <span class="number">2.</span>process_view:路由匹配之后，能够得到视图函数</span><br><span class="line">    <span class="number">3.</span>process_exception:异常时执行</span><br><span class="line">    <span class="number">4.</span>process_template_responseprocess:模板渲染时执行</span><br><span class="line">    <span class="number">5.</span>process_response:请求有响应时执行</span><br><span class="line">        </span><br><span class="line">如果你想修改请求，列如被传送到view中的httprequest对象 或者你想修改view返回的httpresponse对象，这些都可以通过中间件来实现</span><br><span class="line">或者说做一个拦截器，发现一定的时间内某个ip对网页的访问次数过多，则即其加入黑名单</span><br></pre></td></tr></table></figure>

<h6 id="Django-orm"><a href="#Django-orm" class="headerlink" title="Django orm"></a>Django orm</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">O(object)：类和对象</span><br><span class="line">R(relation): 关系，关系数据库中的表格</span><br><span class="line">M(mapping) : 映射</span><br><span class="line">django orm框架的功能:</span><br><span class="line">    建立模型类和表之间的对应关系，允许我们通过面向对象的方式来操作数据库</span><br><span class="line">    根据设计的模型类生成数据库中的表格</span><br><span class="line">    通过方便的配置就可以进行数据库的切换</span><br><span class="line">缺点:</span><br><span class="line">    性能损耗，过度封装</span><br><span class="line">    有一定的学习成本</span><br></pre></td></tr></table></figure>

<h6 id="使用orm和原生sql的优缺点"><a href="#使用orm和原生sql的优缺点" class="headerlink" title="使用orm和原生sql的优缺点"></a>使用orm和原生sql的优缺点</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用orm最大的优点就是快速开发，让我们将更多的精力放在业务上而不是数据库</span><br><span class="line">隐藏了数据访问细节，使用数据库交互变得简单易行。同时orm避免了不规范，风格不统一的sql语句，可以避免很多人为的bug,方便编码风格的统一和后期维护。性能问题:越是功能强大的orm越消耗内存。</span><br><span class="line">    </span><br><span class="line"> 使用原生sql:</span><br><span class="line">  		优:  进行复杂的查询时更加灵活，可以根据需要编写特殊的sql语句</span><br><span class="line">    	缺: 需要对输入进入严格的检测 可能会有Sql注入的漏洞</span><br></pre></td></tr></table></figure>

<h6 id="Django本身提供了runserver-为什么不能用来部署"><a href="#Django本身提供了runserver-为什么不能用来部署" class="headerlink" title="Django本身提供了runserver,为什么不能用来部署"></a>Django本身提供了runserver,为什么不能用来部署</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>runserver方式时调式django时经常用到的运行方式，它使用django自带的wsgi server运行，主要在测试和开发中使用，并且runserver开启的方式也是单进程。</span><br><span class="line"><span class="number">2.</span>uwsgi是一个web服务器，他实现了wsgi协议，uwsgi,http等协议。注意uwsgi是一种通信协议。</span><br><span class="line">uwsgi具有超快的性能，低内存占用和多app管理等优点并且搭配着nginx就是一个生产环境了。</span><br><span class="line">相对来讲，支持的并发量更高，方便管理多进程，发货多核的优势，提升性能</span><br></pre></td></tr></table></figure>

<h6 id="restful规范的认识"><a href="#restful规范的认识" class="headerlink" title="restful规范的认识"></a>restful规范的认识</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">首先restful是一种软件架构风格或者说是一种设计风格，并不是标准，它只是提供了一组设计原则和约束条件，主要用于客户端和服务器交互类的软件。</span><br><span class="line">每一个url代表一种资源</span><br><span class="line">客户端使用get,post,delete,put4个表示操作方式的动词对服务端资源进行操作；get用来获取资源，post用来新建资源(也可以用于更新资源),put用来更新资源，delete用来删除资源。</span><br><span class="line">客户端与服务端之间的交互在请求之间是无状态的。</span><br><span class="line">状态码必须精确(客户端的每一次请求，服务器都必须给出回应。回应包括http状态码和数据俩部分)</span><br><span class="line">http 状态码就是一个三位数，分成五个类别</span><br><span class="line">	<span class="number">1</span>** ：相关信息</span><br><span class="line">    <span class="number">2</span>** ：操作成功</span><br><span class="line">    <span class="number">3</span>** ：重定向</span><br><span class="line">    <span class="number">4</span>** ：客户端错误</span><br><span class="line">    <span class="number">5</span>** ：服务器错误</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse,HttpResponseRedirect,HttpResponseForbidden</span><br><span class="line"><span class="comment">#导入自定义的数据库模型</span></span><br><span class="line"><span class="keyword">from</span> mysite.models <span class="keyword">import</span> User</span><br><span class="line"><span class="comment">#导内置模板方法</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义视图方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment">#打印头部信息</span></span><br><span class="line">    <span class="comment">#print(request.META)</span></span><br><span class="line">    <span class="comment">#获取ip信息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'HTTP_X_FORWARDED_FOR'</span> <span class="keyword">in</span> request.META:</span><br><span class="line">        ip = request.META.get(<span class="string">'HTTP_X_FORWARDED_FOR'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ip = request.META.get(<span class="string">'REMOTE_ADDR'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"来访者的ip是"</span>+str(ip))</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"您的ip是"</span>+str(ip))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义首页视图方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment">#入库操作（增）</span></span><br><span class="line">    <span class="comment">#建立实例</span></span><br><span class="line">    <span class="comment">#user = User(username='新用户',password='你好')</span></span><br><span class="line">    <span class="comment">#入库操作</span></span><br><span class="line">    <span class="comment">#user.save()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#删除数据（删）</span></span><br><span class="line">    <span class="comment">#User.objects.filter(username='新用户').delete()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#修改数据(改) 第一种方式</span></span><br><span class="line">    <span class="comment">#user = User.objects.get(id=9)</span></span><br><span class="line">    <span class="comment">#修改字段</span></span><br><span class="line">    <span class="comment">#user.username = '1234'</span></span><br><span class="line">    <span class="comment">#保存修改</span></span><br><span class="line">    <span class="comment">#user.save()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#修改数据（改） 第二种方式</span></span><br><span class="line">    <span class="comment">#return HttpResponse('',status=403)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#User.objects.filter(id=9).update(password='新密码')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#查询全部数据 翻译为 select * from user; all()返回值是list</span></span><br><span class="line">    res = User.objects.all()</span><br><span class="line">    <span class="comment">#print(res)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#查询限定条件的数据 翻译为 select * from user where username = '新用户123' and逻辑使用多个参数传递</span></span><br><span class="line">    res = User.objects.filter(username=<span class="string">'新用户'</span>,password=<span class="string">'你好'</span>)</span><br><span class="line">    <span class="comment">#print(res)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#只取一条 翻译 select * from user where id = 1</span></span><br><span class="line">    res_one = User.objects.get(id=<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#print(res_one)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#排除条件  翻译为 select * from user where username != '新用户123'   &lt;&gt;</span></span><br><span class="line">    res = User.objects.exclude(username=<span class="string">'新用户'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定制字段显示 翻译为 select password from user where name = '新用户'</span></span><br><span class="line">    res_s = User.objects.filter(username=<span class="string">'新用户'</span>).values(<span class="string">'password'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#排序 翻译为 select * from user order by id asc  倒序使用 reverse()</span></span><br><span class="line">    res = User.objects.filter(username=<span class="string">'新用户'</span>).order_by(<span class="string">"password"</span>).reverse()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#去重 翻译为 select distinct(username) from user where username = '新用户'</span></span><br><span class="line">    res_dis = User.objects.filter(username=<span class="string">'新用户'</span>).values(<span class="string">'username'</span>).distinct()</span><br><span class="line">    <span class="comment">#print(res_dis)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#取数量 翻译为 select count(*) from user</span></span><br><span class="line">    res_count = User.objects.filter(username=<span class="string">'新用户'</span>).count()</span><br><span class="line">    print(res_count)</span><br><span class="line"></span><br><span class="line">    res_list = [&#123;<span class="string">'name'</span>:<span class="string">'小王'</span>,<span class="string">'score'</span>:<span class="number">100</span>,<span class="string">'gender'</span>:<span class="string">'男'</span>&#125;,&#123;<span class="string">'name'</span>:<span class="string">'小宏'</span>,<span class="string">'score'</span>:<span class="number">50</span>,<span class="string">'gender'</span>:<span class="string">'女'</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'d4_index.html'</span>,locals())</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义捕获500的异常</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_error</span><span class="params">(request,**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"捕获500异常"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/Docker/Docker/</url>
    <content><![CDATA[<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><ul>
<li>什么是docker：小海腾<ul>
<li>KVM、Xen、VMware、VirtualBox、Hyper-V</li>
<li>VMM</li>
</ul>
</li>
<li>容器技术：在计算机的世界中, 容器拥有一段漫长且传奇的历史。容器与管理程序虚拟化 (hypervisor virtualization，HV)有所不同，管理程序虚拟化通过中间层将一台或者多台独立 的机器虚拟运行与物理硬件之上，而容器则是直接运行在操作系统内核之上的用户空间。因 此，容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行 在同一台宿主机上。</li>
<li>docker-ee：收费的</li>
<li>docker-ce：免费的<a id="more"></a></li>
</ul>
<h3 id="docker特点"><a href="#docker特点" class="headerlink" title="docker特点"></a>docker特点</h3><ul>
<li><p>上手快：用户只需要几分钟，就可以把自己的程序“Docker 化”。Docker 依赖于“写时复制” (copy-on-write)模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改” 的境界；随后，就可以创建容器来运行应用程序了。大多数 Docker 容器只需要不到 1 秒中即可 启动。由于去除了管理程序的开销，Docker 容器拥有很高的性能，同时同一台宿主机中也 可以运行更多的容器，使用户尽可能的充分利用系统资源</p>
</li>
<li><p>职责的逻辑分类：使用 Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如 何管理容器。Docker 设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署 的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题(测试环境都是正 常的，上线后出了问题就归结为肯定是运维的问题)”</p>
</li>
<li><p>快速高效的开发生命周期：Docker 的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用 程序具备可移植性，易于构建，并易于协作。(通俗一点说，Docker 就像一个盒子，里面 可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件 件的取。)</p>
</li>
<li><p>鼓励使用面向服务的架构：Docker 还鼓励面向服务的体系结构和微服务架构。Docker 推荐单个容器只运行一个应 用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服 务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序 都变得非常简单，同时也提高了程序的内省性。(当然，可以在一个容器中运行多个应用程 序)</p>
</li>
</ul>
<h3 id="Docker客户端和服务器"><a href="#Docker客户端和服务器" class="headerlink" title="Docker客户端和服务器"></a>Docker客户端和服务器</h3><ul>
<li>Docker 是一个客户端-服务器(C/S)架构程序。Docker 客户端只需要向 Docker 服务器 或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker 提供了 一个命令行工具 Docker 以及一整套 RESTful API。你可以在同一台宿主机上运行 Docker 守护 进程和客户端，也可以从本地的 Docker 客户端连接到运行在另一台宿主机上的远程 Docker 守护进程</li>
</ul>
<h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><ul>
<li>镜像是构建 Docker 的基石。用户基于镜像来运行自己的容器，镜像也是 Docker 生命周 期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构 建出来。例如:<ul>
<li>添加一个文件;</li>
<li>执行一个命令;</li>
<li>打开一个窗口。</li>
</ul>
</li>
<li>也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新</li>
</ul>
<h3 id="Registry镜像注册"><a href="#Registry镜像注册" class="headerlink" title="Registry镜像注册"></a>Registry镜像注册</h3><ul>
<li>Docker 用 Registry 来保存用户构建的镜像。</li>
<li>Registry 分为公共和私有两种。Docker 公司 运营公共的 Registry 叫做 Docker Hub</li>
<li>用户可以在 Docker Hub 注册账号，分享并保存自己的 镜像(说明:在 Docker Hub 下载镜像巨慢，可以自己构建私有的 Registry）</li>
</ul>
<h3 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h3><ul>
<li>Docker 可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容 器即可</li>
<li>容器是基于镜像启动起来的，容器中可以运行一个或多个进程</li>
<li>我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。容器基于 镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务</li>
<li>安装好的一个虚拟机</li>
</ul>
<h3 id="Docker镜像-1"><a href="#Docker镜像-1" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><ul>
<li>Docker 把应用程序及其依赖，打包在 image 文件里面</li>
<li>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例</li>
<li>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在自己操作系统所使用的image 基础上，往里面加入 Apache 服务器，形成你的image</li>
<li>就是一个操作系统文件</li>
</ul>
<h3 id="Docker容器操作"><a href="#Docker容器操作" class="headerlink" title="Docker容器操作"></a>Docker容器操作</h3><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">sudo docker run [option] 镜像名</span><br><span class="line"><span class="deletion">-i 表示以“交互模式”运行容器</span></span><br><span class="line"><span class="deletion">-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。</span></span><br><span class="line">–name 为创建的容器命名</span><br><span class="line"><span class="deletion">-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。</span></span><br><span class="line"><span class="deletion">-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不 会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。</span></span><br><span class="line"><span class="deletion">-p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射</span></span><br><span class="line"><span class="deletion">-e 为容器设置环境变量</span></span><br><span class="line">–network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同</span><br></pre></td></tr></table></figure>

<h4 id="停止或启动容器"><a href="#停止或启动容器" class="headerlink" title="停止或启动容器"></a>停止或启动容器</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">docker container <span class="keyword">stop</span> 容器名或<span class="keyword">ID</span></span><br></pre></td></tr></table></figure>

<h3 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h3><ul>
<li>FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制， 充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务</li>
<li>FastDFS架构包括 <strong>Tracker server</strong> 和 <strong>Storage server</strong>。客户端请求Trackerserver进行过文件上传、下载<ul>
<li>通过<code>Tracker server</code>调度最终由Storage server完成文件上传、下载</li>
</ul>
</li>
<li><strong>Tracker server</strong><ul>
<li>作用是负载均衡和调度,通过Tracker server在文件上传时可以根据一些策略找到Storage server提供文件上传服务。可以将tracker称为<strong>追踪服务器</strong>或 <strong>调度服务器</strong></li>
</ul>
</li>
<li><strong>Storage server</strong><ul>
<li>作用是文件存储,客户端上传的文件最终存储在Storage存储器上,Storageserver没有实现自己的文件系统而是利用操作系统的文件系统来管理文件。可以将storage称为<strong>存储服务器</strong></li>
</ul>
</li>
</ul>
<h3 id="centos部署docker"><a href="#centos部署docker" class="headerlink" title="centos部署docker"></a>centos部署docker</h3><ul>
<li>安装docker</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加docker-repo源</span></span><br><span class="line">yum install docker-ce</span><br><span class="line"><span class="meta">#</span><span class="bash"> 尝试安装docker-ce</span></span><br><span class="line">yum erase docker-common-2:1.13.1-96.gitb2f74b2.el7.centos.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已安装的docker</span></span><br></pre></td></tr></table></figure>

<ul>
<li>开启docker服务</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure>

<ul>
<li>查看docker镜像<ul>
<li>REPOSITORY：镜像所在的仓库名称</li>
<li>TAG：镜像标签</li>
<li>IMAGEID：镜像ID</li>
<li>CREATED：镜像的创建日期(不是获取该镜像的日期)</li>
<li>SIZE：镜像大小</li>
</ul>
</li>
</ul>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">image</span> <span class="keyword">ls</span></span><br><span class="line">docker  rm</span><br></pre></td></tr></table></figure>

<ul>
<li>拉取镜像及删除镜像</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">image</span> pull delron/fastdfs</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，docker image pull是抓取 image 文件的命令。delron/fastdfs是 image 文件在仓库里面的位置，其中delron是 image 文件所在的组，fastdfs是 image 文件的名字</p>
</blockquote>
<ul>
<li>开启fastdfs的tracker服务</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">docker run -dti <span class="params">--network=host</span> <span class="params">--name</span> tracker -v <span class="string">/var/fdfs/tracker</span>:<span class="string">/var/fdfs</span> delron/fastdfs tracker</span><br></pre></td></tr></table></figure>

<ul>
<li>开启fastdfs的storage服务</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -dti <span class="attribute">--network</span>=host --name storage -e <span class="attribute">TRACKER_SERVER</span>=47.97.210.11:22122 -v /var/fdfs/storage:/var/fdfs delron/fastdfs storage</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭docker容器</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">stop</span> container_id</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前运行的容器</li>
</ul>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">container</span> <span class="keyword">ls</span></span><br></pre></td></tr></table></figure>

<h2 id="Fastdfs使用"><a href="#Fastdfs使用" class="headerlink" title="Fastdfs使用"></a>Fastdfs使用</h2><h3 id="python客户端"><a href="#python客户端" class="headerlink" title="python客户端"></a>python客户端</h3><ul>
<li>下载安装<code>fastdfs</code>的<code>python</code>客户端</li>
</ul>
<blockquote>
<p><a href="https://github.com/JaceHo/fdfs_client-py" target="_blank" rel="noopener">https://github.com/JaceHo/fdfs_client-py</a></p>
</blockquote>
<ul>
<li>windows兼容问题</li>
</ul>
<blockquote>
<p>解压下载好的压缩包，提取fdfs_client文件夹</p>
</blockquote>
<ul>
<li>将该文件夹放入python的三方包目录下</li>
</ul>
<blockquote>
<p>C:\Python37\Lib\site-packages</p>
</blockquote>
<ul>
<li>安装所需的两个额外模块</li>
</ul>
<blockquote>
<p>pip install mutagen<br>pip isntall requests </p>
</blockquote>
<ul>
<li>注释fdfs_client/storage_client.py文件中的第十二行</li>
</ul>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">from</span> fdfs_client.sendfile <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<ul>
<li>创建client.conf文件到django下</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># project/client.conf</span></span><br><span class="line"><span class="comment"># connect timeout in seconds</span></span><br><span class="line"><span class="comment"># default value is 30s</span></span><br><span class="line">connect_timeout=<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network timeout in seconds</span></span><br><span class="line"><span class="comment"># default value is 30s</span></span><br><span class="line">network_timeout=<span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the base path to store log files</span></span><br><span class="line">base_path=\static <span class="comment">#FastDFS客户端存放日志文件的目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tracker_server can ocur more than once, and tracker_server format is</span></span><br><span class="line"><span class="comment">#  "host:port", host can be hostname or ip address</span></span><br><span class="line">tracker_server=<span class="number">123.57</span><span class="number">.61</span><span class="number">.168</span>:<span class="number">22122</span> <span class="comment">#运行tracker服务的机器IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#standard log level as syslog, case insensitive, value list:</span></span><br><span class="line"><span class="comment">### emerg for emergency</span></span><br><span class="line"><span class="comment">### alert</span></span><br><span class="line"><span class="comment">### crit for critical</span></span><br><span class="line"><span class="comment">### error</span></span><br><span class="line"><span class="comment">### warn for warning</span></span><br><span class="line"><span class="comment">### notice</span></span><br><span class="line"><span class="comment">### info</span></span><br><span class="line"><span class="comment">### debug</span></span><br><span class="line">log_level=info</span><br><span class="line"></span><br><span class="line"><span class="comment"># if use connection pool</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">use_connection_pool = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># connections whose the idle time exceeds this time will be closed</span></span><br><span class="line"><span class="comment"># unit: second</span></span><br><span class="line"><span class="comment"># default value is 3600</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">connection_pool_max_idle_time = <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if load FastDFS parameters from tracker server</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line">load_fdfs_parameters_from_tracker=false</span><br><span class="line"></span><br><span class="line"><span class="comment"># if use storage ID instead of IP address</span></span><br><span class="line"><span class="comment"># same as tracker.conf</span></span><br><span class="line"><span class="comment"># valid only when load_fdfs_parameters_from_tracker is false</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">use_storage_id = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify storage ids filename, can use relative or absolute path</span></span><br><span class="line"><span class="comment"># same as tracker.conf</span></span><br><span class="line"><span class="comment"># valid only when load_fdfs_parameters_from_tracker is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">storage_ids_filename = storage_ids.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#HTTP settings</span></span><br><span class="line">http.tracker_server_port=<span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#use "#include" directive to include HTTP other settiongs</span></span><br><span class="line"><span class="comment">##include http.conf</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上传测试代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#client.upload_by_filename(文件名)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line">client = Fdfs_client(<span class="string">"client.conf"</span>)</span><br><span class="line"></span><br><span class="line">ret = client.upload_by_filename(<span class="string">'1.jpg'</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中返回结果中的Remote file_id就是上传成功的保存文件名</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	'Group name': 'group1', </span><br><span class="line">	'Remote file_id': 'group1\\M00/00/00/rBEUWlz_HzSAPPzBAAQ2UAPajsU035.jpg', </span><br><span class="line">	'Status': 'Upload successed.', </span><br><span class="line">	'Local file name': '1.jpg', </span><br><span class="line">	'Uploaded size': '269.00KB', </span><br><span class="line">	'Storage IP': '123.57.61.168\x008'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Django文件引擎"><a href="#Django文件引擎" class="headerlink" title="Django文件引擎"></a><code>Django</code>文件引擎</h3><ul>
<li>重构<code>django</code>文件上传引擎</li>
</ul>
<blockquote>
<p>存储类中必须实现_open()和_save()方法,以及任何后续使用中可能用到的其他方法。</p>
</blockquote>
<ul>
<li><code>_open(name, mode = ‘rb’)</code>：被<code>Storage.open()</code>调用,在打开文件时被调用</li>
<li><code>save(name, content)</code>：被<code>Storage.save()</code>调用,name是传入的文件名,<code>content</code>是<code>Django</code>接收到的文件内容,该方法需要将<code>content</code>文件内容保存。<code>Django</code>会将该方法的返回值保存到数据库中对应的文件字段,也就是说该方法应该返回要保存在数据库中的文件名信息。</li>
<li><code>exists(name)</code>：如果名为<code>name</code>的文件在文件系统中存在，按返回<code>True</code>，否则返回<code>False</code></li>
<li><code>url(name)</code>：返回文件的完整访问<code>URL</code></li>
<li><code>delete(name)</code>：删除<code>name</code>文件</li>
<li><code>listdir(path)</code>：列出指定路径的文件</li>
<li><code>size(name)</code>：返回<code>name</code>文件的总大小</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.core.files.storage <span class="keyword">import</span> Storage</span><br><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastDFSStroage</span><span class="params">(Storage)</span>:</span></span><br><span class="line">    <span class="string">"""定义FastDFS客户端类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, base_url = None, client_conf = None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化对象</span></span><br><span class="line"><span class="string">        :param base_url:</span></span><br><span class="line"><span class="string">        :param client_conf:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> base_url <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            base_url = settings.FDAS_URL</span><br><span class="line">            <span class="comment"># 'http://123.57.61.168:8888' </span></span><br><span class="line">        self.base_url = base_url</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> client_conf <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            client_conf = settings.FDFS_CLIENT_CONF</span><br><span class="line">            <span class="comment"># FDFS_CLIENT_CONF = os.path.join(BASE_DIR, 'client.conf')</span></span><br><span class="line">        self.client_conf = client_conf</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_open</span><span class="params">(self, name, mode = <span class="string">'rb'</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        打开文件</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :param mode:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_save</span><span class="params">(self, name, content)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        保存文件</span></span><br><span class="line"><span class="string">        :param name: 传入文件名</span></span><br><span class="line"><span class="string">        :param content: 文件内容</span></span><br><span class="line"><span class="string">        :return:保存到数据库中的FastDFSDE文件名</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        client = Fdfs_client(self.client_conf)</span><br><span class="line">        ret = client.upload_by_buffer(content.read())</span><br><span class="line">        <span class="keyword">if</span> ret.get(<span class="string">"Status"</span>) != <span class="string">"Upload successed."</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"upload file failed"</span>)</span><br><span class="line">        file_name = ret.get(<span class="string">"Remote file_id"</span>)</span><br><span class="line">        <span class="keyword">return</span> file_name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exists</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        检查文件是否重复, FastDFS自动区分重复文件</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">url</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取name文件的完整url</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.base_url + name</span><br></pre></td></tr></table></figure>

<ul>
<li>将文件引擎设置到settings中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#settings.py</span></span><br><span class="line">DEFAULT_FILE_STORAGE = <span class="string">'goods.views.FastDFSStorage'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上传成功后的访问地址</li>
</ul>
<blockquote>
<p>在服务器IP地址的<code>8888</code>端口，记得打开对应阿里云的端口规则</p>
</blockquote>
<ul>
<li>注意：在新版本的Remote file_id，由<code>\\</code>斜杠变为了<code>/</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">'Remote file_id'</span>].replace(<span class="string">'\\'</span>,<span class="string">'/'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>&#39;Jwt的应用&#39;</title>
    <url>/Python/Jwt/</url>
    <content><![CDATA[<h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><p>​     Json web token（JWT）是为了网络应用环境间传递声明而执行的一种基于JSON的开发标准（RFC 7519），该token被设计为紧凑且安全的，特别适用于分布式站点的单点登陆（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。<a id="more"></a></p>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>   说起JWT，我们应该来谈一谈基于token的认证和传统的Session认证的区别。</p>
<h2 id="传统的session认证"><a href="#传统的session认证" class="headerlink" title="传统的session认证"></a>传统的session认证</h2><p>​    我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发送的请求，所以为了让我们的应用能识别是哪个用户发出的，我们只能在服务器存储一份用户登陆的信息，这份登陆信息会在响应时传递给服务器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的英哟个就能识别请求来自哪个用户了，这就是传统的基于sessino认证</p>
<p>​       但是这种基于session的认证使应用本身很难得扩展，随着不用客户端的增加，独立的服务器已无法承载更多的用户，而这个时候基于session认证应用的问题就会暴露出来</p>
<h2 id="基于session认证所显露的问题"><a href="#基于session认证所显露的问题" class="headerlink" title="基于session认证所显露的问题"></a>基于session认证所显露的问题</h2><p>​       Session：每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大</p>
<p>​        扩展性：用户认证之后，服务端做认证记录，如果认证的记录被保存在内存的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，响应的限制了负载均衡器的能力，也意味着限制了应用的扩展性</p>
<p>​        CSRF：因为是基于cookie来进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
<h2 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h2><p>​    基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或会话信息。这也就意味着机遇tokent认证机制的应用不需要去考虑用户在哪一台服务器登陆了，这就为应用的扩展提供了便利</p>
<p>​     流程是这样的</p>
<ul>
<li>用户使用用户名密码请求服务器</li>
<li>服务器进行验证用户信息</li>
<li>服务器通过验证发送给用户一个token</li>
<li>客户端存储token，并在每次请求时附加这个token值</li>
<li>服务器验证token，并返回数据</li>
</ul>
<p>​      这个token必须要在每次请求时发送给服务器，它应该保存在请求头中，另外，服务器要支持CORS（跨来源资源共享）策略，一般我们在服务端这么做就可以了 Access-Control-Allow-Origin：*</p>
<h2 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h2><p>​      JWT是由三部分构成，将这三段信息文本用链接构成了JWT字符串。就像这样</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">eyJ<span class="number">0</span>eXAiOiJKV<span class="number">1</span>QiLCJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiJ9</span>.eyJ<span class="attr">Vc2</span>VySWQiOjEyMywiVX<span class="symbol">Nlck5</span>hbWUiOiJhZ<span class="name">G1</span>pbiJ<span class="number">9.</span>Qjw<span class="number">1</span>epD<span class="number">5</span>P<span class="number">6</span>p<span class="number">4</span>Yy<span class="number">2</span>yju<span class="number">3</span>-fkq<span class="number">28</span>Pddz<span class="symbol">nqRj3</span>ESfALQy_U</span><br></pre></td></tr></table></figure>

<p>​    第一部分我们称它为头部（header）第二部分我们称其为载荷（payload，类似于飞机上承载的物品），第三部分是签证（signature）</p>
<h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>​      JWT的头部承载的两部分信息：</p>
<ul>
<li><p>声明类型，这里是jwt</p>
</li>
<li><p>声明加密的算法，通常直接使用HMAC SHA256</p>
<p> 完整的头部就像下面这样的JSON</p>
</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     'typ':'JWT',</span><br><span class="line">     'alg':'HS256'  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    然后将头部进行base64加密（该加密是可以对称解密的），构成了第一部分</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">eyJ<span class="number">0</span>eXAiOiJKV<span class="number">1</span>QiLCJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiJ9</span></span><br></pre></td></tr></table></figure>

<h2 id="plyload"><a href="#plyload" class="headerlink" title="plyload"></a>plyload</h2><p>​      载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p>
<ul>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明 </li>
</ul>
<p>​     标注中注册的声明（建议不强制使用）</p>
<ul>
<li>iss：jwt签发者</li>
<li>sub：jwt所面向的用户</li>
<li>aud：接收jwt的一方</li>
<li>exp：jwt的过期时间，这个过期时间必须大于签发时间</li>
<li>nbf：定义在什么时间之前，该jwt都是不可用的</li>
<li>iat：jwt的签发时间</li>
<li>jti：jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击 </li>
</ul>
<p>​    <strong>公共的声明：</strong></p>
<p>​       公共的声明可以添加任何的信息，一般添加用户的相关信息或其它业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密；</p>
<p>​     <strong>私有的声明</strong></p>
<p>​         私有的声明是提供者和消费者功能定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为名文信息。</p>
<p>​     定义一个payload</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    然后将其base64加密，得到jwt的一部分</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">eyJzdWIiOiIxMj<span class="name">M0</span><span class="symbol">NTY3</span>ODkwIiwibmFtZSI<span class="number">6</span>Ikpva<span class="name">G4</span>gR<span class="name">G9</span>lIiwiYWRtaW<span class="number">4</span>iO<span class="symbol">nRydWV9</span></span><br></pre></td></tr></table></figure>

<p>Signature</p>
<p>​    jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<ul>
<li>header(base64后的)</li>
<li>payload(base64后的)</li>
<li>secred     </li>
</ul>
<p>​       这个部分需要base64加密后的header和base64加密后的payload使用“.”连接组成的字符串，然后通过header中声明的加密方式进行加secret组合加密，然后就构成了jwt的第三部分</p>
<p>​      </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var encodedString = base64<span class="constructor">UrlEncode(<span class="params">header</span>)</span> + <span class="character">'.'</span> + base64<span class="constructor">UrlEncode(<span class="params">payload</span>)</span>;</span><br><span class="line">var signature = <span class="constructor">HMACSHA256(<span class="params">encodedString</span>, '<span class="params">secret</span>')</span>; <span class="comment">// TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure>

<p>​    将这三部分用“.”连接成一个完整的字符串，构成了最终的jwt：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiIsInR5</span>cCI<span class="number">6</span>IkpX<span class="attr">VCJ9</span>.eyJzdWIiOiIxMj<span class="name">M0</span><span class="symbol">NTY3</span>ODkwIiwibmFtZSI<span class="number">6</span>Ikpva<span class="name">G4</span>gR<span class="name">G9</span>lIiwiYWRtaW<span class="number">4</span>iO<span class="symbol">nRydWV9</span>.TJVA<span class="number">95</span><span class="keyword">Or</span><span class="name">M7</span>E<span class="number">2</span>cBab<span class="number">30</span>RMHrHDcEfxjoYZgeFO<span class="symbol">NFh7</span>HgQ</span><br></pre></td></tr></table></figure>

<p>​     注意：secret是保存在服务器端的，jwt的签发也是在服务端的，secret就是用来进行jwt的签发和jwt的验证，所以它就是你服务端的私钥，在任何场景都不应该流露出去，一旦客户端得知这个secret，那就意味着客户端可以自我签发jwt了</p>
<p> 应用 </p>
<p>​      一般是在请求头里加入Authorization，并加上Bearer标注：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">fetch</span>(<span class="string">'api/user/1'</span>, &#123;</span><br><span class="line">  <span class="attribute">headers</span>: &#123;</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">'Bearer '</span> + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​       服务端会验证token，如果验证通过就会返回相应的资源，整个流程就是这样</p>
<p><img src="https://images2017.cnblogs.com/blog/1147658/201711/1147658-20171118202151718-1630139158.png" alt="img"></p>
<p>   总结</p>
<p>​      优点：</p>
<ul>
<li>因为json的通用性，所以JWT是可以跨语言支持的，像C#，JavaScript，NodeJS，PHP等许多语言都可以使用</li>
<li>因为由了payload部分，所以JWT可以在自身存储一些其它业务逻辑所必要的非敏感信息</li>
<li>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的</li>
<li>它不需要在服务端保存会话信息，所以它易于应用的扩展</li>
</ul>
<p>​       安全相关</p>
<ul>
<li>不应该在jwt的payload部分存储敏感信息，因为该部分是客户端可解密的部分</li>
<li>保护好secret私钥。该私钥非常重要</li>
<li>如果可以，请使用https协议</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="comment">#加密</span></span><br><span class="line"><span class="comment">#第一个参数 用户敏感信息  第二个参数 密钥  第三个参数 加密算法 hs256</span></span><br><span class="line">encode_jwt=jwt.encode(&#123;<span class="string">'uid'</span>:<span class="string">'1'</span>&#125;,<span class="string">'123'</span>,algorithm=<span class="string">'HS256'</span>)</span><br><span class="line"><span class="comment">#返回一个字节码  加密后两个点分割，分成三部分。第一部分token头部，声明它是token  第二部分 载荷 存用户敏感信息  第三部分 算法</span></span><br><span class="line"><span class="comment">#转码  字符串  进行解密</span></span><br><span class="line">encode_str=str(encode_jwt,<span class="string">'utf-8'</span>)  <span class="comment">#强转， 声明编码python3 utf-8</span></span><br><span class="line"><span class="comment">#变成可用字符串</span></span><br><span class="line">print(encode_str)</span><br><span class="line"><span class="comment">#解码</span></span><br><span class="line">de_Code=jwt.decode(<span class="string">'加密后的字符串'</span>,<span class="string">'密钥'</span>，<span class="string">'声明算法'</span>)   (<span class="string">'12dcs'</span>,<span class="string">'123'</span>,algorithms=[<span class="string">'HS256'</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#声明载荷</span></span><br><span class="line">improt datetime</span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line">过期时间  时间戳  敏感信息</span><br><span class="line">playlod=&#123;</span><br><span class="line">    <span class="string">'exp'</span>:int((datetime.datetime.now()) +datetime.timedelta(seconds=<span class="number">20</span>).timestap()),<span class="string">'data'</span>:&#123;<span class="string">'uid'</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#加密token</span></span><br><span class="line">encode_jwt=jwt.encode(playload,<span class="string">'123'</span>,algorithm=<span class="string">'HS256'</span>)</span><br><span class="line"><span class="comment">#解码</span></span><br><span class="line">algorithms=[<span class="string">'HS256'</span>]</span><br><span class="line"><span class="comment">#判断token过期</span></span><br><span class="line">datetime.datetime.now()</span><br><span class="line">如果当前时间大于过期时间则token过期</span><br></pre></td></tr></table></figure>



<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#装饰器就是一个封装的闭包</span></span><br><span class="line"><span class="comment">#自定义装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_de</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">decortor</span><span class="params">(view_func)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">_wrapped_view</span><span class="params">(request,*args,**kwargs)</span>:</span></span><br><span class="line">				<span class="comment">#此处写判断逻辑</span></span><br><span class="line">				print(<span class="string">'请求开始'</span>)</span><br><span class="line">				<span class="keyword">return</span> view_func(request,*args,**kwargs)</span><br><span class="line">		<span class="keyword">return</span> _wrapped_viw</span><br><span class="line">	<span class="keyword">return</span> decoror</span><br><span class="line">	</span><br><span class="line"><span class="meta">@my_de()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">haha</span><span class="params">(name)</span>:</span></span><br><span class="line">	print(<span class="string">'谁是 %s'</span> name)</span><br><span class="line">haha(<span class="string">'张三'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>添加萌萌的宠物live2d</title>
    <url>/Happy/%E6%B7%BB%E5%8A%A0%E8%90%8C%E8%90%8C%E7%9A%84%E5%AE%A0%E7%89%A9live2d/</url>
    <content><![CDATA[<h1 id="Hexo-Next-添加萌萌的宠物live2d"><a href="#Hexo-Next-添加萌萌的宠物live2d" class="headerlink" title="Hexo Next 添加萌萌的宠物live2d"></a>Hexo Next 添加萌萌的宠物live2d</h1><h5 id="添加萌宠来装饰Hexo站点-使用到的插件hexo-helper-live2d"><a href="#添加萌宠来装饰Hexo站点-使用到的插件hexo-helper-live2d" class="headerlink" title="添加萌宠来装饰Hexo站点, 使用到的插件hexo-helper-live2d"></a>添加萌宠来装饰Hexo站点, 使用到的插件hexo-helper-live2d</h5><p>添加萌宠</p>
<h6 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1.安装插件"></a>1.安装插件</h6><p>命令行cmd进入站点文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd .\TestBlog\</span><br><span class="line"></span><br><span class="line">npm install hexo-helper-live2d --save</span><br></pre></td></tr></table></figure>



<p>下载完插件后, 使用hexo s启动服务器发现左下角已经有live2d模型了</p>
<h6 id="2-在站点配置文件-config-yml中添加配置"><a href="#2-在站点配置文件-config-yml中添加配置" class="headerlink" title="2.在站点配置文件_config.yml中添加配置"></a>2.在站点配置文件_config.yml中添加配置</h6><p>配置信息可以设置live2d的位置、大小、透明度等</p>
<p>更多配置信息可看Github hexo-helper-live2d上的介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  model:</span><br><span class="line">    # 这是白猫的模型</span><br><span class="line">    use: live2d-widget-model-tororo</span><br><span class="line">  display:</span><br><span class="line">    # 设置模型的位置</span><br><span class="line">    position: right</span><br><span class="line">    width: 120</span><br><span class="line">    height: 240</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 1</span><br><span class="line">    opacityOnHover: 1</span><br></pre></td></tr></table></figure>



<h6 id="3-下载你喜欢的模型"><a href="#3-下载你喜欢的模型" class="headerlink" title="3.下载你喜欢的模型"></a>3.下载你喜欢的模型</h6><p>命令行cmd进入站点文件夹, 使用npm install {your model’s package name}下载你喜欢的模型</p>
<p>模型列表<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">模型预览</a></p>
<p>效果如图</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">比如下载  这是猫的</span><br><span class="line">tororo npm install live2d-widget-model-tororo</span><br></pre></td></tr></table></figure>

<p>完成上述，你会发现有一个可爱的小老虎</p>
]]></content>
      <categories>
        <category>Happy</category>
      </categories>
      <tags>
        <tag>Happy</tag>
      </tags>
  </entry>
  <entry>
    <title>web基础</title>
    <url>/uncategorized/web%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h6 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第一次握手：建立连接时，客户端发送syn包到服务器，并进入syn_sent状态，等待服务器确认；syn:同步序列编号</span><br><span class="line">第二次握手:服务器收到syn包，必须确认客户的syn,同时自己也发送一个syn包，即syn+ack包，此时服务器进入syn_recv状态</span><br><span class="line"> 第三次握手:客户端收到服务器的syn+ack包，向服务器发送确认包，次包发送完毕。完成三次握手</span><br></pre></td></tr></table></figure>

<h6 id="Tcp的四次挥手"><a href="#Tcp的四次挥手" class="headerlink" title="Tcp的四次挥手"></a>Tcp的四次挥手</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接</span><br><span class="line"></span><br><span class="line">那对于TCP的断开连接，这里就有了“四次挥手”</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=<span class="number">1</span>，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加<span class="number">1</span>），此时，客户端进入FIN-WAIT<span class="number">-1</span>（终止等待<span class="number">1</span>）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）服务器收到连接释放报文，发出确认报文，ACK=<span class="number">1</span>，ack=u+<span class="number">1</span>，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT<span class="number">-2</span>（终止等待<span class="number">2</span>）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=<span class="number">1</span>，ack=u+<span class="number">1</span>，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）客户端收到服务器的连接释放报文后，必须发出确认，ACK=<span class="number">1</span>，ack=w+<span class="number">1</span>，而自己的序列号是seq=u+<span class="number">1</span>，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过<span class="number">2</span>∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</span><br></pre></td></tr></table></figure>

<h6 id="同步，异步编程差异是"><a href="#同步，异步编程差异是" class="headerlink" title="同步，异步编程差异是"></a>同步，异步编程差异是</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">你打电话问书店老板有没有《python开发》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下<span class="string">"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。</span></span><br><span class="line"><span class="string">而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</span></span><br></pre></td></tr></table></figure>

<h6 id="阻塞于非阻塞的差异是啥"><a href="#阻塞于非阻塞的差异是啥" class="headerlink" title="阻塞于非阻塞的差异是啥"></a>阻塞于非阻塞的差异是啥</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">还是你打电话问书店老板有没有《python开发》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果</span><br><span class="line">如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去干别的了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</span><br><span class="line">大部分Web应用都是阻塞性质的，也就是说当一个请求被处理时，这个进程就会被挂起直至请求完成，比如Django,而Tornado的思想是当我们在等待结果的时候不阻塞，转而我们给框架一个回调函数作为参数，让框架在收到结果的时候通过回调函数继续操作。这样，服务器就可以被解放去接受其他客户端的请求了。</span><br></pre></td></tr></table></figure>

<h6 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">get在浏览器回退时是无害的，而post会再次提交请求</span><br><span class="line">get产生的url地址可以被Bookmark(书签),而post不可以</span><br><span class="line">get请求会被浏览器主动cache(缓存),而post不会除非手动设置</span><br><span class="line">get请求只能进行url编码，而post支持多种编码方式</span><br><span class="line">get请求在url中传送的参数是有长度限制的，而post没有</span><br><span class="line">get比post更不安全，因为参数直接暴露在url上，所以不能用来传递铭感信息</span><br><span class="line">get参数通过url传参，post放在request body中</span><br></pre></td></tr></table></figure>

<h6 id="MVC模式MVT模式"><a href="#MVC模式MVT模式" class="headerlink" title="MVC模式MVT模式"></a>MVC模式MVT模式</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Django的mvt模式本质上和mvc是一样的，也是为了各组件件保持松耦合关系</span><br><span class="line">MTV</span><br><span class="line">M代表模型(model)负责业务对象和数据库的关系映射</span><br><span class="line">T代表模板(template) 负责如何把页面展示给用户</span><br><span class="line">V代表视图(view):负责业务逻辑，并在适当时候调用model和template</span><br><span class="line">除了以上三层之外，还需要一个url分发器，它的作用是将一个url的页面请求分发给不同的view处理，view再调用相应的model和template</span><br><span class="line"></span><br><span class="line">MVC</span><br><span class="line">所谓mvc就是把web应用分为模型(m),控制器(c)和视图(v)三层，他们之间以一种插件式的，松耦合的方式连接在一起，模型负责业务对象与数据库的映射，视图负责与用户的交互(页面)，控制器接收用户的输入调用模型和视图完成用户的请求。</span><br></pre></td></tr></table></figure>

<h6 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http 超文本传输协议 是一种用于分布式，协作式和超媒体信息系统的应用层协议。 端口<span class="number">80</span></span><br><span class="line">简单来说就是一种发布和接收HTML页面的方法，被用于在web浏览器和网站服务器之间传递信息。http协议以明文方式发送内容，不提供任何方式的数据加密，因此http协议不适合传输一些敏感信息，比如：信用卡号，密码支付等信息。</span><br><span class="line"></span><br><span class="line">https 超文本传输安全协议 https经由http进行通信，但利用ssl/tls来加密数据包。</span><br><span class="line">https开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。https默认工作在tcp协议<span class="number">443</span>端口</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">http明文传输，数据都是未加密的，安全性较差，https(ssl+http)数据传输过程都是加密的，安全性较好。</span><br><span class="line">使用https协议需要到CA(数字证书认证机构)申请证书，一般免费证书较少，因而需要一定费用。</span><br><span class="line">http页面响应速度比https快，主要业务http使用tcp三次握手建立连接，客户端和服务器需要交换三个包，而https除了tcp的三个包，还要加上ssl握手需要的<span class="number">9</span>个包，所以一共是<span class="number">12</span>个包</span><br><span class="line">http和https使用的是完全不同的连接方式，用的端口也不一样，前者是<span class="number">80</span>，后者是<span class="number">443.</span></span><br><span class="line">https其实就是建构在ssl/tls之上的http协议，所以，https比http更耗费服务器资源</span><br></pre></td></tr></table></figure>



<h6 id="什么是websocket"><a href="#什么是websocket" class="headerlink" title="什么是websocket"></a>什么是websocket</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">websocket是html5下一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。它与http一样通过已建立的tcp连接来传输数据，但是它和http最大不同是:websocket是一种双向通信协议。在建立连接后，websocket服务器端和客户端都能主动向对方发送或接收数据。</span><br><span class="line"> Websocket有以下特点：是真正的全双共方式，建立连接后客户端与服务端是完全平等的，可以互相主动请求。扩展了浏览器与服务器的通信功能，是服务端也可以主动向客户端发送数据。</span><br></pre></td></tr></table></figure>

<h6 id="websocket心跳及重连机制"><a href="#websocket心跳及重连机制" class="headerlink" title="websocket心跳及重连机制"></a>websocket心跳及重连机制</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在使用websocket的过程中，有时候会遇到网络断开的情况，但是在网络断开的时候服务器并没有触发oneclose的事件。这样会有：服务器会继续向客户端发送多余的连接，并且这些数据还会丢失。所以就需要一种机制来检测客户端和服务端是否处于正常的连接状态。因此就有了websocket的心跳。</span><br></pre></td></tr></table></figure>

<h6 id="websocket心跳包"><a href="#websocket心跳包" class="headerlink" title="websocket心跳包"></a>websocket心跳包</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">所谓的心跳包就是服务器每隔固定的一段时间向客户端发送一个包，如果客户端收到这个包证明它还活着，同时它也会给服务端也返回一个包，证明它也还活着。</span><br></pre></td></tr></table></figure>



<h6 id="JSON-Web-Token"><a href="#JSON-Web-Token" class="headerlink" title="JSON Web Token"></a>JSON Web Token</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">jwt</span><br><span class="line">基于jwt的token身份认证方案</span><br><span class="line">	Browser                                  Server</span><br><span class="line">    		<span class="number">1.</span>发送带有用户名密码的post请求</span><br><span class="line">        							<span class="number">2.</span>验证通过后生成jwt并将用户信息放入jwt</span><br><span class="line">            		<span class="number">3.</span>将jwt存入cookie中</span><br><span class="line">                	<span class="number">4.</span>发送带有jwt cookie的请求</span><br><span class="line">                    		<span class="number">5.</span>验证签名后从jwt中获取用户信息</span><br><span class="line">                        <span class="number">6.</span>放回响应信息</span><br><span class="line">                        </span><br><span class="line">jwt 特点 体积小，因而传输速度快</span><br><span class="line">传输方式多样，可以通过url/post参数/http头部等方式传输</span><br><span class="line">严格的结构化。它自身(在payload中)就包含了所有与用户有关的验证信息，如用户可以访问路由，访问有效期等信息。</span><br><span class="line">支持跨域验证，可以应用于单点登陆</span><br><span class="line">签名的目的：</span><br><span class="line">	签名实际上是对头部以及载荷内容进行签名。所以，如果说有人对头部以及载荷的内容解码之后进行修改，在进行编码的话，那么新的签名和之前的签名就是不一样的。我们因此可以知道它是一个非法请求进行拦截。这样能保证token不会被纂改。</span><br><span class="line"> 最后，我们将上面拼接完的字符进行加密。在加密的时候，我们还需要提供提供一个密钥(sercet).类似盐</span><br><span class="line"></span><br><span class="line">使用json web token的好处？</span><br><span class="line"><span class="number">1.</span>性能问题。jwt方式将用户状态分散到了客户端中，相比于session,可以很明显减轻服务端的内存压力。session方式存储用户id的最大弊病在于session是存储在服务器端的，所以需要占用大量服务器内存，一般还需借助nosql和缓存机制来实现session的存储，如果分布式应用还需session共享。</span><br><span class="line"><span class="number">2.</span>单点登陆.jwt能轻松的实现单点登陆，因为用户的状态已经被传送到了客户端。tokem可保存自定义信息，如用户基本信息。</span><br><span class="line"><span class="number">3.</span>前后端分离。以前的传统模式下，后台对应的客户端就是浏览器，就可以使用session+cookie的方式实现登陆，但是在前后分离的情况下，后端只负责通过暴力的restApi提供数据，而页面的渲染，路由都由前端完成。因为rest是无状态的，因此也就不会有session记录到服务器端。</span><br><span class="line"><span class="number">4.</span>兼容性。支持移动设备，支持跨域程序调用，cookied是不允许跨域访问的。</span><br><span class="line"><span class="number">5.</span>可扩展性。jwt是无状态的，特别适用于分布式站点的单点登陆。</span><br><span class="line">jwt不适合存放大量信息，信息越多token越长。</span><br></pre></td></tr></table></figure>

<h6 id="什么是csrf"><a href="#什么是csrf" class="headerlink" title="什么是csrf"></a>什么是csrf</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CSRF 中文名称：跨站请求伪造。</span><br><span class="line">你可以这么理解csrf攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。csrf能够做的事情包括:以你名义发送邮件，发信息，盗取你的账号，甚至于购买商品，虚拟货币转账.....个人隐私泄露以及财产安全。</span><br></pre></td></tr></table></figure>

<h6 id="什么是sql注入"><a href="#什么是sql注入" class="headerlink" title="什么是sql注入"></a>什么是sql注入</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql注入是属于注入式攻击，这种攻击是因为在项目中没有将代码与数据(比如用户敏感数据)隔离，在读取数据的时候，错误的将数据作为代码的一部分执行而导致的。</span><br><span class="line">将sql代码注入到sql服务器中，解析并执行的一种攻击手法。</span><br><span class="line"></span><br><span class="line">任何防止？</span><br><span class="line"><span class="number">1.</span>过滤用户输入参数中的特殊字符，降低风险。</span><br><span class="line"><span class="number">2.</span>禁止通过字符串拼接sql语句，要严格适用参数绑定来传入参数。</span><br><span class="line"><span class="number">3.</span>合理使用数据库框架提供的机制。禁止拼接Sql语句，</span><br><span class="line">就是要正确使用参数化绑定sql变量</span><br></pre></td></tr></table></figure>

<h6 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xss:跨站脚本攻击，为了和前端的css避免重名，简称为xss,是指通过技术手段，向正常用户请求的HTML页面中插入恶意脚本，执行。</span><br><span class="line">    这种攻击主要是用于信息窃取和破坏等目的。</span><br><span class="line">    </span><br><span class="line">关于防范xss，主要就是通过对用户输入的数据做过滤或者是转义。总结扼，过滤html标签。</span><br></pre></td></tr></table></figure>

<h6 id="什么是celery"><a href="#什么是celery" class="headerlink" title="什么是celery?"></a>什么是celery?</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Django的请求处理过程都是同步的无法实现异步任务，若要实现异步任务处理需要通过其他方式(前端的一般解决方案是ajax操作)，而后台celery就是不错的选择。倘若一个用户在执行某些操作需要等待很就才放回，这大大降低了网站的吞吐量。</span><br><span class="line">celery是由python开发，简单，灵活，可靠的分布式任务队列，其本质是生产者消费者模型，生产者发送任务到消息队列，消费者负责处理任务。celery侧重于实时操作</span><br><span class="line">高可用:当任务执行失败或执行过程中发送连续中断，celery会自动吃屎重新执行任务。</span><br><span class="line">快速:一个单进程的celery每分钟可处理上百万个任务</span><br><span class="line"> 灵活:几乎celery的每个组件都可以被扩展及自定制</span><br><span class="line">工作原理：</span><br><span class="line"></span><br><span class="line">任务模块Task包含异步任务和定时任务。其中，异步任务通常在业务逻辑中被触发并发往消息队列，而定时任务由Celery Beat进程周期性地将任务发往消息队列； 任务执行单元Worker实时监视消息队列获取队列中的任务执行； Woker执行完任务后将结果保存在Backend中;</span><br><span class="line"></span><br><span class="line">消息中间件Broker 　　消息中间件Broker官方提供了很多备选方案，支持RabbitMQ、Redis、Amazon SQS、MongoDB、Memcached 等，官方推荐RabbitMQ。</span><br><span class="line"></span><br><span class="line">任务执行单元Worker 　　Worker是任务执行单元，负责从消息队列中取出任务执行，它可以启动一个或者多个，也可以启动在不同的机器节点，这就是其实现分布式的核心。</span><br><span class="line"></span><br><span class="line">结果存储Backend 　　Backend结果存储官方也提供了诸多的存储方式支持：RabbitMQ、 Redis、Memcached,SQLAlchemy, Django ORM、Apache Cassandra、Elasticsearch。</span><br><span class="line"></span><br><span class="line">Celery管理和监控功能是通过flower组件实现的，flower组件不仅仅提供监控功能，还提供HTTP API可实现对woker和task的管理。</span><br></pre></td></tr></table></figure>

<h6 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">因为浏览器的同源策略规定某域下的客户端在没明确授权的情况下，不能读写另一个域的资源</span><br><span class="line">而在实际开发中，前后端是常常相互分离的。</span><br><span class="line">所谓同源(域名，协议，端口相同)</span><br></pre></td></tr></table></figure>

<h6 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>开头(请求成功)表示成功处理了请求的状态码</span><br><span class="line"><span class="number">200</span>(成功)服务器已成功处理了请求</span><br><span class="line"><span class="number">201</span> （已创建） 请求成功并且服务器创建了新的资源。</span><br><span class="line"></span><br><span class="line"><span class="number">202</span> （已接受） 服务器已接受请求，但尚未处理。</span><br><span class="line"></span><br><span class="line"><span class="number">203</span> （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</span><br><span class="line"></span><br><span class="line"><span class="number">204</span> （无内容） 服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line"></span><br><span class="line"><span class="number">205</span> （重置内容） 服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line"></span><br><span class="line"><span class="number">206</span> （部分内容） 服务器成功处理了部分 GET 请求。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</span><br><span class="line"></span><br><span class="line"><span class="number">300</span> （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</span><br><span class="line"></span><br><span class="line"><span class="number">301</span> （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</span><br><span class="line"></span><br><span class="line"><span class="number">302</span> （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class="line"></span><br><span class="line"><span class="number">303</span> （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</span><br><span class="line"></span><br><span class="line"><span class="number">304</span> （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</span><br><span class="line"></span><br><span class="line"><span class="number">305</span> （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</span><br><span class="line"></span><br><span class="line"><span class="number">307</span> （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</span><br><span class="line"></span><br><span class="line"><span class="number">400</span> （错误请求） 服务器不理解请求的语法。</span><br><span class="line"></span><br><span class="line"><span class="number">401</span> （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</span><br><span class="line"></span><br><span class="line"><span class="number">403</span> （禁止） 服务器拒绝请求。</span><br><span class="line"></span><br><span class="line"><span class="number">404</span> （未找到） 服务器找不到请求的网页。</span><br><span class="line"></span><br><span class="line"><span class="number">405</span> （方法禁用） 禁用请求中指定的方法。</span><br><span class="line"></span><br><span class="line"><span class="number">406</span> （不接受） 无法使用请求的内容特性响应请求的网页。</span><br><span class="line"></span><br><span class="line"><span class="number">407</span> （需要代理授权） 此状态代码与 <span class="number">401</span>（未授权）类似，但指定请求者应当授权使用代理。</span><br><span class="line"></span><br><span class="line"><span class="number">408</span> （请求超时） 服务器等候请求时发生超时。</span><br><span class="line"></span><br><span class="line"><span class="number">409</span> （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</span><br><span class="line"></span><br><span class="line"><span class="number">410</span> （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</span><br><span class="line"></span><br><span class="line"><span class="number">411</span> （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</span><br><span class="line"></span><br><span class="line"><span class="number">412</span> （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</span><br><span class="line"></span><br><span class="line"><span class="number">413</span> （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</span><br><span class="line"></span><br><span class="line"><span class="number">414</span> （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</span><br><span class="line"></span><br><span class="line"><span class="number">415</span> （不支持的媒体类型） 请求的格式不受请求页面的支持。</span><br><span class="line"></span><br><span class="line"><span class="number">416</span> （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</span><br><span class="line"></span><br><span class="line"><span class="number">417</span> （未满足期望值） 服务器未满足<span class="string">"期望"</span>请求标头字段的要求。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</span><br><span class="line"></span><br><span class="line"><span class="number">500</span> （服务器内部错误） 服务器遇到错误，无法完成请求。</span><br><span class="line"></span><br><span class="line"><span class="number">501</span> （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</span><br><span class="line"></span><br><span class="line"><span class="number">502</span> （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</span><br><span class="line"></span><br><span class="line"><span class="number">503</span> （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</span><br><span class="line"></span><br><span class="line"><span class="number">504</span> （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</span><br><span class="line"></span><br><span class="line"><span class="number">505</span> （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</span><br></pre></td></tr></table></figure>

<h6 id="列举django-orm中所有的方法"><a href="#列举django-orm中所有的方法" class="headerlink" title="列举django orm中所有的方法"></a>列举django orm中所有的方法</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">从数据库中查询出来的结果一般是一个集合。Queryset</span><br><span class="line">filter过滤     all放回所有结果</span><br><span class="line">exclude排除    distince 去除查询结果中重复的行</span><br><span class="line">order_by排序</span><br><span class="line">reverse反向排序</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
