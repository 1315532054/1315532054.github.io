<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>四十岁的吃鸡玩家</title>
    <url>/Live/%E5%9B%9B%E5%8D%81%E5%B2%81%E7%9A%84%E5%90%83%E9%B8%A1%E7%8E%A9%E5%AE%B6/</url>
    <content><![CDATA[<p>四十岁的吃鸡玩家<br>我从家里出来，在马路边四处张望，寻找我叫的那辆滴滴快车。<br>司机已经来过电话，我拜托他多等一会儿，但现在已经过去了十多分钟，不知道他会不会已经取消订单。<br>情况并没有那么糟，我最终找到了那辆车。我上车之后才发现，司机居然在玩“刺激战场”。我看了一眼，三级包三级头，还挺肥。<br> <a id="more"></a><br>司机没有埋怨我的姗姗来迟，反而问我急不急着赶路。我连忙摆手，说道：“不急不急，你好好玩吧，这把有望吃鸡啊。”<br>司机一听，兴奋的说：“你也玩这个啊？”<br>“我就没事儿瞎玩玩。”<br>“你们年轻人玩这个应该挺厉害，我连前十都没进过几次。”<br>“哪有，你这把就很稳啊，这不马上就进前十了嘛。”<br>“哈哈，这把运气好…”<br>他话还没说完，就听见了一声枪响。他立刻集中精神，趴在草里，转动视角观察周围。<br>我也不再说话，静静的看他冲进决赛圈。</p>
<p>这时我才注意到，这位吃鸡玩家已经长了不少白发，脸上也有了皱纹。没想到这个年纪的大叔，也会热衷于吃鸡。</p>
<p>最后他止步于第二名，被一个穿着吉利服的“伏地魔”给淘汰了，只差一步就能吃鸡。我还觉得有些遗憾，他却十分满足。我忽然很好奇，他是因为什么开始玩这个游戏，他笑容一滞，随后说道：“因为我儿子喜欢玩这个，我就想着，要是我也玩的话，就能和他多说上几句话。”</p>
<p>我一时语塞，愣了片刻才缓缓开口：“你儿子真幸运，有你这样贴心的父亲。”<br>司机笑了笑：“嗐，天下哪个父母不是为了儿女操碎了心。”<br>“也是。你儿子多大了啊？”<br>“刚中考完，马上就高一了。”<br>他顿了顿，继续说道：“小时候还挺爱说话，上初中之后就不怎么和我聊天了。”<br>我安慰着：“叛逆期嘛，过了这段时间就好了。平时多陪陪他吧，比如一起吃鸡什么的。”<br>“现在每天晚上我都拉着他一起玩游戏，”他有些无奈，“但他嫌我技术差，不爱和我玩。每次都是我去睡的时候，他才能真正的和他的朋友玩。”</p>
<p>我忽然知道他为什么不会因为第二名而遗憾了，因为他在乎的从来都不是名次。第二名，意味着他的技术有了进步，意味着他能和儿子玩得更久。</p>
<p>我不知该如何接话。就在我沉默的时候，他又说道：“嘿嘿，我还打算下个‘王者荣耀’，我儿子也喜欢玩这个。”</p>
]]></content>
      <categories>
        <category>Live</category>
      </categories>
      <tags>
        <tag>Live</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间任何通信？</title>
    <url>/uncategorized/%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BB%BB%E4%BD%95%E9%80%9A%E4%BF%A1%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="进程之间究竟有哪些通信方式？如何通信？"><a href="#进程之间究竟有哪些通信方式？如何通信？" class="headerlink" title="进程之间究竟有哪些通信方式？如何通信？"></a>进程之间究竟有哪些通信方式？如何通信？</h3><h6 id="1、管道"><a href="#1、管道" class="headerlink" title="1、管道"></a>1、管道</h6><p>我们来看一条 Linux 的语句</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">netstat -tulnp | grep <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>学过 Linux 命名的估计都懂这条语句的含义，其中”|“是管道的意思，它的作用就是把前一条命令的输出作为后一条命令的输入。在这里就是把 netstat -tulnp 的输出结果作为 grep 8080 这条命令的输入。如果两个进程要进行通信的话，就可以用这种管道来进行通信了，并且我们可以知道这条竖线是没有名字的，所以我们把这种通信方式称之为匿名管道。</p>
<p>并且这种通信方式是单向的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。<a id="more"></a></p>
<p>居然有匿名管道，那也意味着有命名管道，下面我们来创建一个命名管道。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mkfifo  test</span><br></pre></td></tr></table></figure>

<p>这条命令创建了一个名字为 test 的命名管道。</p>
<p>接下来我们用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"this is a pipe"</span> &gt; <span class="built_in">test</span>   // 写数据</span><br></pre></td></tr></table></figure>


<p>这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束。接下来我们用另外一个进程来读取</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> &lt; <span class="keyword">test</span>  <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure>


<p>我们可以看到，test 里面的数据被读取出来了。上一条命令也执行结束了。</p>
<p>从上面的例子可以看出，管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是单向传输的。</p>
<p>这种通信方式有什么缺点呢？显然，这种通信方式效率低下，你看，a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。</p>
<p>所以管道不适合频繁通信的进程。当然，他也有它的优点，例如比较简单，能够保证我们的数据已经真的被其他进程拿走了。我们平时用 Linux 的时候，也算是经常用。</p>
<h6 id="2、消息队列"><a href="#2、消息队列" class="headerlink" title="2、消息队列"></a>2、消息队列</h6><p>那我们能不能把进程的数据放在某个内存之后就马上让进程返回呢？无需等待其他进程来取就返回呢？</p>
<p>答是可以的，我们可以用消息队列的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的<br>消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于缓存吧。</p>
<p>这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味<strong>发送消息（拷贝）</strong>这个过程需要花很多时间来读内存。</p>
<p>哪有没有什么解决方案呢？答是有的，请继续往下看。</p>
<h6 id="3、共享内存"><a href="#3、共享内存" class="headerlink" title="3、共享内存"></a>3、共享内存</h6><p>共享内存这个通信方式就可以很好着解决拷贝所消耗的时间了。</p>
<p>这个可能有人会问了，每个进程不是有自己的独立内存吗？两个进程怎么就可以共享一块内存了？</p>
<p>我们都知道，系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。</p>
<h6 id="4、信号量"><a href="#4、信号量" class="headerlink" title="4、信号量"></a>4、信号量</h6><p>共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的线程安全问题。如何解决这个问题？这个时候我们的信号量就上场了。</p>
<p>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p>
<h6 id="5、Socket"><a href="#5、Socket" class="headerlink" title="5、Socket"></a>5、Socket</h6><p>上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？</p>
<p>答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p>
<p>总结<br>所以，进程之间的通信方式有：</p>
<p>1、管道</p>
<p>2、消息队列</p>
<p>3、共享内存</p>
<p>4、信号量</p>
<p>5、Socket</p>
]]></content>
  </entry>
  <entry>
    <title>检测验证码模拟登陆</title>
    <url>/uncategorized/%E6%A3%80%E6%B5%8B%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<h2 id="爬虫：实时api-百度ai-检测验证码模拟登录-Selenium-页面"><a href="#爬虫：实时api-百度ai-检测验证码模拟登录-Selenium-页面" class="headerlink" title="爬虫：实时api(百度ai)检测验证码模拟登录(Selenium)页面"></a>爬虫：实时api(百度ai)检测验证码模拟登录(Selenium)页面</h2><p>老板让自动登录这个页面：<a href="https://www.dianxiaomi.com/index.htm，毫无疑问登录页面基本都会有在线验证码，要破解这个验证码当然不是啥难事，诚然可以自己去训练模型，然而大量的训练集测试数据还得自己去打码，说白了，不值当，有现成的接口可以用，何乐而不为，于是我们向万恶的百度伸出了魔爪。" target="_blank" rel="noopener">https://www.dianxiaomi.com/index.htm，毫无疑问登录页面基本都会有在线验证码，要破解这个验证码当然不是啥难事，诚然可以自己去训练模型，然而大量的训练集测试数据还得自己去打码，说白了，不值当，有现成的接口可以用，何乐而不为，于是我们向万恶的百度伸出了魔爪。</a><a id="more"></a></p>
<p>  首先申请百度api开发平台：<a href="https://cloud.baidu.com/" target="_blank" rel="noopener">https://cloud.baidu.com/</a></p>
<p>  随后在人工智能-》文字识别 模块里建立一个应用</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">人工智能 ----&gt; 文字识别</span><br></pre></td></tr></table></figure>

<p>建立成功之后，会分配给你一个key(APl key)和secret(Secret key)</p>
<p>只不过这个接口免费版的每秒最多只能请求两次，一天有500次的请求机会</p>
<p>这里推荐适用高精度的接口，普通的识别率太差了</p>
<h2 id="接口描述"><a href="#接口描述" class="headerlink" title="接口描述"></a>接口描述</h2><p>基于业界领先的深度学习技术，提供多场景、多语种、高精度的整图文字检测和识别服务，多项ICDAR指标居世界第一。</p>
<h2 id="请求说明"><a href="#请求说明" class="headerlink" title="请求说明"></a>请求说明</h2><p><strong>请求示例</strong></p>
<p>HTTP 方法：<code>POST</code></p>
<p>请求URL： <code>https://aip.baidubce.com/rest/2.0/ocr/v1/general_basic</code></p>
<p>URL参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>access_token</td>
<td>通过API Key和Secret Key获取的access_token,参考“<a href="http://ai.baidu.com/docs#/Auth" target="_blank" rel="noopener">Access Token获取</a>”</td>
</tr>
</tbody></table>
<p>Header如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>Content-Type</td>
<td>application/x-www-form-urlencoded</td>
</tr>
</tbody></table>
<p>Body中放置请求参数，参数详情如下：</p>
<p><strong>请求参数</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>是否必选</th>
<th>类型</th>
<th>可选值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>image</td>
<td>和url二选一</td>
<td>string</td>
<td>-</td>
<td>图像数据，base64编码后进行urlencode，要求base64编码和urlencode后大小不超过4M，最短边至少15px，最长边最大4096px,支持jjpg/jpeg/png/bmp格式，当image字段存在时url字段失效</td>
</tr>
<tr>
<td>url</td>
<td>和image二选一</td>
<td>string</td>
<td>-</td>
<td>图片完整URL，URL长度不超过1024字节，URL对应的图片base64编码后大小不超过4M，最短边至少15px，最长边最大4096px,支持jpg/jpeg/png/bmp格式，当image字段存在时url字段失效，不支持https的图片链接</td>
</tr>
<tr>
<td>language_type</td>
<td>否</td>
<td>string</td>
<td>CHN_ENG ENG JAP KOR FRE SPA POR GER ITA RUS</td>
<td>识别语言类型，默认为CHN_ENG 可选值包括： - CHN_ENG：中英文混合 - ENG：英文 - JAP：日语 - KOR：韩语 - FRE：法语 - SPA：西班牙语 - POR：葡萄牙语 - GER：德语 - ITA：意大利语 - RUS：俄语</td>
</tr>
<tr>
<td>detect_direction</td>
<td>否</td>
<td>string</td>
<td>true/false</td>
<td>是否检测图像朝向，默认不检测，即：false。朝向是指输入图像是正常方向、逆时针旋转90/180/270度。可选值包括: - true：检测朝向； - false：不检测朝向。</td>
</tr>
<tr>
<td>detect_language</td>
<td>否</td>
<td>string</td>
<td>true/false</td>
<td>是否检测语言，默认不检测。当前支持（中文、英语、日语、韩语）</td>
</tr>
<tr>
<td>paragraph</td>
<td>否</td>
<td>string</td>
<td>true/false</td>
<td>是否输出段落信息</td>
</tr>
<tr>
<td>probability</td>
<td>否</td>
<td>string</td>
<td>true/false</td>
<td>是否返回识别结果中每一行的置信度</td>
</tr>
</tbody></table>
<p>第一步，获取access_token</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = requests.get(<span class="string">"https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=你的key&amp;client_secret=你的秘钥"</span>)</span><br><span class="line"></span><br><span class="line">res = json.loads(str(res.text))</span><br><span class="line">token = res[<span class="string">'access_token'</span>]</span><br></pre></td></tr></table></figure>

<p>然后请求高精度识别接口，需要注意一点，这里图片需要转换成base64编码 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp_url = <span class="string">'https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic?access_token='</span> + token</span><br><span class="line">temp_headers = &#123;<span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>&#125;</span><br><span class="line">temp_file = open(<span class="string">'./test.png'</span>, <span class="string">'rb'</span>)</span><br><span class="line">temp_image = temp_file.read()</span><br><span class="line">temp_file.close()</span><br><span class="line">temp_data = &#123;<span class="string">'image'</span>: base64.b64encode(temp_image)&#125;</span><br><span class="line">temp_data = urllib.parse.urlencode(temp_data)</span><br><span class="line">temp_res = requests.post(url=temp_url, data=temp_data, headers=temp_headers)</span><br><span class="line"></span><br><span class="line">res = json.loads(str(temp_res.text))</span><br><span class="line">code = res[<span class="string">'words_result'</span>][<span class="number">0</span>][<span class="string">'words'</span>]</span><br></pre></td></tr></table></figure>

<p>百度接口会将识别出的验证码文字返回给你，当然了有一定误差是在所难免的</p>
<p>现在验证码识别已经搞定，问题的关键是，每次打开页面的时候，怎么将图片传给百度接口</p>
<p>其实很简单，我们可以考虑适用Selenium自动化工具来截图，Selenium是可以根据选择器做局部截图的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nodes = driver.find_element_by_id(<span class="string">'loginImgVcode'</span>)</span><br><span class="line">nodes.screenshot(<span class="string">'test.png'</span>)</span><br></pre></td></tr></table></figure>

<p>虽然可以截图，但是其实发现有东西干扰了验证码图片，这样的干扰会让识别产生误差，当然这些html标签是可以移除的，适用Selenium运行js代码来删除这些干扰元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除元素</span></span><br><span class="line">js = <span class="string">"var elem = document.getElementsByClassName('dnf');elem[0].parentNode.removeChild(elem[0]);"</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line"></span><br><span class="line">js = <span class="string">"var elem = document.getElementsByClassName('qqshow');elem[0].parentNode.removeChild(elem[0]);"</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line"></span><br><span class="line">js = <span class="string">"var elem = document.getElementsByClassName('QR');elem[0].parentNode.removeChild(elem[0]);"</span></span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure>

<p>这里还有个技巧，可以提高百度api的识别准确度，就是利用opencv对验证码进行降噪去色的操作</p>
<p>首先安装opencv</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install opencv-python</span><br></pre></td></tr></table></figure>

<p>然后对原图进行去色处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'./code.png'</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">print(<span class="string">"cv2.imread(imgfile, cv2.IMREAD_GRAYSCALE)结果如下："</span>)</span><br><span class="line">print(<span class="string">'大小：&#123;&#125;'</span>.format(img.shape))</span><br><span class="line">print(<span class="string">"类型：%s"</span>%type(img))</span><br><span class="line">print(img)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">'code1.png'</span>, img)</span><br></pre></td></tr></table></figure>

<p>Selenium驱动下载地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://npm.taobao.org/mirrors/chromedriver/</span><br></pre></td></tr></table></figure>

<p>剩下的就很简单了，直接利用Selenium输入账号密码以及验证码就可以自动登陆了</p>
<p>完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#selenium 截图</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">'https://www.dianxiaomi.com/index.htm'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除元素</span></span><br><span class="line">js = <span class="string">"var elem = document.getElementsByClassName('dnf');elem[0].parentNode.removeChild(elem[0]);"</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line"></span><br><span class="line">js = <span class="string">"var elem = document.getElementsByClassName('qqshow');elem[0].parentNode.removeChild(elem[0]);"</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line"></span><br><span class="line">js = <span class="string">"var elem = document.getElementsByClassName('QR');elem[0].parentNode.removeChild(elem[0]);"</span></span><br><span class="line">driver.execute_script(js)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nodes = driver.find_element_by_id(<span class="string">'loginImgVcode'</span>)</span><br><span class="line">nodes.screenshot(<span class="string">'test.png'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#用户名 exampleInputName exampleInputPassword</span></span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">'exampleInputName'</span>).send_keys(<span class="string">'18231327142'</span>)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">'exampleInputPassword'</span>).send_keys(<span class="string">'密码'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#请求百度api接口</span></span><br><span class="line"></span><br><span class="line">res = requests.get(<span class="string">"https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=你的key&amp;client_secret=你的秘钥"</span>)</span><br><span class="line"></span><br><span class="line">res = json.loads(str(res.text))</span><br><span class="line">token = res[<span class="string">'access_token'</span>]</span><br><span class="line"></span><br><span class="line">temp_url = <span class="string">'https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic?access_token='</span> + token</span><br><span class="line">temp_headers = &#123;<span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>&#125;</span><br><span class="line">temp_file = open(<span class="string">'./test.png'</span>, <span class="string">'rb'</span>)</span><br><span class="line">temp_image = temp_file.read()</span><br><span class="line">temp_file.close()</span><br><span class="line">temp_data = &#123;<span class="string">'image'</span>: base64.b64encode(temp_image)&#125;</span><br><span class="line">temp_data = urllib.parse.urlencode(temp_data)</span><br><span class="line">temp_res = requests.post(url=temp_url, data=temp_data, headers=temp_headers)</span><br><span class="line"></span><br><span class="line">res = json.loads(str(temp_res.text))</span><br><span class="line">print(res)</span><br><span class="line">code = res[<span class="string">'words_result'</span>][<span class="number">0</span>][<span class="string">'words'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">'loginVerifyCode'</span>).send_keys(code.strip().replace(<span class="string">' '</span>,<span class="string">''</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#登录按钮</span></span><br><span class="line">driver.find_element_by_id(<span class="string">'loginBtn'</span>).click()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>协同过滤算法</title>
    <url>/uncategorized/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/</url>
    <content><![CDATA[<h6 id="使用Python3-7配合协同过滤算法构建一套简单的精准推荐系统"><a href="#使用Python3-7配合协同过滤算法构建一套简单的精准推荐系统" class="headerlink" title="使用Python3.7配合协同过滤算法构建一套简单的精准推荐系统"></a>使用Python3.7配合协同过滤算法构建一套简单的精准推荐系统</h6><p>​    协同过滤算法，它隶属于启发式推荐算法，这种推荐算法易于实现，并且推荐结果的可解释性强</p>
<p>主要考虑的是用户和用户之间的相似度，就可以找出相似用户喜欢的物品，并预测目标用户对对于物品的评分，就可以找到评分最高的若干个物品推荐给用户。<a id="more"></a>举个例子，李老师和闫老师拥有相似的电影喜好，当新电影上映后，李老师对其表示喜欢，那么就能将这部电影推荐给闫老师。</p>
<p>​    说白了就是利用商品作为纽带，判断高相似度的用户之间互相没有买过的商品，然后将其排序推荐。</p>
<p>假如我们是一个在线手机平台，有一些用户的购买数据和打分记录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">phone.txt</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>,华为p30,<span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>,三星s10,<span class="number">5.0</span></span><br><span class="line"><span class="number">1</span>,小米<span class="number">9</span>,<span class="number">2.6</span></span><br><span class="line"><span class="number">2</span>,华为p30,<span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>,vivo,<span class="number">5.0</span></span><br><span class="line"><span class="number">2</span>,htc,<span class="number">4.6</span></span><br><span class="line"><span class="number">3</span>,魅族,<span class="number">2.0</span></span><br><span class="line"><span class="number">3</span>,iphone,<span class="number">5.0</span></span><br><span class="line"><span class="number">3</span>,pixel2,<span class="number">2.6</span></span><br></pre></td></tr></table></figure>

<p>​    用户1买了华为三星和小米三款手机，而用户2买了华为，vio,htc这三款，其中用户1和用户2的相同点是都买过华为手机，我们认为此二人具有一定的相似度，而用户3买的手机则完全不一样，所以用户3的存在可以理解为一种检查机制，用来验证推荐系统的可用性，因为以用户3的购买记录来看，理论上不应该将用户3的手机推荐给用户1和2，反过来用户1和用户2买过的手机也不会推荐给拥护3</p>
<p>  第一步，将数据读取并格式化为字典形式，便于解析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = []</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'./phone.txt'</span>) <span class="keyword">as</span> fp:  </span><br><span class="line">    content = fp.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将用户、评分、和手机写入字典data</span></span><br><span class="line">data = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">    line = line.strip().split(<span class="string">','</span>)</span><br><span class="line">    <span class="comment">#如果字典中没有某位用户，则使用用户ID来创建这位用户</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line[<span class="number">0</span>] <span class="keyword">in</span> data.keys():</span><br><span class="line">        data[line[<span class="number">0</span>]] = &#123;line[<span class="number">1</span>]:line[<span class="number">2</span>]&#125;</span><br><span class="line">    <span class="comment">#否则直接添加以该用户ID为key字典中</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data[line[<span class="number">0</span>]][line[<span class="number">1</span>]] = line[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>  第二步，计算两个用户之间的相似度，这里使用欧几里得距离（欧式距离）  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Euclid</span><span class="params">(user1,user2)</span>:</span></span><br><span class="line">    <span class="comment">#取出两位用户购买过的手机和评分</span></span><br><span class="line">    user1_data=data[user1]</span><br><span class="line">    user2_data=data[user2]</span><br><span class="line">    distance = <span class="number">0</span></span><br><span class="line">    <span class="comment">#找到两位用户都购买过的手机，并计算欧式距离</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> user1_data.keys():</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> user2_data.keys():</span><br><span class="line">            <span class="comment">#注意，distance越大表示两者越相似</span></span><br><span class="line">            distance += pow(float(user1_data[key])-float(user2_data[key]),<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+sqrt(distance))<span class="comment">#这里返回值越小，相似度越大</span></span><br></pre></td></tr></table></figure>

<p> 第三步，计算当前用户和其他所有用户的相似度，因为用户可能成千上万，我们只需要那一个和当前用户极为相似的真命天子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算某个用户与其他用户的相似度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_simliar</span><span class="params">(userID)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> userid <span class="keyword">in</span> data.keys():</span><br><span class="line">        <span class="comment">#排除与自己计算相似度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> userid == userID:</span><br><span class="line">            simliar = Euclid(userID,userid)</span><br><span class="line">            res.append((userid,simliar))</span><br><span class="line">    res.sort(key=<span class="keyword">lambda</span> val:val[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p> 最后一步，进行推荐推送：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recommend</span><span class="params">(user)</span>:</span></span><br><span class="line">    <span class="comment">#相似度最高的用户</span></span><br><span class="line">    top_sim_user = top_simliar(user)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#相似度最高的用户的购买记录</span></span><br><span class="line">    items = data[top_sim_user]</span><br><span class="line">    recommendations = []</span><br><span class="line">    <span class="comment">#筛选出该用户未购买的手机并添加到列表中</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items.keys():</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> data[user].keys():</span><br><span class="line">            recommendations.append((item,items[item]))</span><br><span class="line">    recommendations.sort(key=<span class="keyword">lambda</span> val:val[<span class="number">1</span>],reverse=<span class="literal">True</span>)<span class="comment">#按照评分排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recommendations</span><br></pre></td></tr></table></figure>

<p>最后运行测试</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(recommend(<span class="string">'1'</span>))</span><br><span class="line">[(<span class="string">'vivo'</span>, <span class="string">'5.0'</span>), (<span class="string">'htc'</span>, <span class="string">'4.6'</span>)]</span><br></pre></td></tr></table></figure>

<p> 将vivo和htc手机按照评分倒序推荐给了用户1，符合我们的基本逻辑</p>
]]></content>
  </entry>
  <entry>
    <title>Redis知识点</title>
    <url>/uncategorized/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h4 id="1-Redis数据结构有哪些-？"><a href="#1-Redis数据结构有哪些-？" class="headerlink" title="1.Redis数据结构有哪些 ？"></a>1.Redis数据结构有哪些 ？</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">String    List    Hash   Set    Sorted Set</span><br><span class="line">bitmap    Geo     HyperLogLog Streams</span><br></pre></td></tr></table></figure>

<h4 id="2-Redis相比memcached有哪些优势？"><a href="#2-Redis相比memcached有哪些优势？" class="headerlink" title="2.Redis相比memcached有哪些优势？"></a>2.Redis相比memcached有哪些优势？</h4><p><code>memcached</code> 所有的值均是简单的字符串;<br><code>redis</code> 作为其替代者，支持更为丰富的数据类型;<br><code>redis</code> 的速度比 <code>memcached</code> 快很多 <code>redis</code> 可以持久化数据。</p>
<a id="more"></a>

<h4 id="3-Redis是单线程，如何解决并发请求访问？"><a href="#3-Redis是单线程，如何解决并发请求访问？" class="headerlink" title="3.Redis是单线程，如何解决并发请求访问？"></a>3.Redis是单线程，如何解决并发请求访问？</h4><p><code>redis</code> 利用<strong>队列技术**</strong>将并发访问变为串行访问**，消除了传统数据库串行控制的开销。</p>
<h4 id="4-Reids6淘汰策略有哪些？"><a href="#4-Reids6淘汰策略有哪些？" class="headerlink" title="4. Reids6淘汰策略有哪些？"></a>4. Reids6淘汰策略有哪些？</h4><p><code>noeviction</code>: <strong>不删除策略</strong>, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。大多数写命令都会导致占用更多的内存，有极少数会例外。</p>
<ul>
<li><strong>LRU算法</strong><br><code>allkeys-lru</code>:所有<code>key</code>通用;<br>优先删除最近最少使用(<code>less recently used ,LRU</code>) 的 <code>key</code>。<br><code>volatile-lru</code>:只限于设置了<code>expire</code> 的部分;<br>优先删除最近最少使用(<code>less recently used ,LRU</code>) 的 <code>key</code>。</li>
<li><strong>随机淘汰</strong><br><code>allkeys-random</code>: 所有<code>key</code>通用; 随机删除一部分 <code>key</code>。<br><code>volatile-random</code>: 只限于设置了 <code>expire</code> 的部分; 随机删除一部分 <code>key</code>。<br><code>volatile-ttl</code>: 只限于设置了<code>expire</code> 的部分; 优先删除剩余时间(<code>time to live,TTL</code>) 短的<code>key</code>。</li>
</ul>
<h4 id="5-Redis持久化方案有哪些？"><a href="#5-Redis持久化方案有哪些？" class="headerlink" title="5.Redis持久化方案有哪些？"></a>5.Redis持久化方案有哪些？</h4><ul>
<li><strong>RDB(Redis DataBase)持久化</strong><br>是指<strong>用数据集快照</strong>的方式半持久化模式，记录<code>redis</code>数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复；</li>
<li><strong>AOF(Append-only file)持久化：</strong><br>是指所有的命令行记录以<code>redis</code>命令请求协议的格式完全持久化存储，保存为<code>aof</code>文件。</li>
</ul>
<h5 id="RDB和AOF的优缺点-："><a href="#RDB和AOF的优缺点-：" class="headerlink" title="RDB和AOF的优缺点 ："></a><code>RDB</code>和<code>AOF</code>的优缺点 ：</h5><p><strong><code>RDB</code>持久化:</strong></p>
<ul>
<li><strong>优点</strong>：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。</li>
<li><strong>缺点</strong>：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然<strong>做不到实时持久化</strong>，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</li>
</ul>
<p><strong><code>AOF</code>持久化:</strong></p>
<ul>
<li>与RDB持久化相对应；</li>
<li><strong>优点</strong>在于支持秒级持久化、兼容性好；</li>
<li><strong>缺点</strong>是文件大、恢复速度慢、对性能影响大。</li>
</ul>
<h4 id="6-Redis内存划分"><a href="#6-Redis内存划分" class="headerlink" title="6.Redis内存划分"></a>6.Redis内存划分</h4><p>**数据:</p>
<p>**作为数据库，数据是最主要的部分；<br>这部分占用的内存会统计在<code>used_memory</code>中。</p>
<p>**进程本身运行需要的内存:</p>
<p>**<code>Redis</code>主进程本身运行肯定需要占用内存，如代码、常量池等等；<br>这部分内存大约几兆，在大多数生产环境中与<code>Redis</code>数据占用的内存相比可以忽略。<br>这部分内存不是由<code>jemalloc</code>分配，因此不会统计在<code>used_memory</code>中。</p>
<p>**缓冲内存:</p>
<p>**缓冲内存包括客户端缓冲区、复制积压缓冲区、<code>AOF</code>缓冲区等；<br>其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；<br><code>AOF</code>缓冲区用于在进行<code>AOF</code>重写时，保存最近的写入命令。<br>在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由<code>jemalloc</code>分配， 因此会统计在<code>used_memory</code>中。</p>
<p>**内存碎片:</p>
<p>**内存碎片是<code>Redis</code>在分配、回收物理内存过程中产生的。<br>例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致<code>redis</code>释放的空间在物理内存中并没有释放，但<code>redis</code>又无法有效利用，这就形成了内存碎片。内存碎片不会统计在<code>used_memory</code>中。</p>
<h4 id="7-Reids主从复制"><a href="#7-Reids主从复制" class="headerlink" title="7.Reids主从复制"></a>7.Reids主从复制</h4><p>复制是高可用<code>Redis</code>的基础，哨兵和集群都是在复制基础上实现高可用的。<br>复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。<br>缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制 。</p>
<h4 id="8-Redis哨兵"><a href="#8-Redis哨兵" class="headerlink" title="8.Redis哨兵"></a>8.Redis哨兵</h4><p>在复制的基础上，哨兵实现了自动化的故障恢复。<br><strong>缺陷</strong>：写操作无法负载均衡；存储能力受到单机的限制。</p>
<h4 id="9-redis缓存被击穿处理机制"><a href="#9-redis缓存被击穿处理机制" class="headerlink" title="9.redis缓存被击穿处理机制"></a>9.redis缓存被击穿处理机制</h4><p>使用<code>mutex</code>。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去<code>load db</code>，而是先使用缓存工具的某些带成功操作返回值的操作（比如<code>Redis</code>的<code>SETNX</code>或者<code>Memcache</code>的<code>ADD</code>）去<code>set</code>一个<code>mutex key</code>，当操作返回成功时，再进行<code>load db</code>的操作并回设缓存；否则，就重试整个 get缓存方法。</p>
<h4 id="10-缓存和数据库间数据一致性问题"><a href="#10-缓存和数据库间数据一致性问题" class="headerlink" title="10.缓存和数据库间数据一致性问题"></a>10.缓存和数据库间数据一致性问题</h4><p>分布式环境下非常容易出现缓存和数据库间的数据一致性问题，针对这一点的话，如果你的项目对缓存的要求是强一致性的，那么请不要使用缓存。<br>只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括合适的缓存更新策略，更新数据库后要及时更新缓存、缓存失败时增加重试机制，例如MQ模式的消息队列 。</p>
<h4 id="11-缓存雪崩问题"><a href="#11-缓存雪崩问题" class="headerlink" title="11.缓存雪崩问题"></a>11.缓存雪崩问题</h4><ul>
<li>像解决缓存穿透一样加锁排队；</li>
<li>建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存。</li>
</ul>
<h4 id="12-Redis分布式"><a href="#12-Redis分布式" class="headerlink" title="12.Redis分布式"></a>12.Redis分布式</h4><p><strong>redis支持主从的模式。<br>原则</strong>：<code>Master</code>会将数据同步到<code>slave</code>，而<code>slave</code>不会将数据同步到<code>master</code>。<code>Slave</code>启动时会连接<code>master</code>来同步数据。 这是一个典型的分布式读写分离模型。利用<code>master</code>来插入数据，<code>slave</code>提供检索服务。这样可以有效减少单个机器的并发访问数量 。</p>
<h4 id="13-读写分离模型"><a href="#13-读写分离模型" class="headerlink" title="13.读写分离模型"></a>13.读写分离模型</h4><p>通过增加<code>Slave DB</code>的数量，读的性能可以线性增长。为了避免<code>Master DB</code>的单点故障，集群一般都会采用两台<code>Master DB</code>做双机热备，所以整个集群的读和写的可用性都非常高。<br>读写分离架构的缺陷在于，不管是<code>Master</code>还是<code>Slave</code>，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于<code>Write-intensive</code>类型的应用，读写分离架构并不适合。</p>
<h4 id="14-数据分片模型"><a href="#14-数据分片模型" class="headerlink" title="14.数据分片模型"></a>14.数据分片模型</h4><p>为解决读写分离模型的缺陷，可以将数据分片模型应用进来。 可以将每个节点看成，都是独立的<code>master</code>，然后通过业务实现数据分片。 结合上面两种模型，可以将每个<code>master</code>设计成由一个<code>master</code>和多个<code>slave</code>组成的模型。</p>
<h4 id="15-Redis分布式锁实现"><a href="#15-Redis分布式锁实现" class="headerlink" title="15.Redis分布式锁实现"></a>15.Redis分布式锁实现</h4><p>先拿<code>setnx</code>来争抢锁，抢到之后，再用<code>expire</code>给锁加一个过期时间防止锁忘记了释放。如果在<code>setnx</code>之后执行<code>expire</code>之前进程意外<code>crash</code>或者要重启维护了，那会怎么样？<br><code>set</code>指令有非常复杂的参数，这个应该是可以同时把<code>setnx</code>和<code>expire</code>合成一条指令来用的！</p>
<h4 id="16-Redis做异步队列"><a href="#16-Redis做异步队列" class="headerlink" title="16.Redis做异步队列"></a>16.Redis做异步队列</h4><p>一般使用<code>list</code>结构作为队列，<code>rpush</code>生产消息，<code>lpop</code>消费消息。当<code>lpop</code>没有消息的时候，要适当<code>sleep</code>一会再重试。<br><strong>缺点：</strong>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<code>rabbitmq</code>等。 能不能生产一次消费多次呢？使用<code>pub/sub</code>主题订阅者模式，可以实现<code>1:N</code>的消息队列。</p>
<h4 id="17-Redis中海量数据的正确操作方式"><a href="#17-Redis中海量数据的正确操作方式" class="headerlink" title="17.Redis中海量数据的正确操作方式"></a>17.Redis中海量数据的正确操作方式</h4><p>利用<code>SCAN</code>系列命令<code>（SCAN、SSCAN、HSCAN、ZSCAN）</code>完成数据迭代。</p>
<h4 id="18-是否使用过Redis集群，集群的原理是什么？"><a href="#18-是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="18.是否使用过Redis集群，集群的原理是什么？"></a>18.是否使用过Redis集群，集群的原理是什么？</h4><ul>
<li><code>Redis Sentinal</code>着眼于高可用，在<code>master</code>宕机时会自动将<code>slave</code>提升为<code>master</code>，继续提供服务。</li>
<li><code>Redis Cluster</code>着眼于扩展性，在单个<code>redis</code>内存不足时，使用<code>Cluster</code>进行分片存储。</li>
</ul>
<h4 id="19-Redis集群方案什么情况下会导致整个集群不可用？"><a href="#19-Redis集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="19.Redis集群方案什么情况下会导致整个集群不可用？"></a>19.Redis集群方案什么情况下会导致整个集群不可用？</h4><p>如果有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</p>
<h4 id="20-说说Redis哈希槽的概念"><a href="#20-说说Redis哈希槽的概念" class="headerlink" title="20.说说Redis哈希槽的概念"></a>20.说说Redis哈希槽的概念</h4><p>Redis集群没有使用一致性hash，而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<h4 id="21-Redis集群会有写操作丢失吗？为什么？"><a href="#21-Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="21.Redis集群会有写操作丢失吗？为什么？"></a>21.Redis集群会有写操作丢失吗？为什么？</h4><p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<h4 id="22-怎么测试Redis的连通性？"><a href="#22-怎么测试Redis的连通性？" class="headerlink" title="22.怎么测试Redis的连通性？"></a>22.怎么测试Redis的连通性？</h4><p><strong>使用ping命令。</strong></p>
<h4 id="23-怎么理解Redis事务？"><a href="#23-怎么理解Redis事务？" class="headerlink" title="23.怎么理解Redis事务？"></a>23.怎么理解Redis事务？</h4><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
<h4 id="24-Redis如何做内存优化？"><a href="#24-Redis如何做内存优化？" class="headerlink" title="24.Redis如何做内存优化？"></a>24.Redis如何做内存优化？</h4><p>尽可能使用散列表（<code>hashes</code>），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。<br>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p>
<h4 id="25-Redis回收进程如何工作的？"><a href="#25-Redis回收进程如何工作的？" class="headerlink" title="25.Redis回收进程如何工作的？"></a>25.Redis回收进程如何工作的？</h4><p>一个客户端运行了新的命令，添加了新的数据。Redis检查内存使用情况，如果大于<code>max memory</code>的限制, 则根据设定好的策略进行回收。一个新的命令被执行，等等。所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用（ 例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h4 id="26-MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"><a href="#26-MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？" class="headerlink" title="26.MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？"></a>26.MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</h4><p>Redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h4 id="27-假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#27-假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="27.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>27.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h4><p>使用<code>keys</code>指令可以扫出指定模式的<code>key</code>列表。如果这个<code>redis</code>正在给线上的业务提供服务，那使用<code>keys</code>指令会有什么问题？会造成阻塞卡顿。<br>因为<code>redis</code>是单线程的。<code>keys</code>指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用<code>scan</code>指令，<code>scan</code>指令可以 无阻塞的提取出指定模式的<code>key</code>列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用<code>keys</code>指令长。</p>
<h4 id="28-如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#28-如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="28.如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>28.如果有大量的key需要设置同一时间过期，一般需要注意什么？</h4><p>如果大量的<code>key</code>过期时间设置的过于集中，到过期的那个时间点，<code>redis</code>可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<h3 id="头条面试"><a href="#头条面试" class="headerlink" title="头条面试"></a>头条面试</h3><h4 id="1-Redis连接时的connect与pconnect的区别"><a href="#1-Redis连接时的connect与pconnect的区别" class="headerlink" title="1.Redis连接时的connect与pconnect的区别"></a>1.Redis连接时的connect与pconnect的区别</h4><p><code>connect</code>：脚本结束之后连接就释放了。<br><code>pconnect</code>：脚本结束之后连接不释放，连接保持在<code>php-fpm</code>进程中。</p>
<h4 id="2-Redis有哪些结构时间复杂度较高"><a href="#2-Redis有哪些结构时间复杂度较高" class="headerlink" title="2.Redis有哪些结构时间复杂度较高"></a>2.Redis有哪些结构时间复杂度较高</h4><p>List</p>
<h4 id="3-Redis-hash的实现"><a href="#3-Redis-hash的实现" class="headerlink" title="3.Redis hash的实现"></a>3.Redis hash的实现</h4><p>哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code> 。<br><code>ziplist</code> 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此,保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前，保存值的节点在后；先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</p>
<h4 id="4-redis-主从同步是怎样的过程？-见第7题"><a href="#4-redis-主从同步是怎样的过程？-见第7题" class="headerlink" title="4.redis 主从同步是怎样的过程？ 见第7题"></a>4.redis 主从同步是怎样的过程？ 见第7题</h4><h4 id="5-redis-的-zset-怎么实现的？"><a href="#5-redis-的-zset-怎么实现的？" class="headerlink" title="5.redis 的 zset 怎么实现的？"></a>5.redis 的 zset 怎么实现的？</h4><p>有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code> 。<br><code>ziplist</code> 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（<code>member</code>）， 而第二个元素则保存元素的分值（<code>score</code>）。 <code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现， 一个 <code>zset</code> 结构同时包含一个字典和一个跳跃表。</p>
<h3 id="小米面试"><a href="#小米面试" class="headerlink" title="小米面试"></a>小米面试</h3><h4 id="1-Redis数据结构有哪些"><a href="#1-Redis数据结构有哪些" class="headerlink" title="1.Redis数据结构有哪些"></a>1.Redis数据结构有哪些</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">String，List，Hash，Set，Sorted Set，bitmap，Geo，HyperLogLog ，Streams</span><br></pre></td></tr></table></figure>

<h4 id="2-Redis-持久化方案有哪些？"><a href="#2-Redis-持久化方案有哪些？" class="headerlink" title="2.Redis 持久化方案有哪些？"></a>2.Redis 持久化方案有哪些？</h4><p><code>RDB(Redis DataBase)</code>持久化：是指用数据集快照的方式半持久化模式，记录<code>redis</code>数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复 <code>**AOFAppend-only file**</code>。<br><strong>持久化： 是指所有的命令行记录以<code>redis</code>命令请求协议的格式完全持久化存储)保存为<code>aof</code>文件。</strong></p>
<h3 id="360面试"><a href="#360面试" class="headerlink" title="360面试"></a>360面试</h3><h4 id="1-redis的持久化"><a href="#1-redis的持久化" class="headerlink" title="1.redis的持久化"></a>1.redis的持久化</h4><p><code>RDB(Redis DataBase)</code>持久化： 是指用数据集快照的方式半持久化模式，记录redis数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复<code>**AOFAppend-only file**</code>。<br><strong>持久化： 是指所有的命令行记录以<code>redis</code>命令请求协议的格式完全持久化存储)保存为<code>aof</code>文件。</strong></p>
<h4 id="2-lru算法实现"><a href="#2-lru算法实现" class="headerlink" title="2.lru算法实现"></a>2.lru算法实现</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRU是最近最少使用页面置换算法(Least Recently Used)</span></span><br><span class="line"><span class="comment"> * 也就是首先淘汰最长时间未被使用的页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRU_Cache</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> $array_lru = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">private</span> $max_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 缓存最大存储</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;max_size = $size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set_value</span><span class="params">($key, $value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果存在，则向队尾移动，先删除，后追加</span></span><br><span class="line">        <span class="keyword">if</span> (array_key_exists($key, <span class="keyword">$this</span>-&gt;array_lru)) &#123;</span><br><span class="line">            <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;array_lru[$key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 长度检查，超长则删除首元素</span></span><br><span class="line">        <span class="keyword">if</span> (count(<span class="keyword">$this</span>-&gt;array_lru) &gt; <span class="keyword">$this</span>-&gt;max_size) &#123;</span><br><span class="line">            array_shift(<span class="keyword">$this</span>-&gt;array_lru);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 队尾追加元素</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;array_lru[$key] = $value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_value</span><span class="params">($key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $ret_value = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (array_key_exists($key, <span class="keyword">$this</span>-&gt;array_lru)) &#123;</span><br><span class="line">            $ret_value = <span class="keyword">$this</span>-&gt;array_lru[$key];</span><br><span class="line">            <span class="comment">// 移动到队尾</span></span><br><span class="line">            <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;array_lru[$key]);</span><br><span class="line">            <span class="keyword">$this</span>-&gt;array_lru[$key] = $ret_value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $ret_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">vardump_cache</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        var_dump(<span class="keyword">$this</span>-&gt;array_lru);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$cache = <span class="keyword">new</span> LRU_Cache(<span class="number">5</span>);</span><br><span class="line">$cache-&gt;set_value(<span class="string">"01"</span>, <span class="string">"01"</span>);</span><br><span class="line">$cache-&gt;set_value(<span class="string">"02"</span>, <span class="string">"02"</span>);</span><br><span class="line">$cache-&gt;set_value(<span class="string">"03"</span>, <span class="string">"03"</span>);</span><br><span class="line">$cache-&gt;set_value(<span class="string">"04"</span>, <span class="string">"04"</span>);</span><br><span class="line">$cache-&gt;set_value(<span class="string">"05"</span>, <span class="string">"05"</span>);</span><br><span class="line">$cache-&gt;vardump_cache();</span><br><span class="line">$cache-&gt;set_value(<span class="string">"06"</span>, <span class="string">"06"</span>);</span><br><span class="line">$cache-&gt;vardump_cache();</span><br><span class="line">$cache-&gt;set_value(<span class="string">"03"</span>, <span class="string">"03"</span>);</span><br><span class="line">$cache-&gt;vardump_cache();</span><br><span class="line">$cache-&gt;set_value(<span class="string">"07"</span>, <span class="string">"07"</span>);</span><br><span class="line">$cache-&gt;vardump_cache();</span><br><span class="line">$cache-&gt;set_value(<span class="string">"01"</span>, <span class="string">"01"</span>);</span><br><span class="line">$cache-&gt;vardump_cache();</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Python网络爬虫之Requests模块</title>
    <url>/Spider/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B9%8BRequests%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h3 id="Python网络爬虫之requests模块"><a href="#Python网络爬虫之requests模块" class="headerlink" title="Python网络爬虫之requests模块"></a>Python网络爬虫之requests模块</h3><h6 id="什么是requests模块"><a href="#什么是requests模块" class="headerlink" title="什么是requests模块"></a>什么是requests模块</h6><p>​        request模块是python中原生的基于网络请求的模块，其主要作用是用来模拟浏览器发起请求。功能强大，用法简洁高效。在爬虫领域中占着半壁江山的地位。</p>
<h6 id="为什么要使用request模块"><a href="#为什么要使用request模块" class="headerlink" title="为什么要使用request模块"></a>为什么要使用request模块</h6><p>​        因为在使用urllib模块的时候，会有诸多不便之处，总结如下：手动处理url编码，手动处理post请求参数，处理cookie和代理操作频繁。使用request模块：自动处理url编码，自动处理post请求参数，简化cookie和代理操作  <a id="more"></a></p>
<h6 id="如何使用request模块"><a href="#如何使用request模块" class="headerlink" title="如何使用request模块"></a>如何使用request模块</h6><p>安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>

<p>使用流程</p>
<p>指定url—-&gt;基于requests模块发起请求——-&gt;获取响应对象中的数据值——&gt;持久化存储</p>
<h6 id="request发送请求"><a href="#request发送请求" class="headerlink" title="request发送请求"></a>request发送请求</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>requests的get请求:</span><br><span class="line"><span class="comment"># requests的简单get请求</span></span><br><span class="line"><span class="comment"># requests.get + headers</span></span><br><span class="line"><span class="comment"># requests.get + headers + params</span></span><br><span class="line"><span class="comment"># requests.get + headers + params + proxy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">'...'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">	<span class="string">"User-Agent"</span>:<span class="string">'...'</span></span><br><span class="line">&#125;</span><br><span class="line">params = &#123;</span><br><span class="line">	<span class="string">'key'</span>: <span class="string">'value'</span></span><br><span class="line">&#125;</span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">'http'</span>: <span class="string">'http://127.0.0.1:8080'</span></span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'http://127.0.0.1:8899'</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.get(url=url, headers=headers, params=params, proxies=proxies)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理:</span></span><br><span class="line">	透明代理:</span><br><span class="line">	匿名代理:</span><br><span class="line">	高匿代理:</span><br><span class="line">        </span><br><span class="line"><span class="comment">#第一种: 反爬机制与反反爬策略</span></span><br><span class="line">反爬机制: UA检测</span><br><span class="line">反反爬策略: UA伪装</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>响应数据</span><br><span class="line"><span class="comment"># 获取响应数据内容:</span></span><br><span class="line">		res.text		获取HTML文本</span><br><span class="line">		res.content		获取二进制流</span><br><span class="line">		res.json()		获取json数据</span><br><span class="line"><span class="comment"># 响应数据的属性:</span></span><br><span class="line">	    res_code = res.status_code  <span class="comment"># 响应状态码(*)</span></span><br><span class="line">        res_headers = res.headers  <span class="comment"># 响应头信息</span></span><br><span class="line">        res_url = res.url  <span class="comment"># 此响应对应的请求url</span></span><br><span class="line">        res_cookie = res.cookies  <span class="comment"># 响应的cookies(*)</span></span><br><span class="line">        res_history = res.history  <span class="comment"># 请求历史</span></span><br></pre></td></tr></table></figure>

<h6 id="requests高阶用法"><a href="#requests高阶用法" class="headerlink" title="requests高阶用法"></a>requests高阶用法</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>requests上传文件操作</span><br><span class="line"><span class="number">2.</span>会话维持： Session对象</span><br><span class="line"><span class="number">3.</span>设置超时事件：timeout,请求<span class="number">5</span>秒内没有返回响应，则抛出异常</span><br><span class="line"><span class="number">4.</span>Prepare requests:构建requests对象，可以放入队列中实现爬取队列调度</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>requests上传文件操作</span><br><span class="line">	files=&#123;<span class="string">'file'</span>:open(<span class="string">'filename'</span>,<span class="string">'rb'</span>)&#125;</span><br><span class="line">    res=requests.post(url=url,files=files)</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>会话维持  Session对象</span><br><span class="line">	<span class="keyword">from</span> requests <span class="keyword">import</span> Session</span><br><span class="line">    session=Session()</span><br><span class="line">    res=requests.get(url=url,headers=headers)</span><br><span class="line"><span class="number">3.</span>设置超时时间：timeout,请求<span class="number">5</span>秒内没有返回相应，则抛出异常</span><br><span class="line">	res=requests.get(url=url,headers=headers,timeout=<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>Prepare Request: 构建request对象, 可以放入队列中实现爬取队列调度</span><br><span class="line">        <span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</span><br><span class="line">        url = <span class="string">'....'</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">'wd'</span>: <span class="string">'spiderman'</span></span><br><span class="line">        &#125;</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">'User-Agent'</span>: <span class="string">'...'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 1.实话session对象</span></span><br><span class="line">        session = Session()</span><br><span class="line">        <span class="comment"># 2.构建request对象, 传入必要参数</span></span><br><span class="line">        req = Request(<span class="string">'POST'</span>, url, data=data, headers=headers)</span><br><span class="line">        req = Request(<span class="string">'GET'</span>, url, params=params, headers=headers)</span><br><span class="line">        <span class="comment"># 3.应用prepared_request方法将request对象转化为Prepared Request对象</span></span><br><span class="line">        prepared = session.prepare_request(req)</span><br><span class="line">        <span class="comment"># 4.利用session的send方法发送请求</span></span><br><span class="line">        res = session.send(prepared)</span><br></pre></td></tr></table></figure>



<h6 id="xpath解析库"><a href="#xpath解析库" class="headerlink" title="xpath解析库"></a>xpath解析库</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Xpath解析库介绍:</span></span><br><span class="line">	数据解析的过程中使用过正则表达式, 但正则表达式想要进准匹配难度较高, 一旦正则表达式书写错误, 匹配的数据也会出错.</span><br><span class="line">    网页由三部分组成: HTML, Css, JavaScript, HTML页面标签存在层级关系, 即DOM树, 在获取目标数据时可以根据网页层次关系定位标签, 在获取标签的文本或属性.</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># xpath解析库解析数据原理:</span></span><br><span class="line"><span class="number">1.</span> 根据网页DOM树定位节点标签</span><br><span class="line"><span class="number">2.</span> 获取节点标签的征文文本即与属性值</span><br><span class="line"></span><br><span class="line"><span class="comment"># xpath安装, 初体验 --&gt; 使用步骤:</span></span><br><span class="line"><span class="number">1.</span>xpath安装: pip install lxml</span><br><span class="line"><span class="number">2.</span>requests模块爬取糗事百科热门的标题:</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.qiushibaike.com/'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.get(url=url, headers=headers)</span><br><span class="line"></span><br><span class="line">tree = etree.HTML(res.text)</span><br><span class="line">title_lst = tree.xpath(<span class="string">'//ul/li/div/a/text()'</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> title_lst:</span><br><span class="line">    print(item)</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>xpath使用步骤:</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">tree = etree.HTML(res.text)</span><br><span class="line">tree = etree.parse(res.html, etree.HTMLParse())  <span class="comment"># 示例如下, 了解内容</span></span><br><span class="line"></span><br><span class="line">tag_or_attr = tree.xpath(<span class="string">'xpath表达式'</span>)</span><br><span class="line"></span><br><span class="line">**********************************************************</span><br><span class="line"></span><br><span class="line"><span class="comment"># xpath解析本地文件</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.qiushibaike.com/'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.get(url=url, headers=headers)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'qb.html'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(res.text)</span><br><span class="line"></span><br><span class="line">tree = etree.parse(<span class="string">'./qb.html'</span>, etree.HTMLParser())</span><br><span class="line">title_lst = tree.xpath(<span class="string">'//ul/li/div/a/text()'</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> title_lst:</span><br><span class="line">    print(item)</span><br><span class="line">    </span><br><span class="line"> <span class="comment"># xpath语法:</span></span><br><span class="line"><span class="number">1.</span>常用规则:</span><br><span class="line">      <span class="number">1.</span>  nodename:		  节点名定位</span><br><span class="line">      <span class="number">2.</span>  //:			  从当前节点选取子孙节点</span><br><span class="line">      <span class="number">3.</span>  /:			  从当前节点选取直接子节点</span><br><span class="line">      <span class="number">4.</span>  nodename[@attribute=<span class="string">"..."</span>]  根据属性定位标签</span><br><span class="line">      <span class="number">5.</span>  @attributename:  获取属性 </span><br><span class="line">      <span class="number">6.</span>  text():		   获取文本</span><br><span class="line">   </span><br><span class="line"><span class="number">2.</span>属性匹配两种情况: 多属性匹配 &amp;  单属性多值匹配  </span><br><span class="line">     <span class="number">2.2</span> 多属性匹配</span><br><span class="line">    示例: tree.xpath(<span class="string">'//div[@class="item" and @name="test"]/text()'</span>) 	</span><br><span class="line">    <span class="number">2.1</span> 单属性多值匹配</span><br><span class="line">    示例: tree.xpath(<span class="string">'//div[contains(@class, "dc")]/text()'</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>按序选择:</span><br><span class="line">    <span class="number">3.1</span> 索引定位: 从<span class="number">1</span>开始</span><br><span class="line">    <span class="number">3.2</span> last()函数</span><br><span class="line">    <span class="number">3.3</span> position()函数</span><br></pre></td></tr></table></figure>

<h6 id="BeautifulSoup解析"><a href="#BeautifulSoup解析" class="headerlink" title="BeautifulSoup解析"></a>BeautifulSoup解析</h6><p>BeautifulSoup也是一个解析库<br>    BS解析数据是依赖解析器的, BS支持的解析器有html.parser, lxml, xml, html5lib等, 其中lxml解析器解析速度快, 容错能力强.<br>BS现阶段应用的解析器多数是lxml</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BeautifulSoup 使用步骤:</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(res.text, <span class="string">'lxml'</span>)</span><br><span class="line">tag = soup.select(<span class="string">"CSS选择器表达式"</span>)   <span class="comment"># 返回一个列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CSS选择器:</span></span><br><span class="line"><span class="number">1.</span>根据节点名及节点层次关系定位标签: 标签选择器  &amp;  层级选择器</span><br><span class="line">soup.select(<span class="string">'title'</span>)</span><br><span class="line">soup.select(<span class="string">'div &gt; ul &gt; li'</span>)   <span class="comment"># 单层级选择器</span></span><br><span class="line">soup.select(<span class="string">'div li'</span>)  <span class="comment"># 多层级选择器</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>根据节点的<span class="class"><span class="keyword">class</span>属性定位标签:</span> <span class="class"><span class="keyword">class</span>选择器</span></span><br><span class="line"><span class="class"><span class="title">soup</span>.<span class="title">select</span><span class="params">(<span class="string">'.panel'</span>)</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">3.根据<span class="title">id</span>属性定位标签:</span> id选择器</span><br><span class="line">soup.select(<span class="string">'#item'</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>嵌套选择:</span><br><span class="line">ul_list = soup.select(<span class="string">'ul'</span>)</span><br><span class="line"><span class="keyword">for</span> ul <span class="keyword">in</span> ul_list:</span><br><span class="line">  print(ul.select(<span class="string">'li'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取节点的文本或属性:</span></span><br><span class="line">tag_obj.string: 获取直接子文本--&gt;如果节点内有与直系文本平行的节点, 该方法拿到的是None</span><br><span class="line">tag_obj.get_text(): 获取子孙节点的所有文本</span><br><span class="line">tag_obj[<span class="string">'attribute'</span>]: 获取节点属性</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 练习示例:</span></span><br><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">    &lt;div class="panel"&gt;</span></span><br><span class="line"><span class="string">        &lt;div class="panel-heading"&gt;</span></span><br><span class="line"><span class="string">            &lt;h4&gt;BeautifulSoup练习&lt;/h4&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div class="panel-body"&gt;</span></span><br><span class="line"><span class="string">            &lt;ul class="list" id="list-1"&gt;</span></span><br><span class="line"><span class="string">                &lt;li class="element"&gt;第一个li标签&lt;/li&gt;</span></span><br><span class="line"><span class="string">                &lt;li class="element"&gt;第二个li标签&lt;/li&gt;</span></span><br><span class="line"><span class="string">                &lt;li class="element"&gt;第三个li标签&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">            &lt;ul class="list list-small"&gt;</span></span><br><span class="line"><span class="string">                &lt;li class="element"&gt;one&lt;/li&gt;</span></span><br><span class="line"><span class="string">                &lt;li class="element"&gt;two&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">            &lt;li class="element"&gt;测试多层级选择器&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line"><span class="comment"># 1.根据节点名定位节点, 获取其文本</span></span><br><span class="line">h4 = soup.select(<span class="string">'h4'</span>)   <span class="comment"># 标签选择器</span></span><br><span class="line">print(h4[<span class="number">0</span>].get_text())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.根据class属性定位节点</span></span><br><span class="line">panel = soup.select(<span class="string">'.panel-heading'</span>)</span><br><span class="line">print(panel)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.根据id属性定位节点</span></span><br><span class="line">ul = soup.select(<span class="string">'#list-1'</span>)</span><br><span class="line">print(ul)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.嵌套选择</span></span><br><span class="line">ul_list = soup.select(<span class="string">'ul'</span>)</span><br><span class="line"><span class="keyword">for</span> ul <span class="keyword">in</span> ul_list:</span><br><span class="line">    li = ul.select(<span class="string">'li'</span>)</span><br><span class="line">    print(li)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 5.单层级选择器与多层级选择器</span></span><br><span class="line">li_list_single = soup.select(<span class="string">".panel-body &gt; ul &gt; li"</span>)</span><br><span class="line">li_list_multi = soup.select(<span class="string">".panel-body li"</span>)</span><br></pre></td></tr></table></figure>



<h6 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h6><p>需求：爬取搜狗指定词条搜索后的页面数据</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import os</span><br><span class="line"><span class="meta">#指定搜索关键字</span></span><br><span class="line">word = input(<span class="string">'enter a word you want to search:'</span>)</span><br><span class="line"><span class="meta">#自定义请求头信息</span></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#指定url</span></span><br><span class="line">url = <span class="string">'https://www.sogou.com/web'</span></span><br><span class="line"><span class="meta">#封装get请求参数</span></span><br><span class="line">prams = &#123;</span><br><span class="line">    <span class="string">'query'</span>:word,</span><br><span class="line">    <span class="string">'ie'</span>:<span class="string">'utf-8'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#发起请求</span></span><br><span class="line">response = requests.<span class="keyword">get</span>(url=url,params=prams)</span><br><span class="line"></span><br><span class="line"><span class="meta">#获取响应数据</span></span><br><span class="line">page_text = response.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(<span class="string">'./sougou.html'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) as fp:</span><br><span class="line">    fp.write(page_text)</span><br></pre></td></tr></table></figure>

<h6 id="请求载体身份标识的伪装"><a href="#请求载体身份标识的伪装" class="headerlink" title="请求载体身份标识的伪装"></a>请求载体身份标识的伪装</h6><p>User-Agent:请求载体身份标识，通过浏览器发起的请求，请求载体为浏览器，则该请求的User-Agent为浏览器的身份标识。可以通过判断该值来获知该请求的载体究竟是基于那款浏览器还是基于爬虫程序。</p>
<p>反爬机制：某些门户网站会对访问该网站的请求中的User-Agent进行捕获和判断，如果该请求的UA为爬虫程序，则拒绝向该请求提供数据。</p>
<p>反反爬策略：将爬虫程序的UA伪装成某一款浏览器的身份标识</p>
<p>需求：requests带参的get请求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#百度原 https://www.baidu.com/s?wd=python  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36"</span></span><br><span class="line">	&#125;</span><br><span class="line">url = <span class="string">'https://www.baidu.com/s'</span></span><br><span class="line">data = &#123;<span class="string">'wd'</span> : <span class="string">'Scrapy'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#url不需要编码     会自动拼接</span></span><br><span class="line"></span><br><span class="line">res=requests.get(url=url,headers=headers,params=data)</span><br><span class="line">print(res.url)</span><br></pre></td></tr></table></figure>

<p>爬取校花网图片案列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36"</span>&#125;</span><br><span class="line"><span class="comment">#获取网页地址</span></span><br><span class="line"><span class="comment">#http://www.xiaohuar.com/list-1-3.html</span></span><br><span class="line"><span class="comment">#http://www.xiaohuar.com/list-1-5.html</span></span><br><span class="line"><span class="comment"># 'http://www.xueshengmai.com/list-1-%d.html'</span></span><br><span class="line"></span><br><span class="line">url=<span class="string">'http://www.xueshengmai.com/list-1-%d.html'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):<span class="comment">#4表示要爬取4页图片，这里可根据需求做出修改。</span></span><br><span class="line">    temp=(url % i)</span><br><span class="line">    <span class="comment"># print(temp)</span></span><br><span class="line">    <span class="comment">#获取网页源码</span></span><br><span class="line">    response=requests.get(url=temp,headers=headers)</span><br><span class="line">    tree=etree.HTML(response.text)</span><br><span class="line">    <span class="keyword">for</span> td <span class="keyword">in</span> tree:</span><br><span class="line">        pc=td.xpath(<span class="string">'//div[@class="item_t"]/div[1]/a/img/@src'</span>)        <span class="comment">#图片url</span></span><br><span class="line">        name=td.xpath(<span class="string">'//div[@class="item_t"]/div[1]/span/text()'</span>)   <span class="comment">#名字</span></span><br><span class="line">   </span><br><span class="line">        <span class="comment"># print(pc)</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> pc:</span><br><span class="line">            pc_url=<span class="string">'http://www.xueshengmai.com'</span>+x             <span class="comment">#美女图片</span></span><br><span class="line">            <span class="comment"># print(pc_url)</span></span><br><span class="line">            <span class="comment"># img_data=response.content</span></span><br><span class="line">            res=requests.get(url=pc_url,headers=headers)</span><br><span class="line">            img_data=res.content</span><br><span class="line">       </span><br><span class="line">            girl=pc_url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">            <span class="comment"># print(girl)</span></span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">'%s'</span>%girl,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(img_data)</span><br></pre></td></tr></table></figure>

<p>爬取梨视频</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  梨视频数据的爬取</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="comment"># 安装fake_useragent: pip install fake_useragent</span></span><br><span class="line">url = <span class="string">"https://www.pearvideo.com/category_8"</span></span><br><span class="line">ua = UserAgent().random</span><br><span class="line"><span class="comment"># 定制请求头</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 获取首页页面数据</span></span><br><span class="line">page_text = requests.get(url=url, headers=headers).text</span><br><span class="line"><span class="comment"># print("111", page_text)</span></span><br><span class="line"><span class="comment"># 获取首页页面数据的相关视频详情连接进行解析</span></span><br><span class="line">tree = etree.HTML(page_text)</span><br><span class="line">li_list = tree.xpath(<span class="string">"//div[@id='listvideoList']/ul/li"</span>)</span><br><span class="line">print(<span class="string">"哈哈哈"</span>, li_list)</span><br><span class="line"><span class="comment"># 详情的url</span></span><br><span class="line">detail_urls = []  <span class="comment"># type:list</span></span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">    detail_url = <span class="string">"http://www.pearvideo.com/"</span> + li.xpath(<span class="string">"./div/a/@href"</span>)[<span class="number">0</span>]  <span class="comment"># 此时返回的是一个列表</span></span><br><span class="line">    print(<span class="string">"222"</span>,detail_url)</span><br><span class="line">    title = li.xpath(<span class="string">"./div/a/div[@class='vervideo-title']/text()"</span>)[<span class="number">0</span>]</span><br><span class="line">    detail_urls.append(detail_url)</span><br><span class="line"></span><br><span class="line">print(detail_urls)</span><br><span class="line"><span class="comment"># 拿到每一个详情url发送get请求</span></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> detail_urls:</span><br><span class="line">    page_text = requests.get(url=url, headers=headers).text</span><br><span class="line">    video_url = re.findall(<span class="string">'srcUrl="(.*?)"'</span>, page_text, re.S)[<span class="number">0</span>]</span><br><span class="line">    print(<span class="string">"啧啧啧"</span>, video_url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 向视频的详情发送请求</span></span><br><span class="line">    data = requests.get(url=video_url, headers=headers).content</span><br><span class="line">    fileName = str(random.randint(<span class="number">1</span>,<span class="number">10000</span>)) + <span class="string">'.mp4'</span>  <span class="comment"># 随机生成视频文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 存储得到本地</span></span><br><span class="line">    <span class="keyword">with</span> open(fileName, <span class="string">"wb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(data)</span><br><span class="line">        print(fileName + <span class="string">"下载成功!"</span>)</span><br></pre></td></tr></table></figure>

<p>随手拍，分享经典一刻</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url=<span class="string">'http://jandan.net/ooxx'</span></span><br><span class="line"></span><br><span class="line">headers=&#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">res=requests.get(url=url,headers=headers)</span><br><span class="line"></span><br><span class="line">tree=etree.HTML(res.text)</span><br><span class="line"></span><br><span class="line">td_list=tree.xpath(<span class="string">'//div[@class="row"]/div[2]'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> td <span class="keyword">in</span> td_list:</span><br><span class="line">    img_src=<span class="string">'http:'</span>+td.xpath(<span class="string">'./p/img/@src'</span>)[<span class="number">0</span>]    <span class="comment">#需要拼接url</span></span><br><span class="line">    img_data=requests.get(url=img_src).content   <span class="comment">#图片二进制流</span></span><br><span class="line">    img_name=img_src.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'%s'</span>%img_name,<span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(img_data)</span><br></pre></td></tr></table></figure>

<h6 id="Selenium介绍"><a href="#Selenium介绍" class="headerlink" title="Selenium介绍"></a>Selenium介绍</h6><p>selenium是一个web自动化测试用的框架。程序员可以通过代码实现对浏览器的控制，比如打开网页，点击网页中的元素，实现鼠标滚动操作。<br>它支持多款浏览器，如谷歌浏览器，火狐浏览器等等，当然也支持无头浏览器。<br>目的：<br>    在爬取数据的过程中，经常遇到动态数据加载，一般动态数据加载有两种，一种通过ajax请求加载数据，另一种通过js代码加载动态数据。selenium可以模拟人操作真实浏览器，获取加载完成的页面数据。</p>
<p> ajax:<br>    url有规律且未加密，直接构建url连接请求<br>    url加密过无法破解规律  —–&gt;selenium<br>    js动态数据加载 —–&gt;  selenium</p>
<p>三元素：浏览器  驱动程序  selenium框架<br>    浏览器：推荐谷歌浏览器，标准稳定版本<br>    pip install selenium</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser=webdriver.Chrome(<span class="string">'./webdriver'</span>)  <span class="comment">#将驱动放在脚本所在的文件夹</span></span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">'www.baidu.com'</span>)</span><br></pre></td></tr></table></figure>

<h6 id="selenium常用操作"><a href="#selenium常用操作" class="headerlink" title="selenium常用操作"></a>selenium常用操作</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实列化浏览器对象</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser=webdriver.Chrome(<span class="string">'driverpath'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#发送get请求</span></span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取页面元素</span></span><br><span class="line">find_element_by_id:根据元素的id</span><br><span class="line">find_element_by_name:根据元素的name</span><br><span class="line">find_element_by_xpath:根据xpath表达式</span><br><span class="line">find_element_by_class_name:根据<span class="class"><span class="keyword">class</span>的值</span></span><br><span class="line"><span class="class"><span class="title">find_element_by_css_selector</span>:</span>根据css选择器</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点交互操作:</span></span><br><span class="line">click(): 点击</span><br><span class="line">send_keys(): 输入内容</span><br><span class="line">clear(): 清空操作</span><br><span class="line">execute_script(js): 执行指定的js代码</span><br><span class="line"><span class="comment"># JS代码: window.scrollTo(0, document.body.scrollHeight)可以模拟鼠标滚动一屏高度</span></span><br><span class="line">quit(): 退出浏览器</span><br><span class="line">    I quit! 我不干!</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 获取网页的数据:</span></span><br><span class="line">browser.page_source   ---&gt;  str类型</span><br><span class="line"></span><br><span class="line"><span class="comment"># frame</span></span><br><span class="line">switch_to.frame(<span class="string">'frameid'</span>)</span><br></pre></td></tr></table></figure>

<p>selenium百度图片抓取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 百度图片抓取:</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.实例化浏览器对象</span></span><br><span class="line">browser = webdriver.Chrome(<span class="string">'./chromedriver.exe'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.向服务器发起请求</span></span><br><span class="line">browser.get(<span class="string">'http://image.baidu.com/'</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.输入关键字</span></span><br><span class="line">input_tag = browser.find_element_by_id(<span class="string">'kw'</span>)</span><br><span class="line">input_tag.send_keys(<span class="string">'腰子姐'</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.点击搜索</span></span><br><span class="line">button = browser.find_element_by_class_name(<span class="string">'s_search'</span>)</span><br><span class="line">button.click()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.实现滚动下拉</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    browser.execute_script(<span class="string">'window.scrollTo(0, document.body.scrollHeight)'</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">text = browser.page_source</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.实现数据解析</span></span><br><span class="line">soup = BeautifulSoup(text, <span class="string">'lxml'</span>)</span><br><span class="line"></span><br><span class="line">li_list = soup.select(<span class="string">'.imgpage ul li'</span>)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">    href = li[<span class="string">'data-objurl'</span>]</span><br><span class="line">    <span class="comment"># print(href)</span></span><br><span class="line">    <span class="comment"># request.urlretrieve(href, '%s.jpg'%li_list.index(li))</span></span><br><span class="line">    res = requests.get(url=href, headers=headers)</span><br><span class="line">    <span class="comment"># res.text: 文本数据</span></span><br><span class="line">    <span class="comment"># res.json(): json数据</span></span><br><span class="line">    <span class="comment"># res.content: 二进制流</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'%s.jpg'</span>%li_list.index(li), <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(res.content)</span><br><span class="line"></span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure>





<p>qq空间模拟登陆</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 实例化浏览器对象</span></span><br><span class="line">browser = webdriver.Chrome(<span class="string">r'C:\Users\lenovo\Desktop\sp\chromedriver.exe'</span>)</span><br><span class="line"><span class="comment">#注意浏览器版本号与插件版本号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开qq空间登陆页面</span></span><br><span class="line">browser.get(<span class="string">'https://qzone.qq.com/'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 转至frame子页面</span></span><br><span class="line">browser.switch_to.frame(<span class="string">'login_frame'</span>)</span><br><span class="line"><span class="comment"># 获取密码登陆选项并点击</span></span><br><span class="line">a_tag = browser.find_element_by_id(<span class="string">'switcher_plogin'</span>)</span><br><span class="line">a_tag.click()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 获取账号输入框并输入账号</span></span><br><span class="line">browser.find_element_by_id(<span class="string">'u'</span>).clear()</span><br><span class="line">user = browser.find_element_by_id(<span class="string">'u'</span>)</span><br><span class="line">user.send_keys(<span class="string">'账号'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 获取密码输入框并输入密码</span></span><br><span class="line">browser.find_element_by_id(<span class="string">'p'</span>).clear()</span><br><span class="line">pwd = browser.find_element_by_id(<span class="string">'p'</span>)</span><br><span class="line">pwd.send_keys(<span class="string">'密码'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 获取登陆按钮并单击</span></span><br><span class="line">button = browser.find_element_by_id(<span class="string">'login_button'</span>)</span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure>

<h6 id="Scrapy安装与环境依赖"><a href="#Scrapy安装与环境依赖" class="headerlink" title="Scrapy安装与环境依赖"></a>Scrapy安装与环境依赖</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.在安装scrapy前需要安装好相应的依赖库, 再安装scrapy, 具体安装步骤如下:</span></span><br><span class="line">    (<span class="number">1</span>).安装lxml库: pip install lxml</span><br><span class="line">    (<span class="number">2</span>).安装wheel: pip install wheel</span><br><span class="line">    (<span class="number">3</span>).安装twisted: pip install twisted文件路径</span><br><span class="line">    	(twisted需下载后本地安装,下载地址:http://www.lfd.uci.edu/~gohlke/pythonlibs/<span class="comment">#twisted)</span></span><br><span class="line">    	(版本选择如下图,版本后面有解释,请根据自己实际选择)</span><br><span class="line">    (<span class="number">4</span>).安装pywin32: pip install pywin32</span><br><span class="line">    	(注意:以上安装步骤一定要确保每一步安装都成功,没有报错信息,如有报错自行百度解决)</span><br><span class="line">    (<span class="number">5</span>).安装scrapy: pip install scrapy</span><br><span class="line">    	(注意:以上安装步骤一定要确保每一步安装都成功,没有报错信息,如有报错自行百度解决)</span><br><span class="line">    (<span class="number">6</span>).成功验证:在cmd命令行输入scrapy,显示Scrapy1<span class="number">.6</span><span class="number">.0</span>-no active project,证明安装成功</span><br></pre></td></tr></table></figure>

<p>2.创建项目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>手动创建一个目录test</span><br><span class="line"><span class="number">2.</span>在test文件夹下创建项目为：scrapy startproject spiderpro</span><br><span class="line"><span class="number">3.</span>进入项目文件夹： cd spiderpro</span><br><span class="line"><span class="number">4.</span>创建爬虫文件: Scrapy genspider 爬虫名  域名</span><br></pre></td></tr></table></figure>

<p>3.项目目录介绍</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spiderpro</span><br><span class="line">　　spiderpro <span class="comment"># 项目目录</span></span><br><span class="line">　　　　__init__</span><br><span class="line">　　　　spiders:爬虫文件目录</span><br><span class="line">　　　　　　__init__</span><br><span class="line">　　　　　　tests.py:爬虫文件</span><br><span class="line">　　　　items.py:定义爬取数据持久化的数据结构</span><br><span class="line">　　　　middlewares.py:定义中间件</span><br><span class="line">　　　　pipelines.py:管道,持久化存储相关</span><br><span class="line">　　　　settings.py:配置文件</span><br><span class="line">　　venv:虚拟环境目录</span><br><span class="line">　 scrapy.cfg: scrapy项目配置文件</span><br></pre></td></tr></table></figure>

<p>说明</p>
<p>　(1).spiders:其内包含一个个Spider的实现, 每个Spider是一个单独的文件<br>　　(2).items.py:它定义了Item数据结构, 爬取到的数据存储为哪些字段<br>　　(3).pipelines.py:它定义Item Pipeline的实现<br>　　(4).settings.py:项目的全局配置<br>　　(5).middlewares.py:定义中间件, 包括爬虫中间件和下载中间件<br>　　(6).scrapy.cfg:它是scrapy项目的配置文件, 其内定义了项目的配置路径, 部署相关的信息等</p>
<hr>
<h6 id="Scrapy框架介绍：5大核心组件与数据流向"><a href="#Scrapy框架介绍：5大核心组件与数据流向" class="headerlink" title="Scrapy框架介绍：5大核心组件与数据流向"></a>Scrapy框架介绍：5大核心组件与数据流向</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>).架构:</span><br><span class="line"></span><br><span class="line">　　Scrapy Engine: 这是引擎，负责Spiders、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等等!</span><br><span class="line"></span><br><span class="line">　　Scheduler(调度器): 它负责接受引擎发送过来的requests请求，并按照一定的方式进行整理排列，入队、并等待Scrapy Engine(引擎)来请求时，交给引擎。</span><br><span class="line"></span><br><span class="line">　　Downloader（下载器)：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spiders来处理</span><br><span class="line"></span><br><span class="line">　　Spiders：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)，</span><br><span class="line"></span><br><span class="line">　　Item Pipeline：它负责处理Spiders中获取到的Item，并进行处理，比如去重，持久化存储（存数据库，写入文件，总之就是保存数据用的）</span><br><span class="line"></span><br><span class="line">　　Downloader Middlewares(下载中间件)：你可以当作是一个可以自定义扩展下载功能的组件</span><br><span class="line"></span><br><span class="line">　　Spider Middlewares(Spider中间件)：你可以理解为是一个可以自定扩展和操作引擎和Spiders中间‘通信‘的功能组件（比如进入Spiders的Responses;和从Spiders出去的Requests）</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>).工作流:</span><br><span class="line"></span><br><span class="line">　　<span class="number">1.</span>spider将请求发送给引擎, 引擎将request发送给调度器进行请求调度</span><br><span class="line"></span><br><span class="line">　　<span class="number">2.</span>调度器把接下来要请求的request发送给引擎, 引擎传递给下载器, 中间会途径下载中间件</span><br><span class="line"></span><br><span class="line">　　<span class="number">3.</span>下载携带request访问服务器, 并将爬取内容response返回给引擎, 引擎将response返回给spider</span><br><span class="line"></span><br><span class="line">　　<span class="number">4.</span>spider将response传递给自己的parse进行数据解析处理及构建item一系列的工作, 最后将item返回给引擎, 引擎传递个pipeline</span><br><span class="line"></span><br><span class="line">　　<span class="number">5.</span>pipeline获取到item后进行数据持久化</span><br><span class="line"></span><br><span class="line">　　<span class="number">6.</span>以上过程不断循环直至爬虫程序终止</span><br></pre></td></tr></table></figure>

<p>5.使用scrapy框架爬取糗百</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建项目</span></span><br><span class="line">scrapy startproject qbsk</span><br><span class="line">cd qsbk  <span class="comment">#切换到项目目录</span></span><br><span class="line">scrapy genspider qsbk_hot www.qiushibaike.com <span class="comment">#创建爬虫文件，qsbk_hot为爬虫名</span></span><br><span class="line">www....com为爬取范围</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#item文件定义数据存储的字段：</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QsbkItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    title = scrapy.Field()  <span class="comment"># 标题</span></span><br><span class="line">    lau = scrapy.Field()  <span class="comment"># 好笑数</span></span><br><span class="line">    comment = scrapy.Field()  <span class="comment"># 评论数</span></span><br><span class="line">    auth = scrapy.Field()  <span class="comment"># 作者</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spider文件中定义解析数据的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QsbkHotSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">	name =<span class="string">'qsbk_hot'</span></span><br><span class="line">	<span class="comment"># allowed_domains = ['www.qiushibaike.com'] # 无用, 可注释掉</span></span><br><span class="line">	start_urls =[<span class="string">'http://www.qiushibaike.com/'</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 思路:一条热点数据在前端中对应一个li标签, 将一页中的所有li标签取出, 再进一步操作</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line"></span><br><span class="line">		li_list = response.selector.xpath(<span class="string">'//div[@class="recommend-article"]/ul/li'</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 循环li标签组成的列表, 先实例化item, 再取需要的字段, 并该item对象的相应属性赋值</span></span><br><span class="line">		<span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">			<span class="comment"># 实例化item对象</span></span><br><span class="line">			item =QsbkItem()</span><br><span class="line">			<span class="comment"># 解析获取title(标题), lau(好笑数), comment(评论数), auth(作者)等信息</span></span><br><span class="line">			title = ....</span><br><span class="line">			lau = ....</span><br><span class="line">			comment = ....</span><br><span class="line">			auth = ....</span><br><span class="line"></span><br><span class="line">			<span class="comment"># 将字段的值存储在item的属性中</span></span><br><span class="line"></span><br><span class="line">			<span class="comment"># 返回item, 框架会自动将item传送至pipeline中的指定类</span></span><br><span class="line">			<span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在pipeline中定义管道类进行数据的存储</span></span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">classQsbkPipeline(object):</span><br><span class="line">　　<span class="comment"># 连接MongoDB数据库</span></span><br><span class="line">	conn = pymongo.MongoClient(<span class="string">"localhost"</span>, <span class="number">27017</span>)</span><br><span class="line">	db = conn.qiubai</span><br><span class="line">	table = db.qb_hot</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">　　　　<span class="comment"># 向数据库中出入数据</span></span><br><span class="line">　　　　self.table.insert(dict(item))</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment"># 此处return item是为了下一个管道类能够接收到item进行存储</span></span><br><span class="line">　　　　<span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self)</span>:</span></span><br><span class="line">　　　　<span class="comment"># 关闭数据库连接</span></span><br><span class="line">　　　　self.conn.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此示例中配置文件中的配置的项, 注意是不是全部的配置, 是针对该项目增加或修改的配置项</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略robots协议</span></span><br><span class="line">ROBOTSTXT_OBEY =<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># UA伪装</span></span><br><span class="line">USER_AGENT = <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 管道类的注册配置</span></span><br><span class="line">ITEM_PIPELINES =&#123;</span><br><span class="line"><span class="string">'qsbk.pipelines.QsbkPipeline'</span>:<span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Scrapy爬取校花网人名与图片下载链接"><a href="#Scrapy爬取校花网人名与图片下载链接" class="headerlink" title="Scrapy爬取校花网人名与图片下载链接"></a>Scrapy爬取校花网人名与图片下载链接</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需求: 爬取校花网大学校花的默认的第一页的所有图片src和人名, 并通过管道存入mongodb数据库</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建item类, 用于存储解析出的数据</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaohuaspiderItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    name = scrapy.Field()</span><br><span class="line">    src = scrapy.Field()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spider中定义爬取的行为与解析数据的操作</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> XiaohuaspiderItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'hua'</span></span><br><span class="line">    <span class="comment"># allowed_domains = ['www.baidu.com']</span></span><br><span class="line">    start_urls = [<span class="string">'http://www.xiaohuar.com/hua/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        div_list = response.xpath(<span class="string">'//div[@class="img"]'</span>)</span><br><span class="line">        <span class="keyword">for</span> div <span class="keyword">in</span> div_list:</span><br><span class="line">            item = XiaohuaspiderItem()</span><br><span class="line">            name = ...(xpath匹配)</span><br><span class="line">            src = ...(xpath匹配)</span><br><span class="line">            <span class="comment"># 将数据存储到item的属性中</span></span><br><span class="line">            item[...] = ...</span><br><span class="line">            item[...] = ...</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># itemPipeline编码, 持久化数据到本地</span></span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaohuaspiderPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    conn = pymongo.MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)</span><br><span class="line">    db = conn.xiaohua</span><br><span class="line">    table = db.hua</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        self.table.insert(dict(item))</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.conn.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置项:</span></span><br><span class="line"><span class="comment"># UA伪装:</span></span><br><span class="line">USER_AGENT = <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.87 Safari/537.36'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略robots协议:</span></span><br><span class="line">ROBOTSTXT_OBEY = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启管道类</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">'xiaohuaspider.pipelines.XiaohuaspiderPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.确定爬取的字段, 在items.py中定义字段</span></span><br><span class="line"><span class="comment"># 2.将要爬取的url, 放置在start_urls, 要把allowed_domains注释掉</span></span><br><span class="line"><span class="comment"># 3.在parse当中定义解析规则</span></span><br><span class="line">	<span class="number">1</span>).解析响应数据</span><br><span class="line">	<span class="number">2</span>).存储在临时的容器中, item对象</span><br><span class="line">	<span class="number">3</span>).<span class="keyword">yield</span> item: 将item提交给管道</span><br><span class="line"><span class="comment"># 4.在管道中实现与数据库的交互</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RtysPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        conn = pymongo.MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)</span><br><span class="line">        db = conn.rtys</span><br><span class="line">        table = db.ys</span><br><span class="line">        table.insert_one(dict(item))</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"><span class="comment"># 运行项目：</span></span><br><span class="line">scrapy crawl 爬虫名</span><br></pre></td></tr></table></figure>



<h6 id="1-Scrapy多页爬取"><a href="#1-Scrapy多页爬取" class="headerlink" title="1.Scrapy多页爬取"></a>1.Scrapy多页爬取</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spider编码在原基础之上, 构建其他页面的url地址, 并利用scrapy.Request发起新的请求, 请求的回调函数依然是parse:</span></span><br><span class="line">page = <span class="number">1</span></span><br><span class="line">base_url = <span class="string">'http://www.xiaohuar.com/list-1-%s.html'</span></span><br><span class="line"><span class="keyword">if</span> self.page &lt; <span class="number">4</span>:</span><br><span class="line">    page_url = base_url%self.page</span><br><span class="line">    self.page += <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> scrapy.Request(url=page_url, callback=self.parse)</span><br><span class="line"><span class="comment"># (其他文件不用改动)</span></span><br></pre></td></tr></table></figure>

<h6 id="2-scrapy爬取详情页"><a href="#2-scrapy爬取详情页" class="headerlink" title="2.scrapy爬取详情页"></a>2.scrapy爬取详情页</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需求: 爬取笑话的标题与详情页连接, 通过详情页链接, 爬取详情页笑话内容</span></span><br><span class="line"><span class="comment"># item编码: 定义数据持久化的字段信息</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JokeItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    content = scrapy.Field()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spider的编码:</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> JokeItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XhSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'xh'</span></span><br><span class="line">    <span class="comment"># allowed_domains = ['www.baidu.com']</span></span><br><span class="line">    start_urls = [<span class="string">'http://www.jokeji.cn/list.htm'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        li_list = response.xpath(<span class="string">'//div[@class="list_title"]/ul/li'</span>)</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">            title = li.xpath(<span class="string">'./b/a/text()'</span>).extract_first()</span><br><span class="line">            link = <span class="string">'http://www.jokeji.cn'</span> + li.xpath(<span class="string">'./b/a/@href'</span>).extract_first()</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=link, callback=self.datail_parse, meta=&#123;<span class="string">"title"</span>:title&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">datail_parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        joke_list = response.xpath(<span class="string">'//span[@id="text110"]//text()'</span>).extract()</span><br><span class="line">        title = response.meta[<span class="string">"title"</span>]</span><br><span class="line">        content = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> joke_list:</span><br><span class="line">            content += s</span><br><span class="line">        item = JokeItem()</span><br><span class="line">        item[<span class="string">"title"</span>] = title</span><br><span class="line">        item[<span class="string">"content"</span>] = content</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pipeline编码: 数据持久化具体操作</span></span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JokePipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    conn = pymongo.MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)</span><br><span class="line">    db = conn.haha</span><br><span class="line">    table = db.hahatable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        self.table.insert(dict(item))</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.conn.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings配置编码:</span></span><br><span class="line">UA伪装</span><br><span class="line">Robots协议</span><br><span class="line">Item_Pipeline</span><br></pre></td></tr></table></figure>

<h6 id="3-scrapy发送post请求"><a href="#3-scrapy发送post请求" class="headerlink" title="3.scrapy发送post请求"></a>3.scrapy发送post请求</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FySpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'fy'</span></span><br><span class="line">    <span class="comment"># allowed_domains = ['www.baidu.com']</span></span><br><span class="line">    start_urls = [<span class="string">'https://fanyi.baidu.com/sug'</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">'kw'</span>:<span class="string">'boy'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">yield</span> scrapy.FormRequest(url=self.start_urls[<span class="number">0</span>], callback=self.parse, formdata=data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        print(<span class="number">1111111111111111111111111111111111111111111111111111111111111111111111111111111111</span>)</span><br><span class="line">        print(response.text)</span><br><span class="line">        print(json.loads(response.text))</span><br><span class="line">        </span><br><span class="line"> print(<span class="number">2222222222222222222222222222222222222222222222222222222222222222222222222222222222</span>)</span><br></pre></td></tr></table></figure>



<h6 id="scrapy对接selenium"><a href="#scrapy对接selenium" class="headerlink" title="scrapy对接selenium"></a>scrapy对接selenium</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">selenium可以实现抓取动态数据</span><br><span class="line">scrapy不能抓取动态数据, 如果是ajax请求, 可以请求接口, 如果是js动态加载, 需要结合selenium</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> WynewsItem</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'news'</span></span><br><span class="line">    <span class="comment"># allowed_domains = ['www.baidu.com']</span></span><br><span class="line">    start_urls = [<span class="string">'https://news.163.com/domestic/'</span>]</span><br><span class="line">    option.add_experimental_option(<span class="string">'excludeSwitches'</span>, [<span class="string">'enable-automation'</span>])				      			bro=webdriver.Chrome(executable_path=<span class="string">r'C:\Users\Administrator\Desktop\news\wynews\wynews\spiders\chromedriver.exe'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detail_parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        content_list = response.xpath(<span class="string">'//div[@id="endText"]/p//text()'</span>).extract()</span><br><span class="line">        content = <span class="string">''</span></span><br><span class="line">        title = response.meta[<span class="string">'title'</span>]</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> content_list:</span><br><span class="line">            content += s</span><br><span class="line">        item = WynewsItem()</span><br><span class="line">        item[<span class="string">"title"</span>] = title</span><br><span class="line">        item[<span class="string">"content"</span>] = content</span><br><span class="line">        <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        div_list = response.xpath(<span class="string">'//div[contains(@class, "data_row")]'</span>)</span><br><span class="line">        <span class="keyword">for</span> div <span class="keyword">in</span> div_list:</span><br><span class="line">            link = div.xpath(<span class="string">'./a/@href'</span>).extract_first()</span><br><span class="line">            title = div.xpath(<span class="string">'./div/div[1]/h3/a/text()'</span>).extract_first()</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=link, callback=self.detail_parse, meta=&#123;<span class="string">"title"</span>:title&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中间件编码:</span></span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> HtmlResponse</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WynewsDownloaderMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response, spider)</span>:</span></span><br><span class="line">        bro = spider.bro</span><br><span class="line">        <span class="keyword">if</span> request.url <span class="keyword">in</span> spider.start_urls:</span><br><span class="line">            bro.get(request.url)</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            js = <span class="string">'window.scrollTo(0, document.body.scrollHeight)'</span></span><br><span class="line">            bro.execute_script(js)</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            response_selenium = bro.page_source</span><br><span class="line">            <span class="keyword">return</span> HtmlResponse(url=bro.current_url, body=response_selenium, encoding=<span class="string">"utf-8"</span>, request=request)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pipeline编码:</span></span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WynewsPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    conn = pymongo.MongoClient(<span class="string">'localhost'</span>, <span class="number">27017</span>)</span><br><span class="line">    db = conn.wynews</span><br><span class="line">    table = db.newsinfo</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        self.table.insert(dict(item))</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>

<h6 id="pipeline数据持久化"><a href="#pipeline数据持久化" class="headerlink" title="pipeline数据持久化"></a>pipeline数据持久化</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MongoDB交互:</span></span><br><span class="line"><span class="keyword">import</span> Pymongo</span><br><span class="line"><span class="comment"># 管道类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 初始化方法, __new__: 构造方法, 在内存中开辟一块空间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mongo_uri, mongo_db)</span>:</span></span><br><span class="line">        self.mongo_uri = mongo_uri</span><br><span class="line">        self.mongo_db = mongo_db</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls(</span><br><span class="line">        	mongo_uri = crawler.settings.get(<span class="string">'MONGO_URI'</span>),</span><br><span class="line">            mongo_db = crawler.settings.get(<span class="string">'MONGO_DB'</span>)</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.client = pymongo.MongoClient(self.mongo_uri)</span><br><span class="line">        self.db = self.client[self.mongo_db]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        self.db[<span class="string">'news'</span>].insert(dict(item))</span><br><span class="line">        <span class="comment"># 在一个项目中可能存在多个管道类, 如果该管道类后面还有管道类需要存储数据, 必须return item</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.client.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MySQL交互:</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, database, user, password, port)</span>:</span></span><br><span class="line">        self.host = host</span><br><span class="line">        self.database = database</span><br><span class="line">        self.user = user</span><br><span class="line">        self.password = password</span><br><span class="line">        self.port = port</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls(</span><br><span class="line">        	host = crawler.settings.get(<span class="string">'MYSQL_HOST'</span>)</span><br><span class="line">            database = crawler.settings.get(<span class="string">'MYSQL_DATABASE'</span>)</span><br><span class="line">            user = crawler.settings.get(<span class="string">'MYSQL_USER'</span>)</span><br><span class="line">            password= crawler.settings.get(<span class="string">'MYSQL_PASSWORD'</span>)</span><br><span class="line">            port = crawler.settings.get(<span class="string">'MYSQL_PORT'</span>)</span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.db = pymysql.connect(self.host, self.user, self.password, self.database, charset=<span class="string">'utf8'</span>, port=self.port)</span><br><span class="line">        self.cursor = self.db.cursor()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        data = dict(item)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># data.keys()--&gt; 获取所有的键, 字段 --&gt; 'title,content'</span></span><br><span class="line">        keys = <span class="string">','</span>.join(data.keys())</span><br><span class="line">        <span class="comment"># ['%s']*len(data)  --&gt; ['%s', '%s']</span></span><br><span class="line">        <span class="comment"># ','.join(['%s', '%s'])  --&gt;  '%s,%s'</span></span><br><span class="line">        values = <span class="string">','</span>.join([<span class="string">'%s'</span>]*len(data))</span><br><span class="line">        sql = <span class="string">'insert into %s (%s) values (%s)'</span> % (tablename, keys, values)</span><br><span class="line">        self.cursor.execute(sql, tuple(data.values()))</span><br><span class="line">        self.db.commit()</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用于文件下载的管道类</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spider编码:</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> XhxhItem</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XhSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'xh'</span></span><br><span class="line">    <span class="comment"># allowed_domains = ['www.baidu.com']</span></span><br><span class="line">    start_urls = [<span class="string">'http://www.521609.com/qingchunmeinv/'</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        li_list = response.xpath(<span class="string">'//div[@class="index_img list_center"]/ul/li'</span>)</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">            item = XhxhItem()</span><br><span class="line">            link = li.xpath(<span class="string">'./a[1]/img/@src'</span>).extract_first()</span><br><span class="line">            item[<span class="string">'img_link'</span>] = <span class="string">'http://www.521609.com'</span> + link</span><br><span class="line">            print(item)</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># items编码:</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XhxhItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    img_link = scrapy.Field()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 管道编码:</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XhxhPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImgPipeLine</span><span class="params">(ImagesPipeline)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_media_requests</span><span class="params">(self, item, info)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(url=item[<span class="string">'img_link'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">file_path</span><span class="params">(self, request, response=None, info=None)</span>:</span></span><br><span class="line">        url = request.url</span><br><span class="line">        file_name = url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> file_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">item_completed</span><span class="params">(self, results, item, info)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings编码:</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">'xhxh.pipelines.XhxhPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">   <span class="string">'xhxh.pipelines.ImgPipeLine'</span>: <span class="number">301</span>,</span><br><span class="line">&#125;</span><br><span class="line">IMAGES_STORE = <span class="string">'./mvs'</span></span><br></pre></td></tr></table></figure>

<h6 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装:</span></span><br><span class="line">pip install virtualenvwrapper-win</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常用命令:</span></span><br><span class="line">mkvirtualenv envname  <span class="comment"># 创建虚拟环境并自动切换到该环境下</span></span><br><span class="line">workon envname  <span class="comment"># 切换到某虚拟环境下</span></span><br><span class="line">pip list / pip show / pip freeze / pip freeze -all</span><br><span class="line">rmvirtualenv envname  <span class="comment"># 删除虚拟环境</span></span><br><span class="line">deactivate  <span class="comment"># 退出虚拟环境</span></span><br><span class="line">lsvirtualenv  <span class="comment"># 列出所有常见的虚拟环境</span></span><br><span class="line">mkvirtualenv --python==C:\...\python.exe envname  <span class="comment"># 指定Python解释器创建虚拟环境</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同一项目环境</span></span><br><span class="line">pip freeze &gt; requirements.txt</span><br><span class="line">pip install -r C:\...\requirements.txt</span><br><span class="line">pip uninstall -r C:\...\requirements.txt</span><br></pre></td></tr></table></figure>

<h6 id="Scrapy-amp-Django项目"><a href="#Scrapy-amp-Django项目" class="headerlink" title="Scrapy &amp; Django项目"></a>Scrapy &amp; Django项目</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spider编写:</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> dl.items <span class="keyword">import</span> DlItem</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'p'</span></span><br><span class="line">    <span class="comment"># allowed_domains = ['www.baidu.com']</span></span><br><span class="line">    start_urls = [<span class="string">'https://www.kuaidaili.com/free/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="comment"># print(response)</span></span><br><span class="line">        tr_list = response.xpath(<span class="string">'//*[@id="list"]/table/tbody/tr'</span>)</span><br><span class="line">        <span class="comment"># print(tr_list)</span></span><br><span class="line">        <span class="keyword">for</span> tr <span class="keyword">in</span> tr_list:</span><br><span class="line">            ip = tr.xpath(<span class="string">'./td[1]/text()'</span>).extract_first()</span><br><span class="line">            port = tr.xpath(<span class="string">'./td[2]/text()'</span>).extract_first()</span><br><span class="line">            typ = tr.xpath(<span class="string">'./td[3]/text()'</span>).extract_first()</span><br><span class="line">            protocal = tr.xpath(<span class="string">'./td[4]/text()'</span>).extract_first()</span><br><span class="line">            position = tr.xpath(<span class="string">'./td[5]/text()'</span>).extract_first()</span><br><span class="line">            <span class="comment"># print(ip, port, protocal, position)</span></span><br><span class="line">            item = DlItem()</span><br><span class="line">            item[<span class="string">'ip'</span>] = ip</span><br><span class="line">            item[<span class="string">'port'</span>] = port</span><br><span class="line">            item[<span class="string">'typ'</span>] = typ</span><br><span class="line">            item[<span class="string">'protocal'</span>] = protocal</span><br><span class="line">            item[<span class="string">'position'</span>] = position</span><br><span class="line">            print(item)</span><br><span class="line">            <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># items编码</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DlItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    ip = scrapy.Field()</span><br><span class="line">    port = scrapy.Field()</span><br><span class="line">    typ = scrapy.Field()</span><br><span class="line">    protocal = scrapy.Field()</span><br><span class="line">    position = scrapy.Field()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Django项目创建与所有配置:</span></span><br><span class="line"><span class="number">1.</span>models创建:</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    ip = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    port = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    typ = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    protocal = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    position = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>在scrapy框架项目中嵌入django</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(os.path.dirname(os.path.abspath(<span class="string">'.'</span>)))</span><br><span class="line">os.environ[<span class="string">'DJANGO_SETTINGS_MODULE'</span>] = <span class="string">'proxyscan.settings'</span></span><br><span class="line"><span class="comment"># 手动初始化Django：</span></span><br><span class="line"><span class="keyword">import</span> django</span><br><span class="line">django.setup()</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>修改爬虫item:</span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy_djangoitem <span class="keyword">import</span> DjangoItem</span><br><span class="line"><span class="keyword">from</span> proxy <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DlItem</span><span class="params">(DjangoItem)</span>:</span></span><br><span class="line">    django_model = models.Proxy</span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>pipeline编码:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DlPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        print(<span class="string">'开启数据库, 进行数据存储'</span>)</span><br><span class="line">        item.save()</span><br><span class="line">        print(<span class="string">'关闭数据库'</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    </span><br><span class="line"><span class="number">5.</span>Django项目迁移数据库与admin后台配置</span><br><span class="line">Python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> proxy.models <span class="keyword">import</span> Proxy</span><br><span class="line">admin.site.register(Proxy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建超级用户:</span></span><br><span class="line">Python manage.py createsuperuser</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 路由:</span></span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> proxy.views <span class="keyword">import</span> index</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^admin/'</span>, admin.site.urls),</span><br><span class="line">    url(<span class="string">r'^index/'</span>, index),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视图函数:</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> proxy.models <span class="keyword">import</span> Proxy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(requests)</span>:</span></span><br><span class="line">    p = Proxy.objects.all()</span><br><span class="line">    <span class="keyword">return</span> render(requests, <span class="string">'index.html'</span>, &#123;<span class="string">"p"</span>:p&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前端代码:</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">    &lt;link href=<span class="string">"https://cdn.bootcss.com/twitter-bootstrap/4.3.1/css/bootstrap.min.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class="container"&gt;</span><br><span class="line">    &lt;div class="row" &gt;</span><br><span class="line">        &lt;div class="col-md-10 col-md-offset-2" style="margin:0 auto"&gt;</span><br><span class="line">            &lt;div class="panel panel-primary"&gt;</span><br><span class="line">                &lt;div class="panel-heading" style="margin-top:50px"&gt;</span><br><span class="line">                    &lt;h3 class="panel-title"&gt;代理IP一览表&lt;/h3&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div class="panel-body"&gt;</span><br><span class="line">                    &lt;table class="table table-striped"&gt;</span><br><span class="line">                        &lt;thead&gt;</span><br><span class="line">                        &lt;tr&gt;</span><br><span class="line">                            &lt;th&gt;IP&lt;/th&gt;</span><br><span class="line">                            &lt;th&gt;Port&lt;/th&gt;</span><br><span class="line">                            &lt;th&gt;Type&lt;/th&gt;</span><br><span class="line">                            &lt;th&gt;Protocal&lt;/th&gt;</span><br><span class="line">                            &lt;th&gt;Positon&lt;/th&gt;</span><br><span class="line">                        &lt;/tr&gt;</span><br><span class="line">                        &lt;/thead&gt;</span><br><span class="line">                        &lt;tbody&gt;</span><br><span class="line">                        &#123;% <span class="keyword">for</span> i <span class="keyword">in</span> p %&#125;</span><br><span class="line">                            &lt;tr&gt;</span><br><span class="line">                                &lt;th&gt;&#123;&#123; i.ip &#125;&#125;&lt;/th&gt;</span><br><span class="line">                                &lt;td&gt;&#123;&#123; i.port &#125;&#125;&lt;/td&gt;</span><br><span class="line">                                &lt;td&gt;&#123;&#123; i.typ &#125;&#125;&lt;/td&gt;</span><br><span class="line">                                &lt;td&gt;&#123;&#123; i.protocal &#125;&#125;&lt;/td&gt;</span><br><span class="line">                                &lt;td&gt;&#123;&#123; i.position &#125;&#125;&lt;/td&gt;</span><br><span class="line">                            &lt;/tr&gt;</span><br><span class="line">                        &#123;% endfor %&#125;</span><br><span class="line">                        &lt;/tbody&gt;</span><br><span class="line">                    &lt;/table&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spider</category>
      </categories>
      <tags>
        <tag>Spider</tag>
      </tags>
  </entry>
  <entry>
    <title>gitbook使用</title>
    <url>/uncategorized/gitbook%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="gitbook使用"><a href="#gitbook使用" class="headerlink" title="gitbook使用"></a>gitbook使用</h1><h6 id="1-gitbook说明"><a href="#1-gitbook说明" class="headerlink" title="1.gitbook说明"></a>1.gitbook说明</h6><p>Gitbook使用的Markdown语法在此基础上做了一些写作便利性的加强</p>
<p>Markdown是一种轻量级的【标记语言】，优点在于</p>
<p>1.专注你的文字而不是排版样式</p>
<p>2.轻松的导出HTML,PDF,和本身的.md文件</p>
<p>3.纯文本内容，兼容所有的文本编辑器和字处理软件</p>
<p>4.可读，直观。适合所有人的写作语言</p>
<a id="more"></a>

<h6 id="2-安装gitbook"><a href="#2-安装gitbook" class="headerlink" title="2.安装gitbook"></a>2.安装gitbook</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">npm install gitbook-cli -g   <span class="comment"># 安装gitbook</span></span><br><span class="line">gitbook  help                <span class="comment"># 查看gitbook帮助信息</span></span><br><span class="line">gitbook  -V                  <span class="comment"># 查看gitbook版本信息</span></span><br></pre></td></tr></table></figure>

<h6 id="3-创建一个gitbook项目"><a href="#3-创建一个gitbook项目" class="headerlink" title="3.创建一个gitbook项目"></a>3.创建一个gitbook项目</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C:\Users\tom&gt;  cd C:\aa\test-book            <span class="comment"># 进入要进行书写的空文件夹</span></span><br><span class="line">C:\aa\test-book&gt;  gitbook init               <span class="comment"># 初始化文件夹</span></span><br><span class="line">C:\aa\test-book&gt;  gitbook serve --port <span class="number">80</span>    <span class="comment"># 在本地80端口运行gitbook这个服务</span></span><br><span class="line"><span class="comment"># 注访问：http://localhost:80</span></span><br></pre></td></tr></table></figure>

<h6 id="4-设置gitbook样式"><a href="#4-设置gitbook样式" class="headerlink" title="4.设置gitbook样式"></a>4.设置gitbook样式</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book.json ：在C:\aa\test-book中创建插件配置</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"language"</span>: <span class="string">"zh-hans"</span>,</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        <span class="string">"livereload"</span>,</span><br><span class="line">        <span class="string">"highlight"</span>,</span><br><span class="line">        <span class="string">"search"</span>,</span><br><span class="line">        <span class="string">"lunr"</span>,</span><br><span class="line">        <span class="string">"-sharing"</span>,</span><br><span class="line">        <span class="string">"fontsettings"</span>,</span><br><span class="line">        <span class="string">"theme-default"</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">"styles"</span>: &#123;</span><br><span class="line">        <span class="string">"website"</span>: <span class="string">"styles/website.css"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">styles/website.css ：在C:\aa\test-book清除默认链接样式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.gitbook-link &#123;</span><br><span class="line">    display: none!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="5-设置目录层级结构"><a href="#5-设置目录层级结构" class="headerlink" title="5.设置目录层级结构"></a>5.设置目录层级结构</h6><p>1.<strong>说明</strong></p>
<p>　1. test-book 目录下的 SUMMARY.md 文件是 gitbook init 自动生成的 你也可以自己创建 这个markdown文件决定了你文档的目录结构</p>
<p> 　　　　　2. SUMMARY.md 就是一个markdown文件 当中内容遵循如下格式，星号 空格 方括号 圆括号【 <code>*** [前言](README.md)** 】</code></p>
<p>　　　　　　　　1）<strong>星号：</strong>的缩进代表所在条目的层级结构，四个空格为一个层级，相当于是一个链接 </p>
<p>　　　　　　　　2）<strong>方括号：</strong>中是链接的名字</p>
<p>　　　　　　　　3）<strong>圆括号：</strong>中是一个文件里面是实际内容</p>
<p>　　　　　　　　4）默认的 README.md 是你的说明文件 你可以将文档的说明内容 在此文件中编辑 对应一本书的前言 或者是序言</p>
<p><strong>2.使用举例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd /c/aa/test-book                         <span class="comment"># 在windows中使用git进入test-book文件夹，并使用linux环境</span></span><br><span class="line">mkdir -p chapter&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;                    <span class="comment"># 在test-book中创建文件夹：chapter1  chapter2  chapter3</span></span><br><span class="line">touch chapter&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;/chapter&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;.md     <span class="comment"># 在对应文件夹中创建章节文件：chapter1.md  chapter2.md  chapter3.md</span></span><br><span class="line">touch chapter&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;/section&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;.md     <span class="comment"># 在对应文件夹中创建文章文件：section1.md  section2.md  section3.md</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">创建后的目录结构如下</span><br><span class="line"></span><br><span class="line">C:\aa\test-book&gt;tree /F</span><br><span class="line">C:.</span><br><span class="line">│  book.json            <span class="comment"># 设置gitbook插件</span></span><br><span class="line">│  README.md            <span class="comment"># gitbook介绍</span></span><br><span class="line">│  SUMMARY.md           <span class="comment"># gitbook目录结构</span></span><br><span class="line">│</span><br><span class="line">├─styles</span><br><span class="line">│      website.css      <span class="comment"># 设置样式</span></span><br><span class="line">│</span><br><span class="line">├─chapter1              <span class="comment"># 第一章文件夹</span></span><br><span class="line">│      chapter1.md          <span class="comment"># 第一章文件</span></span><br><span class="line">│      section1.md</span><br><span class="line">│      section2.md</span><br><span class="line">│      section3.md</span><br><span class="line">│</span><br><span class="line">├─chapter2              <span class="comment"># 第二章文件夹</span></span><br><span class="line">│      chapter2.md          <span class="comment"># 第二章文件</span></span><br><span class="line">│      section1.md</span><br><span class="line">│      section2.md</span><br><span class="line">│      section3.md</span><br><span class="line">│</span><br><span class="line">├─chapter3              <span class="comment"># 第三章文件夹</span></span><br><span class="line">│      chapter3.md          <span class="comment"># 第三章文件</span></span><br><span class="line">│      section1.md</span><br><span class="line">│      section2.md</span><br><span class="line">│      section3.md</span><br></pre></td></tr></table></figure>

<p><strong>在test-book/summary.md 中加入目录结构</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Summary</span></span><br><span class="line"></span><br><span class="line">* [前言](README.md)</span><br><span class="line">* [第一章](chapter1/chapter1.md)</span><br><span class="line">    * [第<span class="number">1</span>节](chapter1/section1.md)</span><br><span class="line">    * [第<span class="number">2</span>节](chapter1/section2.md)</span><br><span class="line">    * [第<span class="number">3</span>节](chapter1/section3.md)</span><br><span class="line">* [第二章](chapter2/chapter2.md)</span><br><span class="line">    * [第<span class="number">1</span>节](chapter2/section1.md)</span><br><span class="line">    * [第<span class="number">2</span>节](chapter2/section2.md)</span><br><span class="line">    * [第<span class="number">3</span>节](chapter2/section3.md)</span><br><span class="line">* [第三章](chapter3/chapter3.md)</span><br><span class="line">    * [第<span class="number">1</span>节](chapter3/section1.md)</span><br><span class="line">    * [第<span class="number">2</span>节](chapter3/section2.md)</span><br><span class="line">    * [第<span class="number">3</span>节](chapter3/section3.md)</span><br><span class="line">* [总结](summary.md)</span><br><span class="line"></span><br><span class="line">summary.md</span><br></pre></td></tr></table></figure>

<p><strong>gitbook一些实用插件</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        <span class="string">"splitter"</span>,              <span class="comment"># splitter 侧边栏宽度可调节</span></span><br><span class="line">        <span class="string">"copy-code-button"</span>,      <span class="comment"># 快速复制按钮</span></span><br><span class="line">        <span class="string">"highlight"</span>,             <span class="comment"># 代码高亮</span></span><br><span class="line">        <span class="string">"accordion"</span>,             <span class="comment"># 折叠模块(页面内容可折叠)</span></span><br><span class="line">        <span class="string">"back-to-top-button"</span>,    <span class="comment"># 回到顶部按钮</span></span><br><span class="line">        </span><br><span class="line">        <span class="string">"search-pro"</span>,            <span class="comment"># search-pro支持中文搜索，在使用此插件之前，需要将默认的search和lunr 插件去掉</span></span><br><span class="line">        <span class="string">"-search"</span>,         </span><br><span class="line">        <span class="string">"-lunr"</span>,</span><br><span class="line">        </span><br><span class="line">        <span class="string">"chapter-fold"</span>,                   <span class="comment"># 左侧目录可折叠</span></span><br><span class="line">        <span class="string">"expandable-chapters"</span>,            <span class="comment"># 也是左侧目录折叠的插件，不同的是可以解决chapter-fold插件的bug</span></span><br><span class="line">        <span class="string">"-expandable-chapters-small"</span>,     <span class="comment"># 也是折叠菜单的，但是这个插件跟chapter-fold有一样的bug</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"fontsettings"</span>,</span><br><span class="line">        <span class="string">"livereload"</span>,            <span class="comment"># 为GitBook实时重新加载</span></span><br><span class="line">        <span class="string">"popup"</span>,                 <span class="comment"># 打开新的页面查看图片</span></span><br><span class="line">        </span><br><span class="line">        <span class="string">"-sharing"</span>,              <span class="comment"># 去掉左右分享功能</span></span><br><span class="line">        <span class="string">"theme-default"</span>,</span><br><span class="line">        <span class="string">"theme-comscore"</span>,        <span class="comment"># 主题插件，修改标题和表格颜色</span></span><br><span class="line">        <span class="string">"page-treeview"</span>          <span class="comment"># 在页面顶部显示目录</span></span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="string">"styles"</span>: &#123;</span><br><span class="line">        <span class="string">"website"</span>: <span class="string">"styles/website.css"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="把gitbook打包"><a href="#把gitbook打包" class="headerlink" title="把gitbook打包"></a>把gitbook打包</h6><p><strong>1.把gitbook打包</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C:\Users\tom&gt;  cd C:\aa\test-book     <span class="comment"># 进入gitbook文件目录</span></span><br><span class="line">C:\aa\test-book&gt;  gitbook build       <span class="comment"># 把文件编译成html格式</span></span><br></pre></td></tr></table></figure>

<p><strong>2、由于gitbook 3.x.x版本bug导致build后的文件无法自动跳转页面</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件位置：_book\gitbook\theme.js</span></span><br><span class="line"><span class="comment"># 由于代码是压缩后的，会没有空格，搜索的时候可以直接搜索： if(m)for(n.handler&amp;&amp;</span></span><br><span class="line"><span class="comment"># 将if(m)改成if(false)</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Django+Nginx+Gunicorn的生产环境部署</title>
    <url>/uncategorized/Django-Nginx-Gunicorn%E7%9A%84%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="Django-Gunicorn-Nginx的生产环境部署"><a href="#Django-Gunicorn-Nginx的生产环境部署" class="headerlink" title="Django+Gunicorn +Nginx的生产环境部署"></a>Django+Gunicorn +Nginx的生产环境部署</h2><h6 id="1-Gunicorn"><a href="#1-Gunicorn" class="headerlink" title="1.Gunicorn"></a>1.Gunicorn</h6><p>gunicorn是适用Python实现的WSGI服务器，直接提供了HTTP服务，并且在woker上提供了多种选择，gevent,eventlet这些都支持</p>
<p>在多worker最大化里用cpu的同时，还可以适用协程来提供并发支撑，对于网络IO密集的服务比较有利。</p>
<p>说明：</p>
<p>同时Gunicorn也很容易就改造成一个TCP的服务，比如doge重写worker类</p>
<p>在针对长连接的服务时，最好开启reuse_port，避免worker进程负载不均<a id="more"></a></p>
<h6 id="2-uWSGI与Gunicorn"><a href="#2-uWSGI与Gunicorn" class="headerlink" title="2.uWSGI与Gunicorn"></a>2.uWSGI与Gunicorn</h6><p>1.不同于Gunicorn,uWsgi是使用C写的，它的socket fd创建，worker进程的启动都是使用c语言系统接口来实现的</p>
<p>2.在worker进程处理循环中，解析了http请求后，使用python的c接口生成environ对象</p>
<p>3.在把这个对象作为参数塞到暴露出来的WSGI application函数中调用</p>
<p>4.而这一切都是在C程序中运行，只是在处理请求的时候交给Python虚拟机调用application.</p>
<p>5.完全使用c语言实现的好处是性能会好一些</p>
<h6 id="3-Django-Gunicorn-Nginx的生产环境部署"><a href="#3-Django-Gunicorn-Nginx的生产环境部署" class="headerlink" title="3.Django+Gunicorn+Nginx的生产环境部署"></a>3.Django+Gunicorn+Nginx的生产环境部署</h6><p>1.在centos7中安装python3环境</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、yum更新yum源</span></span><br><span class="line">yum update</span><br><span class="line"><span class="comment"># 2、安装Python 3.7所需的依赖否则安装后没有pip3包</span></span><br><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make</span><br><span class="line"><span class="comment"># 3、在官网下载所需版本，这里用的是3.7.0版本</span></span><br><span class="line">wget https://www.python.org/ftp/<span class="number">3.7</span><span class="number">.0</span>/Python<span class="number">-3.7</span><span class="number">.0</span>.tgz</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、yum更新yum源</span></span><br><span class="line">yum update</span><br><span class="line"><span class="comment"># 2、安装Python 3.7所需的依赖否则安装后没有pip3包</span></span><br><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make</span><br><span class="line"><span class="comment"># 3、在官网下载所需版本，这里用的是3.7.0版本</span></span><br><span class="line">wget https://www.python.org/ftp/<span class="number">3.7</span><span class="number">.0</span>/Python<span class="number">-3.7</span><span class="number">.0</span>.tgz</span><br><span class="line">　　<span class="number">2</span>、安装Python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、解压</span></span><br><span class="line">tar -xvf Python<span class="number">-3.7</span><span class="number">.0</span>.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、配置编译</span></span><br><span class="line">cd Python<span class="number">-3.7</span><span class="number">.0</span></span><br><span class="line">./configure --prefix=/usr/local/python3  <span class="comment"># 配置编译的的路径（这里--prefix是指定编译安装的文件夹）</span></span><br><span class="line">./configure --enable-optimizations  <span class="comment"># 执行该代码后，会编译安装到 /usr/local/bin/ 下，且不用添加软连接或环境变量</span></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">ln -s /usr/local/python3/bin/python3 /usr/bin/python3  <span class="comment"># 添加软连接</span></span><br><span class="line">ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、将/usr/local/python3/bin加入PATH</span></span><br><span class="line">[root@linux-node1 testProj]<span class="comment"># vim /etc/profile</span></span><br><span class="line"><span class="comment">#然后在文件末尾添加</span></span><br><span class="line">export PATH=$PATH:/usr/local/python3/bin</span><br><span class="line"></span><br><span class="line">[root@linux-node1 testProj]<span class="comment"># source /etc/profile # 修改完后，还需要让这个环境变量在配置信息中生效，执行命令</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、安装Python</span><br></pre></td></tr></table></figure>

<h6 id="2-初始化一个django项目"><a href="#2-初始化一个django项目" class="headerlink" title="2.初始化一个django项目"></a>2.初始化一个django项目</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@linux-node1 /]<span class="comment"># pip3 install django==2.0.4</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># mkdir /code/</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># cd /code/</span></span><br><span class="line">[root@linux-node1 testProj]<span class="comment"># django-admin startproject mmcsite</span></span><br><span class="line">[root@linux-node1 testProj]<span class="comment"># cd /code/mmcsite</span></span><br><span class="line">[root@linux-node1 testProj]<span class="comment"># python3 manage.py runserver 0.0.0.0:8000</span></span><br><span class="line"><span class="comment"># 页面中访问：http://192.168.56.11:8000/</span></span><br><span class="line"></span><br><span class="line">初始化一个django项目</span><br></pre></td></tr></table></figure>

<h6 id="3-安装Gunicorn并使用uWsgi启动这个服务"><a href="#3-安装Gunicorn并使用uWsgi启动这个服务" class="headerlink" title="3.安装Gunicorn并使用uWsgi启动这个服务"></a>3.安装Gunicorn并使用uWsgi启动这个服务</h6><p>安装Gunciron</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@linux-node1 mmcsite]<span class="comment">#  pip3 install gunicorn                          # 安装Gunicorn</span></span><br><span class="line">[root@linux-node1 mmcsite]<span class="comment"># gunicorn mmcsite.wsgi -b 0.0.0.0:8000 -w 3      # 命令行下测试</span></span><br><span class="line">-c    <span class="comment"># 指定一个配置文件(py文件)</span></span><br><span class="line">-b    <span class="comment"># 与指定的socket进行绑定</span></span><br><span class="line">-D    <span class="comment"># 以守护进程形式来运行Gunicorn进程，其实就是将这个服务放到后台去运行</span></span><br><span class="line">-w    <span class="comment"># 工作的进程数量</span></span><br><span class="line">-k    <span class="comment"># 工作进程类型，sync（默认）, eventlet, gevent, or tornado, gthread, gaiohttp.</span></span><br><span class="line"><span class="comment"># 参考：http://docs.gunicorn.org/en/latest/settings.html</span></span><br><span class="line">[root@linux-node1 mmcsite]<span class="comment">#  ps -ef|grep gunicorn                          # 查看Gunicorn进程已经运行</span></span><br></pre></td></tr></table></figure>

<p>Gunicron配置文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@linux-node1 mmcsite]<span class="comment">#  vim /code/mmcsite/gunicorn_config.py  # Gunicorn配置文档</span></span><br><span class="line"><span class="comment"># gunicorn_config.py</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"><span class="keyword">from</span> logging.handlers <span class="keyword">import</span> WatchedFileHandler</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line">bind = <span class="string">'0.0.0.0:8000'</span>           <span class="comment">#绑定ip和端口号</span></span><br><span class="line">backlog = <span class="number">512</span>                   <span class="comment">#监听队列</span></span><br><span class="line">chdir = <span class="string">'/code/mmcsite'</span>         <span class="comment">#gunicorn要切换到的目的工作目录</span></span><br><span class="line">timeout = <span class="number">30</span>                    <span class="comment">#超时</span></span><br><span class="line">worker_class = <span class="string">'gevent'</span>         <span class="comment">#使用gevent模式，还可以使用sync 模式，默认的是sync模式</span></span><br><span class="line"></span><br><span class="line">workers = multiprocessing.cpu_count() * <span class="number">2</span> + <span class="number">1</span>     <span class="comment">#进程数</span></span><br><span class="line">threads = <span class="number">2</span>                                       <span class="comment">#指定每个进程开启的线程数</span></span><br><span class="line">loglevel = <span class="string">'info'</span>                                 <span class="comment">#日志级别，这个日志级别指的是错误日志的级别，而访问日志的级别无法设置</span></span><br><span class="line">access_log_format = <span class="string">'%(t)s %(p)s %(h)s "%(r)s" %(s)s %(L)s %(b)s %(f)s" "%(a)s"'</span> </span><br><span class="line">accesslog = <span class="string">"/code/mmcsite/gunicorn_access.log"</span>      <span class="comment">#访问日志文件</span></span><br><span class="line">errorlog = <span class="string">"/code/mmcsite/gunicorn_error.log"</span>        <span class="comment">#错误日志文件</span></span><br><span class="line"></span><br><span class="line">/mmc/site/gunicorn_config.py Gunicorn配置文件</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@linux-node1 mmcsite]<span class="comment">#  gunicorn mmcsite.wsgi -c gunicorn_config.py -D   # 在后台使用Gunicorn运行项目</span></span><br><span class="line">[root@linux-node1 mmcsite]<span class="comment">#  ps -ef|grep gunicorn                             # 查看Gunicorn进程已经运行</span></span><br></pre></td></tr></table></figure>

<h6 id="4-安装配置nginx"><a href="#4-安装配置nginx" class="headerlink" title="4.安装配置nginx"></a>4.安装配置nginx</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''1. 配置nginx YUM源'''</span></span><br><span class="line">[root@linux-node1 /] vim /etc/yum.repos.d/nginx.repo</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<p>[nginx]<br>name=nginx repo</p>
<h1 id="下面这行centos根据你自己的操作系统修改比如：OS-rehel"><a href="#下面这行centos根据你自己的操作系统修改比如：OS-rehel" class="headerlink" title="下面这行centos根据你自己的操作系统修改比如：OS/rehel"></a>下面这行centos根据你自己的操作系统修改比如：OS/rehel</h1><h1 id="6是你Linux系统的版本，可以通过URL查看路径是否正确"><a href="#6是你Linux系统的版本，可以通过URL查看路径是否正确" class="headerlink" title="6是你Linux系统的版本，可以通过URL查看路径是否正确"></a>6是你Linux系统的版本，可以通过URL查看路径是否正确</h1><p>baseurl=<a href="http://nginx.org/packages/centos/7/$basearch/" target="_blank" rel="noopener">http://nginx.org/packages/centos/7/$basearch/</a><br>gpgcheck=0<br>enabled=1<br>​```<br>‘’’2. 安装nginx’’’<br>[root@linux-node1 /] yum -y install nginx</p>
<p>安装nginx</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###### <span class="number">5.</span>配置nginx代理Gunicorn</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">[root@linux-node1 mmcsite]# vim /etc/nginx/conf.d/dj_gunicorn.conf     # 配置nginx代理Gunicorn</span><br><span class="line">server &#123;</span><br><span class="line">        listen <span class="number">8005</span>; </span><br><span class="line">        root /www/demo;</span><br><span class="line">        server_name <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_set_header x-<span class="built_in">Real</span>-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header Host $http_host;</span><br><span class="line">            proxy_pass http:<span class="comment">//localhost:8000/; # gunicorn绑定的端口号</span></span><br><span class="line">        &#125;</span><br><span class="line">        # 配置static的静态文件：</span><br><span class="line">        location ~ ^\/static\/.*$ &#123;</span><br><span class="line">            root /www/demo;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@linux-node1 mmcsite]#  gunicorn mmcsite.wsgi -c gunicorn_config.py -D   # 在后台使用Gunicorn运行项目</span><br><span class="line">[root@linux-node1 mmcsite]#  ps -ef|grep gunicorn                             # 查看Gunicorn进程已经运行</span><br><span class="line">http:<span class="comment">//192.168.56.11:8005/</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>websocket实时通信</title>
    <url>/uncategorized/websocket%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="添加基于Websocket的实时通信，主动推送，聊天室及客服系统"><a href="#添加基于Websocket的实时通信，主动推送，聊天室及客服系统" class="headerlink" title="添加基于Websocket的实时通信，主动推送，聊天室及客服系统"></a>添加基于Websocket的实时通信，主动推送，聊天室及客服系统</h3><h5 id="Websocket是个啥？"><a href="#Websocket是个啥？" class="headerlink" title="Websocket是个啥？"></a>Websocket是个啥？</h5><p>Websocket是一种在单个TCP连接上进行全双工通信的协议</p>
<p>Websocket使得客户端和服务器之间的数据交换变得更加简单，允许服务器主动向客户端推送数据。在Websocket Apl中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<p>现在，很多网站为了实现推送技术，所用的技术都是<strong>轮询</strong>。轮询是在特定的时间间隔(如每一秒)，由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断地服务器发出请求，然后HTTP请求可能包含较长的头部，其中正真有效的数据有可能只是一小部分，显然这样会浪费很多的带宽等资源。 <a id="more"></a></p>
<p>而比较新的技术去做轮询的效果是<strong>Comet</strong>.。这种技术虽然可以双向通信，但依然需要反复发出请求。而且在Comet中，普遍采用的长连接，也会消耗服务器资源。</p>
<p>在这种情况下，HTML5定义了Websocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p>
<h5 id="轮询是几个意思？"><a href="#轮询是几个意思？" class="headerlink" title="轮询是几个意思？"></a>轮询是几个意思？</h5><p>轮询是最原始的实现实时web应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新地数据改动。明显的，这种方法会导致过多不必要地请求，浪费流量和服务器资源。总之就是一种Low到爆地原始作坊水平地技术。</p>
<h5 id="example"><a href="#example" class="headerlink" title="example"></a>example</h5><h6 id="通过基于dwebsocket库来将socket嵌入到Django服务中，使其服务兼具http协议和socket协议，能够达到实时前后端通信，后端主动推送等功能。"><a href="#通过基于dwebsocket库来将socket嵌入到Django服务中，使其服务兼具http协议和socket协议，能够达到实时前后端通信，后端主动推送等功能。" class="headerlink" title="通过基于dwebsocket库来将socket嵌入到Django服务中，使其服务兼具http协议和socket协议，能够达到实时前后端通信，后端主动推送等功能。"></a>通过基于dwebsocket库来将socket嵌入到Django服务中，使其服务兼具http协议和socket协议，能够达到实时前后端通信，后端主动推送等功能。</h6><p>安装dwebsocket库</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple dwebsocket</span><br></pre></td></tr></table></figure>

<p>定义视图文件地逻辑views.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入websocket装饰器</span></span><br><span class="line"><span class="keyword">from</span> dwebsocket.decorators <span class="keyword">import</span> accept_websocket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#接收前端信息</span></span><br><span class="line"><span class="meta">@accept_websocket</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_socket</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.is_websocket():</span><br><span class="line">        <span class="keyword">for</span> message <span class="keyword">in</span> request.websocket:</span><br><span class="line">            c=str(message,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">            print(c)</span><br><span class="line">            request.websocket.send(message)</span><br><span class="line"></span><br><span class="line"><span class="comment">#主动推送消息</span></span><br><span class="line"><span class="meta">@accept_websocket</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_websocket</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.is_websocket():</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>) <span class="comment">## 向前端发送时间</span></span><br><span class="line">            dit = &#123;</span><br><span class="line">                <span class="string">'time'</span>:time.strftime(<span class="string">'%Y.%m.%d %H:%M:%S'</span>,time.localtime(time.time()))</span><br><span class="line">            &#125;</span><br><span class="line">            request.websocket.send(json.dumps(dit))</span><br></pre></td></tr></table></figure>

<p>路由配置urls.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#websocket</span></span><br><span class="line">path(<span class="string">'socket_test'</span>,TemplateView.as_view(template_name=<span class="string">'md_admin/socket.html'</span>)),</span><br><span class="line">path(<span class="string">'websocket_test'</span>,TemplateView.as_view(template_name=<span class="string">'md_admin/socket_push.html'</span>)),</span><br><span class="line">path(<span class="string">'test_socket'</span>,test_socket),</span><br><span class="line">path(<span class="string">'test_websocket'</span>,test_websocket),</span><br></pre></td></tr></table></figure>



<p>定义前端发送消息地页面 socket.html</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;Chat Room&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input id=<span class="string">"chat-message-input"</span> type=<span class="string">"text"</span> size=<span class="string">"100"</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input id=<span class="string">"chat-message-submit"</span> type=<span class="string">"button"</span> value=<span class="string">"Send"</span> onclick=<span class="string">'sendmessage()'</span>/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   </span><br><span class="line">   //生成socket对象</span><br><span class="line">   var socket = new WebSocket(<span class="string">"ws:"</span> + window.location.host + <span class="string">"/md_admin/test_socket"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            socket.onopen = function () &#123;</span><br><span class="line">                console.log(<span class="string">'WebSocket open'</span>);//成功连接上Websocket</span><br><span class="line">            &#125;;</span><br><span class="line">            socket.onmessage = function (e) &#123;</span><br><span class="line">                console.log(<span class="string">'message: '</span> + e.data);//打印服务端返回的数据</span><br><span class="line">            &#125;;</span><br><span class="line">            socket.onclose=function(e)&#123;</span><br><span class="line">              console.log(e);</span><br><span class="line">              socket.close(); //关闭TCP连接</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (socket.readyState == WebSocket.OPEN)&#123;</span><br><span class="line">            socket.onopen();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            window.s = socket;</span><br><span class="line"></span><br><span class="line">function sendmessage()&#123;</span><br><span class="line"></span><br><span class="line">    window.s.send(document.getElementById(<span class="string">"chat-message-input"</span>).value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>然后再定义一个页面，测试后台地主动推送socket_push.html</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;Chat Room&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   </span><br><span class="line">   //生成socket对象</span><br><span class="line">   var socket = new WebSocket(<span class="string">"ws:"</span> + window.location.host + <span class="string">"/md_admin/test_websocket"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            socket.onopen = function () &#123;</span><br><span class="line">                console.log(<span class="string">'WebSocket open'</span>);//成功连接上Websocket</span><br><span class="line">            &#125;;</span><br><span class="line">            socket.onmessage = function (e) &#123;</span><br><span class="line">                console.log(<span class="string">'message: '</span> + e.data);//打印服务端返回的数据</span><br><span class="line">            &#125;;</span><br><span class="line">            socket.onclose=function(e)&#123;</span><br><span class="line">              console.log(e);</span><br><span class="line">              socket.close(); //关闭TCP连接</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (socket.readyState == WebSocket.OPEN)&#123;</span><br><span class="line">            socket.onopen();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<p>可以看到，前后端无论是前端发送消息，还是后端主动推送消息，全部基于websocket,实现了真正意义上地实时通信。</p>
]]></content>
  </entry>
  <entry>
    <title>利用Docker搭建分布式文件系统FastDfs</title>
    <url>/Linux/%E5%88%A9%E7%94%A8Docker%E6%90%AD%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FFastDfs/</url>
    <content><![CDATA[<h1 id="利用Docker搭建分布式文件系统FastDfs"><a href="#利用Docker搭建分布式文件系统FastDfs" class="headerlink" title="利用Docker搭建分布式文件系统FastDfs"></a>利用Docker搭建分布式文件系统FastDfs</h1><p>​        对于文件存储来说，一般情况下简单的处理就是在Django配置文件中配置存储目录，按照规则对文件进行上传或者下载。</p>
<p>​        实际上，当文件较少的时候，Django是可以应付的过来的。但当文件以海量形式出现的时候，Django就并不是那么好用了，于是FastDfs应用而生。</p>
<a id="more"></a>

<p>​        FastDfs是一个开源的分布式文件系统，它对文件进行管理，功能包括：文件存储，文件同步，文件访问(文件上传，文件下载)等，解决了大容量存储和负载均衡的问题。特别适合在以文件为载体的在线服务，如相册网站，视频网站等。可以说它就是为互联网而生，为大数据而生的。</p>
<p>​        FastDfs服务端有两个角色：跟踪器(tracker)和存储节点(storage)。跟踪器主要做调度工作，在访问上起负载均衡的作用。存储节点存储文件，完成文件管理的所有功能：存储，同步和提供存取接口，FastDfs同时对文件的meta data进行管理。跟踪器和存储节点都可以由多台服务器构成。跟踪器和存储节点中的服务器均可随时增加或下线而不会影响上线服务。其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。</p>
<h5 id="说人话，为什么要用FastDfs"><a href="#说人话，为什么要用FastDfs" class="headerlink" title="说人话，为什么要用FastDfs?"></a>说人话，为什么要用FastDfs?</h5><p>1.解决海量存储，同时存储容量扩展方便。</p>
<p>2.解决文件内容重复。如果用户上传的文件重复(文件指纹一样)，那么系统只存储一份数据，这项技术目前被广泛应用在网盘中。</p>
<p>3.结合Nginx提高网站读取图片的效率。</p>
<p>​        如果我们从头搭建fastdfs服务器那么就太Low了，网上有大把的Docker镜像供你选择，所以有到了利用Docker优越性的时候了，首先下载fastdfs镜像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker search fastdfs</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker pull delron/fastdfs</span><br></pre></td></tr></table></figure>

<p>你会发现区区四百多兆就承载了Nginx和FastDfs服务</p>
<p>然后使用Docker镜像构建tracker容器(跟踪服务器，起到调度的作用)，这里tracker服务将会自动映射到宿主机上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">docker run -d --network=host --name tracker -v /var/fdfs/tracker:/var/fdfs delron/fastdfs tracker</span><br></pre></td></tr></table></figure>

<p>使用docker镜像构建storage容器（存储服务器，提供容量和备份服务），这里storage容器需要依赖tracker服务，传入你的tracker服务的ip地址，端口默认是22122，ip地址也就是你宿主机的ip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --network=host --name storage -e TRACKER_SERVER=ip:22122 -v /var/fdfs/storage:/var/fdfs -e GROUP_NAME=group1 delron/fastdfs storage</span><br></pre></td></tr></table></figure>

<p>上面需要填写你的tracker服务的ip地址，端口默认是22122</p>
<p>此时两个服务都已启动，进行服务的配置。</p>
<p>进入storage容器，到storage的配置文件中配置http访问的端口，配置文件在/etc/fdfs目录下的storage.conf</p>
<p>端口默认是8888，也可以不进行更改。</p>
<p>这时，进入正在后台运行的storage容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it storage /bin/bash</span><br></pre></td></tr></table></figure>

<p>随便下载一张图片,这个不用担心，因为在容器中如果不提交仓库的话，该图片是不会保存的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://v3u.cn/v3u/Public/images/logo.png</span><br></pre></td></tr></table></figure>

<p>将该图片通过命令上传到分布式系统中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/bin/fdfs_upload_file /etc/fdfs/client.conf logo.png</span><br></pre></td></tr></table></figure>

<p>ip +端口 +返回网络地址</p>
<p>这时该图片已上传至文件系统，并在执行该语句后返回图片存储的网络地址</p>
<p>最后通过浏览器访问以下存储在Fastdfs的图片，这张图片是通过nginx代理的静态资源，默认nginx监听8888端口，所以需要加上端口号，如果是在阿里云上部署，则需要暴露外部端口8888</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql主从复制</title>
    <url>/uncategorized/Mysql%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h4><hr>
<h5 id="什么是主从复制？"><a href="#什么是主从复制？" class="headerlink" title="什么是主从复制？"></a>什么是主从复制？</h5><p>主从复制(也称AB复制)允许将来自一个Mysql数据库服务器(主服务器)的数据复制到一个或多个Mysql数据库服务器(从服务器)</p>
<p>主从复制至少需要两台服务器，或两个mysql服务，可以配置一主多从，多主多从</p>
<p>建立于某个业务数据库一样的数据库环境，即为主从复制</p>
<p>一般情况下，主库用以写，而从库用以读</p>
<h5 id="为什么要搭建主从复制？"><a href="#为什么要搭建主从复制？" class="headerlink" title="为什么要搭建主从复制？"></a>为什么要搭建主从复制？</h5><p>1.构建主从热备，当某天数据库宕机或数据丢失情况，可以有备份数据库继续工作</p>
<p>2.降低IO频次，多库之间可以合理分配读写压力，提高单个数据库服务的数据库访问压力</p>
<p>3.隔离读写，在某些锁表情况下，可以使数据库读操作继续进行</p>
<h5 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h5><p>利用数据库 bin-log二进制文件，该文件包含有数据库操作的所有SQL语句</p>
<p>复制该文件至其余数据库服务中并执行即可</p>
<h5 id="主从复制过程"><a href="#主从复制过程" class="headerlink" title="主从复制过程"></a>主从复制过程</h5><p>当主库具有新数据时，主库会被从库请求，建立线程进行连接，用以传输binlog日志</p>
<p>从库开启两个线程</p>
<p>​    A线程:也叫做IO线程，连接主库，并请求binlog中的更新记录至从库中，写入从库的relaylog文件中</p>
<p>​    B线程:也叫做SQL线程，读取relaylog文件中的更新操作并执行</p>
<p>如果，有多个从库同时存在，主库会为每个从库建立一个binlog输出线程</p>
<h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h4><p>索引是存储引擎用于快速找到记录的一种数据结构。</p>
<p>一个常见的例子就是书的目录，我们都已经养成了看目录的习惯，拿到一本书时，我们首先会去查看它的目录，并且当我们要查找某个内容时，我们会在目录中查找，然后找到该片段相应的页码，在根据相应的页码去书中查找，如果没有索引(目录)的话，我们就只能一页一页的去查找了。</p>
<p>在MySQL中,假设我们有一张如下记录的表:</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>xiaoming</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>xiaohong</td>
<td>15</td>
</tr>
<tr>
<td>3</td>
<td>xiaofang</td>
<td>18</td>
</tr>
</tbody></table>
<p>如果我们希望查找到年龄为15的人的名字,在没有索引的情况下我们只能遍历所有的数据去做逐一的对比,那么时间复杂度是O(n).</p>
<p>而如果我们在插入数据的过程中, 额外维护一个数组,将age字段有序的存储.得到如下数组.</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span>,<span class="number">15</span>,<span class="number">18</span>,<span class="number">20</span>,<span class="number">21</span>]</span><br><span class="line"> |  |  |  |  |</span><br><span class="line">[x1,x4,x2,x3,x5]</span><br></pre></td></tr></table></figure>

<p>下面的x是模拟数据再磁盘上的存储位置.这个时候如果我们需要查找15岁的人的名字.我们可以对盖数组进行二分查找.众所周知,二分查找的时间复杂度为O(logn).查找到之后再根据具体的位置去获取真正的数据.</p>
<p>PS:MySQL中的索引不是使用的数组,而是使用的B+树(后面讲),这里用数组举例只是因为比较好理解.</p>
<h4 id="索引能为我们带来什么？"><a href="#索引能为我们带来什么？" class="headerlink" title="索引能为我们带来什么？"></a>索引能为我们带来什么？</h4><p>如上面所说，索引能帮助我们快速的查找到数据，其次因为索引中的值是顺序储存，那么可以帮助我们进行orderby操作。而且索引中也是存储了真正的值的，因此有一些的查询直接可以在索引中完成。</p>
<p>总结下索引的优点:</p>
<p>1.减少查询需要扫描的数据量(加快了查询速度)</p>
<p>2.减少服务器的排序操作和创建临时表的操作(加快了groupby和orderby等操作)</p>
<p>3.将服务器的随机IO变为顺序IO(加快查询速度)。</p>
<p>索引有哪些缺点呢？</p>
<p>首先索引也是数据，也需要存储，因此会带来额外的存储空间占用。其次，在插入，更新和删除操作的同时，需要维护索引，因此会带来额外的事件开销。</p>
<p>索引占用磁盘或者内存空间。</p>
<p>减慢了插入更新操作的速度</p>
<p>实际上，在一定数据范围内(索引没有超级多的情况下)，建立索引带来的开销是远远小于它带来的好处，但是我们仍然要防止索引的滥用。</p>
<h4 id="都有哪些类型的索引？"><a href="#都有哪些类型的索引？" class="headerlink" title="都有哪些类型的索引？"></a>都有哪些类型的索引？</h4><p>对于Mysq来说，在服务器层并不实现索引，而不是交给存储引擎来实现的，因此不同的存储引擎实现的索引类型不同意义。INNODB作为当前使用最广泛的存储引擎，使用的是B+树索引，因此我们大部分事件提到的索引也都是指的它。</p>
<p>Mysql主要有以下几种索引：</p>
<p>B-树索引/B+树索引</p>
<p>哈希索引</p>
<p>空间数据索引</p>
<p>全文索引</p>
<h6 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h6><p>B-树是一颗多路平衡查找树，对于一颗M阶的B-树有以下的性质:</p>
<p>根节点至少有两个子女.<br>每个节点包含k-1个元素和k个孩子,其中m/2 &lt;= k &lt;= m.<br>每一个叶子节点都包含k-1个元素,其中m/2 &lt;= k &lt;= m.<br>所有的叶子节点位于同一层.<br>每个节点中的元素从小到大排列,那么k-1个元素正好是k个孩子包含的值域的划分.<br>这么说可能会有一些难理解,可以将B-树理解为一棵更加矮胖的二叉搜索树.</p>
<h6 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h6><p>B+树是B-树的进阶版本，在B-树的基础上有做了如下的限制:</p>
<p>1.每个中间节点不保存数据，只用来索引，也就意味着所有非叶子结点的值都被保存了一份在叶子节点中。</p>
<p>2.叶子节点之间根据自身的顺序进行了链接。</p>
]]></content>
  </entry>
  <entry>
    <title>vue拦截器</title>
    <url>/Vue/vue%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Vue-router的beforeEach"><a href="#Vue-router的beforeEach" class="headerlink" title="Vue:router的beforeEach"></a>Vue:router的beforeEach</h1><h6 id="在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。"><a href="#在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。" class="headerlink" title="在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。"></a>在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。</h6><h6 id="定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。"><a href="#定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。" class="headerlink" title="定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。"></a>定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。</h6><p>两种函数：</p>
<p>​            1.Vue.beforeEach(function(to,form,next){}) /<em>在跳转之前执行</em>/</p>
<p>​            2.Vue.afterEach(function(to,form))/<em>在跳转之后判断</em>/</p>
<h3 id="beforeEach函数有三个参数："><a href="#beforeEach函数有三个参数：" class="headerlink" title="beforeEach函数有三个参数："></a>beforeEach函数有三个参数：</h3><ul>
<li>to:router即将进入的路由对象</li>
<li>from:当前导航即将离开的路由</li>
<li>next:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航。<a id="more"></a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//我们可以在main.js中定义一个白名单</span><br><span class="line">var witelist=[<span class="string">'Detail'</span>,<span class="string">'Order'</span>]  //定义白名单 需要登陆后访问页面</span><br><span class="line">//  router.beforEach  访问路由前</span><br><span class="line">// to:Route :即将要进入的路由对象</span><br><span class="line">// <span class="keyword">from</span> :Route:  当前导航正要离开的路由</span><br><span class="line">// next : Funcation  进行管道中的下一个钩子</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">router.beforeEach((to,from,next)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">	//我们取出存取的token</span><br><span class="line">  let token = sessionStorage.getItem(<span class="string">'token'</span>);</span><br><span class="line">	//判断它是否存在并且白名单定义的路由存在</span><br><span class="line">  <span class="keyword">if</span>(token|| whitelist.indexOf(to.name) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    console.log(<span class="string">'下一页！'</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">'请登陆后访问详情页'</span>)</span><br><span class="line">   </span><br><span class="line">    router.push(&#123;name:<span class="string">'Login'</span>&#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>一万快的火腿</title>
    <url>/Django/%E4%B8%80%E4%B8%87%E5%BF%AB%E7%9A%84%E7%81%AB%E8%85%BF/</url>
    <content><![CDATA[<h1 id="订单支付页面-支付方式-结账，优惠劵"><a href="#订单支付页面-支付方式-结账，优惠劵" class="headerlink" title="订单支付页面  支付方式(结账，优惠劵)"></a>订单支付页面  支付方式(结账，优惠劵)</h1><p>前言：支付宝沙箱环境(Beta)是协助开发者进行接口功能开发及主要功能联调的辅助环境。沙箱环境模拟了开放平台部分产品的主要功能和主要逻辑。在开发者应用上线审核前，开发者可以根据自身需求，先在沙箱环境中了解、组合和调试各种开放接口，进行开发调通工作，从而帮助开发者在应用上线审核完成后，能更快速、更顺利的进行线上调试和验收工作。<br>一、开通支付宝沙箱环境<br>沙箱环境地址：<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=info" target="_blank" rel="noopener">https://openhome.alipay.com/platform/appDaily.htm?tab=info</a><br>访问上面url，支付宝扫码登录，实名认证，根据提示创建应用，生成相应的沙箱应用环境。生成并上传RSA2(SHA256)的应用公钥，详见生成RSA密钥； <a id="more"></a></p>
<h3 id="生成优惠码脚本"><a href="#生成优惠码脚本" class="headerlink" title="生成优惠码脚本"></a>生成优惠码脚本</h3><h6 id="生成一个随机的串，用户输入到输入框中，使用优惠卷，价格打折！与库里对比，打折"><a href="#生成一个随机的串，用户输入到输入框中，使用优惠卷，价格打折！与库里对比，打折" class="headerlink" title="生成一个随机的串，用户输入到输入框中，使用优惠卷，价格打折！与库里对比，打折"></a>生成一个随机的串，用户输入到输入框中，使用优惠卷，价格打折！与库里对比，打折</h6><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">code = string.ascii_letters + string.digits</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> Code():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.<span class="keyword">join</span>(random.sample(code, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(Code())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> Mycode(<span class="keyword">group</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'-'</span>.<span class="keyword">join</span>(Code() <span class="keyword">for</span> i in range(<span class="keyword">group</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mycode = Mycode(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span>(Mycode)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> pymsql</span><br><span class="line"></span><br><span class="line"><span class="comment">#连接数据库</span></span><br><span class="line">conn=pymysql.connet(host=<span class="string">''</span>,user=<span class="string">''</span>,password=<span class="string">''</span>,db=<span class="string">''</span>,charset=<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string.ascii_letters  <span class="comment">#字符串</span></span><br><span class="line">string.digits <span class="comment">#数字 0-9</span></span><br><span class="line"><span class="comment">#定义随机串元素</span></span><br><span class="line">code=string.ascii_letters + string.digits      <span class="comment">#(字母+数字)</span></span><br><span class="line"><span class="comment">#随机码不能太短，定义获取四位的随机码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getcode</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">''</span>.join(random.sample(code,<span class="number">4</span>))  <span class="comment">#定义字符  定义字符长度</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">#定义4列4位码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key</span><span class="params">(group)</span>:</span></span><br><span class="line">	<span class="keyword">return</span>  <span class="string">'-'</span>.join([getcode() <span class="keyword">for</span> i <span class="keyword">in</span> range(group)])</span><br><span class="line">	</span><br><span class="line">print(key(<span class="number">4</span>))</span><br><span class="line">mycode=key(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建游标对象</span></span><br><span class="line">cursor=conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义sql语句</span></span><br><span class="line">sql=<span class="string">"insert into 表名 (code,discount) values ('%s',%s)"</span> % (mycode,<span class="string">'0.8'</span>)</span><br><span class="line">print(sql)  <span class="comment">#展示sql语言，看是否完整</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#入库操作 ，执行sql</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line"><span class="comment">#提交事务 </span></span><br><span class="line">conn.commit()</span><br><span class="line"><span class="comment">#关闭游标</span></span><br><span class="line">cursor.close()</span><br><span class="line"><span class="comment">#关闭数据库连接</span></span><br><span class="line">conn.close</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#优惠卷表</span><br><span class="line">class Codes(models.Model):</span><br><span class="line">	#主键</span><br><span class="line">	id=models.AutoField(primary_key=True)</span><br><span class="line">	#随机码</span><br><span class="line">	code=models.CharField(max_length=100)</span><br><span class="line">	#折扣  每种随机码对应相应的折扣</span><br><span class="line">	discount=models.FloatField()   #打折，浮点</span><br><span class="line">	#是否过期</span><br><span class="line">	status=models.IntegerFiels(default=1)  #默认为一，1为可以使用</span><br><span class="line">	</span><br><span class="line">	#表名</span><br><span class="line">	class Meta:</span><br><span class="line">		db_table=&apos;codes&apos;</span><br></pre></td></tr></table></figure>

<p>ok,你会发现我们的优惠卷已经入库了！</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#序列化器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodesSer</span><span class="params">(serializer.ModelSerializer)</span>:</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">		model=model.Code</span><br><span class="line">		fields=<span class="string">'__all__'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#优惠卷使用接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCode</span><span class="params">(APIbiew)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">		<span class="comment">#获取前端用户输入的优惠码</span></span><br><span class="line">		code=request.GET.get(<span class="string">'code'</span>)</span><br><span class="line">		<span class="comment">#与表中数据进行匹配获取单商品详情</span></span><br><span class="line">		codes=Codes.objects.filter(code=code).first()</span><br><span class="line">		<span class="comment">#序列化</span></span><br><span class="line">		codes_ser=CoderSer(codes)   <span class="comment">#一条数据，所以我们不用加many=True</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">#判断优惠劵使用状态</span></span><br><span class="line">		如果为一可以使用，当为<span class="number">0</span>时则优惠劵已被使用过！</span><br><span class="line">		<span class="keyword">if</span> 优惠劵未被使 用 ==<span class="number">0</span>:</span><br><span class="line">			</span><br><span class="line">			优惠劵被使用过，无效 Code码</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			codes.statiss=<span class="number">0</span> </span><br><span class="line">			codes.save()</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> HttpResponse(codes_ser.data)</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#优惠价:myprice</span><br><span class="line">#原价:price</span><br><span class="line"></span><br><span class="line">#前端输入Code码</span><br><span class="line">优惠劵:&lt;input type=&apos;text&apos; v-model=&apos;discount&apos;/&gt;  </span><br><span class="line">&lt;button @click=&apos;usecode&apos;&gt;使用优惠劵&lt;/button&gt;  #绑定事件我们把数据传到后代</span><br><span class="line">#实际上订单页面并不会只显示优惠劵的价格，还有商品原价。这样可以给用户视觉上的一个冲击，看优惠了多少！  优惠价 以及原价  当用户没有使用优惠卷的时候我们把优惠价隐藏</span><br><span class="line">&lt;span  v-show=&apos;myprice&apos;&gt;优惠价:&#123;&#123;myprice&#125;&#125;&lt;span&gt;</span><br><span class="line"></span><br><span class="line">#使用优惠劵</span><br><span class="line">usecode()&#123;</span><br><span class="line">	//调用接口，数据传给后台</span><br><span class="line">	//设置优惠价</span><br><span class="line">	var totalprice=this.totalprice;</span><br><span class="line">	this.myprice= totalprice * 优惠折扣   #优惠价=商品原价*后台返回的折扣</span><br><span class="line">	</span><br><span class="line">	//这有一个判断，当用户在此输入用过的优惠码时，显示当前优惠码已被使用</span><br><span class="line">	if 优惠码使用状态为0时&#123;</span><br><span class="line">		显示该优惠劵已被使用过</span><br><span class="line">		return    #返回，不做任何处理</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="所谓的重置按钮就是当你点击事件时把你当前输入的数据反空"><a href="#所谓的重置按钮就是当你点击事件时把你当前输入的数据反空" class="headerlink" title="所谓的重置按钮就是当你点击事件时把你当前输入的数据反空"></a>所谓的重置按钮就是当你点击事件时把你当前输入的数据反空</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button @click=&apos;rest&apos;&gt;重置&lt;button&gt;</span><br><span class="line"></span><br><span class="line">rest()&#123;</span><br><span class="line">	this.username ==&apos;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="订单"><a href="#订单" class="headerlink" title="订单"></a>订单</h3><p>订单id  价格  订单用户 订单号</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#订单表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orders</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">	<span class="comment">#主键</span></span><br><span class="line">	id=models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">	<span class="comment">#订单id 一般来说订单id由时间戳(订单涉及钱财，如果用户订单出错，技术人员通过订单号来判断这是那个具体时间的订单)一般来说，大点的公司会进行分表这样存储， 方便(那张表，那个月份)</span></span><br><span class="line">	orderid=models.CharField()</span><br><span class="line">	<span class="comment">#用户id</span></span><br><span class="line">	uid=models.IntegerField()</span><br><span class="line">	<span class="comment">#价格</span></span><br><span class="line">	price=models.IntegerField()</span><br><span class="line">	<span class="comment">#支付状态</span></span><br><span class="line">	status=models.IntegerField(default=<span class="number">0</span>)  <span class="comment">#0:待支付</span></span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">		db_table=<span class="string">'orders'</span></span><br></pre></td></tr></table></figure>



<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="comment">#订单入库,当调用这个方法时，即使用时间戳并生成顶单id</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orders</span><span class="params">(APIview)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">		<span class="comment">#接收参数   用户id  价格</span></span><br><span class="line">		<span class="comment">#后台验证签名，验签</span></span><br><span class="line">		sign=request.GET.get(<span class="string">'sign'</span>,<span class="string">''</span>)</span><br><span class="line">		md5=hashlib.md5()</span><br><span class="line">		<span class="comment">#定义加密对象</span></span><br><span class="line">		sign_str=<span class="string">''</span>  我们在前台生成的md5-js对象  <span class="comment">#要与前台加密对象一致</span></span><br><span class="line">		<span class="comment">#转码</span></span><br><span class="line">		sign_utf8=str(sign_str).encode(encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">		<span class="comment">#加密</span></span><br><span class="line">		md5.update(sign_utf<span class="number">-8</span>)</span><br><span class="line">		<span class="comment">#生成密文</span></span><br><span class="line">		md5_server=md5.hexdigest()</span><br><span class="line">		print(md5_server)</span><br><span class="line">		<span class="comment">#然后我们比对在前端加密和后端的md5加密，如果相同下一步，否则信息已被纂改</span></span><br><span class="line">		<span class="comment">#比对签名</span></span><br><span class="line">		<span class="keyword">if</span> 前端加密 ！= 后台加密:</span><br><span class="line">			订单信息被纂改</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			数据一致，进行订单入库操作</span><br><span class="line">		<span class="comment">#订单号是我们自己生成的</span></span><br><span class="line">		<span class="comment">#根据时间戳生成订单号</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">#进行入库逻辑</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">订单号的用处:</span><br><span class="line">	1.方便我们好查</span><br><span class="line">	2.防止订单号重复(使用时间戳)</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">#定义订单号</span><br><span class="line">def get_order_code():</span><br><span class="line">	#注意 Y：year m:month  d:day  H:小时   M：分钟 S：秒</span><br><span class="line">	order_no=time.strftime(&apos;%Y%m%d%H%M%S&apos;,time.localtime(time.time()))</span><br><span class="line">	</span><br><span class="line">	return order_no</span><br></pre></td></tr></table></figure>



<h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h3><p>初始化订单数据，展示我的订单详情页面、也就是说当我们在购物车中点击去支付的时候展示当前订单信息</p>
<h5 id="前端MD5加密——js-md5"><a href="#前端MD5加密——js-md5" class="headerlink" title="前端MD5加密——js-md5"></a>前端MD5加密——js-md5</h5><h6 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h6><p>是通过前台js加密的方式对密码等私密信息进行加密的工具</p>
<h6 id="2-js加密的好处"><a href="#2-js加密的好处" class="headerlink" title="2.js加密的好处"></a>2.js加密的好处</h6><p>（1）用js对私密信息加密可避免在网络中传输明文信息,被人截取数据包而造成数据泄露。<br>（2）避免缓存中自动缓存密码。比如在使用谷歌浏览器登陆时,输入的用户名和密码会自动缓存,下次登陆时无需输入密码就可以实现登陆,这样就给别人留下漏洞,当别人用你电脑登陆或把input的type改为test 那么你的密码就泄露了.使用js加密时,缓存的加密后的密文,用密文做密码登陆是不成功的,即使泄露也是泄露的密文,对密码不会造成威胁，缺点是每次登陆时都要手动输入密码，较麻烦。<br>（3）使用js加密,减少了服务器加密时的资源消耗,从理论上提高了服务器的性能。为了安全,很有必要再做服务器端的加密.无论从理论还是实际,两道门比一道门要安全些.至少给攻击者造成了一个障碍。</p>
<h6 id="3-安装使用"><a href="#3-安装使用" class="headerlink" title="3.安装使用"></a>3.安装使用</h6><p>（1）安装</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">npm install js-md5</span><br></pre></td></tr></table></figure>



<p>（2）main.js中引入</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">md5</span> <span class="keyword">from</span> 'js-<span class="built_in">md5</span>';</span><br><span class="line">Vue.prototype.$<span class="built_in">md5</span> = <span class="built_in">md5</span>;</span><br></pre></td></tr></table></figure>

<p>（3）使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$md5(<span class="string">"加密内容"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="支付签名"><a href="#支付签名" class="headerlink" title="支付签名"></a>支付签名</h5><h6 id="进行签名验证-价签-md5-js-不可逆，防止恶意纂改数据，进行入库操作"><a href="#进行签名验证-价签-md5-js-不可逆，防止恶意纂改数据，进行入库操作" class="headerlink" title="进行签名验证(价签) md5-js 不可逆，防止恶意纂改数据，进行入库操作"></a>进行签名验证(价签) md5-js 不可逆，防止恶意纂改数据，进行入库操作</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    //结账</span><br><span class="line">    checkout(totalprice)&#123;</span><br><span class="line">        //判断是否优惠劵</span><br><span class="line">        <span class="keyword">if</span>(this.myprice !=<span class="number">0</span>)&#123;</span><br><span class="line">            totalprice=this.myprice</span><br><span class="line">        &#125;</span><br><span class="line">        //进行签名验证(价签)</span><br><span class="line">        var sign =<span class="string">'mysign'</span> + <span class="string">'price='</span>+totalprice;</span><br><span class="line">        sign = md5(sign)</span><br><span class="line">        console.log(sign)</span><br><span class="line">        //使用箭头函数吧参数传过去</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="沙箱应用"><a href="#沙箱应用" class="headerlink" title="沙箱应用"></a>沙箱应用</h5><p>网页登陆支付宝—&gt;开发者中心—–&gt;沙箱环境—–&gt;沙箱应用—&gt;查看appid 应用公钥  私钥等配置信息。</p>
<p>我们用沙箱账号中的买家信息登陆 沙箱版钱包。</p>
<p> 支付宝加密RSA 所以我们也用RSA加密和支付宝的所匹配以防纂改信息</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> cryptography      <span class="comment">#这是一个库，加密搞的</span></span><br></pre></td></tr></table></figure>



<h5 id="支付宝支付接口：一万的火腿"><a href="#支付宝支付接口：一万的火腿" class="headerlink" title="支付宝支付接口：一万的火腿"></a>支付宝支付接口：一万的火腿</h5><h6 id="RSA签名验签工具-—-gt-非Java使用—-gt-生成public-key-和-private-key-俩个文件加头尾标识我们用工具生成的公钥与私钥。把商户应用公钥放到应用公钥，公钥上传成功后，会自动生成支付宝公钥，我们把支付宝公钥放到本地的public-key-公钥-，私钥不变。"><a href="#RSA签名验签工具-—-gt-非Java使用—-gt-生成public-key-和-private-key-俩个文件加头尾标识我们用工具生成的公钥与私钥。把商户应用公钥放到应用公钥，公钥上传成功后，会自动生成支付宝公钥，我们把支付宝公钥放到本地的public-key-公钥-，私钥不变。" class="headerlink" title="RSA签名验签工具 —&gt; 非Java使用—&gt;生成public_key   和 private_key. 俩个文件加头尾标识我们用工具生成的公钥与私钥。把商户应用公钥放到应用公钥，公钥上传成功后，会自动生成支付宝公钥，我们把支付宝公钥放到本地的public_key(公钥)，私钥不变。"></a>RSA签名验签工具 —&gt; 非Java使用—&gt;生成public_key   和 private_key. 俩个文件加头尾标识我们用工具生成的公钥与私钥。把商户应用公钥放到应用公钥，公钥上传成功后，会自动生成支付宝公钥，我们把支付宝公钥放到本地的public_key(公钥)，私钥不变。</h6><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">#公钥</span><br><span class="line"></span><br><span class="line">-----<span class="keyword">BEGIN</span> <span class="keyword">PUBLIC</span> KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApF51QND1p2rOvjx90zERrkDyRyEvdAzijGyjzch1fHgmrYVWMU9DboyWHKACLutwjSV5etTK90cN6rqs64KzRtWzgarjcUpzXpdxTINpn2KsUXHJQYHaz6tvodNdEIf4OB1PKzmNkMWMlBh0Z+KK5RQlU0yGedXbcGvh1dJqCdqhakppRa+DumIdC6IIgagT/Dz3X6kSw9mdxcn73JyJ6XGCSkifUJUtfX94oXg01L1jmtXPV5HJH/wzLVXVJVuRRmRNug6TssmRwowbsFIAiq9rX/mH1tIWbnc/MEPzJMWeKb<span class="comment">//JlNPPXbocAJaH17taDGOF2cyOgTtWomMUxgouQIDAQAB</span></span><br><span class="line">-----<span class="keyword">END</span> <span class="keyword">PUBLIC</span> KEY-----</span><br></pre></td></tr></table></figure>



<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">#私钥</span><br><span class="line">-----<span class="keyword">BEGIN</span> RSA <span class="keyword">PRIVATE</span> KEY-----</span><br><span class="line">MIIEowIBAAKCAQEAxckxbXy+we5P7xFoeEK7DmWPpC2vlpFHUhpS8ZA7omHAx4O0</span><br><span class="line">S6sW+ZijxLUcMKOhCNI78bQQwRkRwwXIEaVl9ob1j1ysCRDXxOmvvMntV6WFoWRe</span><br><span class="line">bJ2suGBwvmaeE+dgdSLdFdCvalVMHWhEJGOv/UbD6uuS3zL6fBPMpr2Tcm7gs/h5</span><br><span class="line">fPA8hBAekYRHP5yZk4+<span class="number">3</span>vh3LZxGVzWZU6AstOdCdXDEtYEx5bbKj035d6Yr9UEHy</span><br><span class="line">FWULy+Jp50a+HyDqNQcCAH3V0Ty+/wYk7H8/Oong4N4V+eZOgBcgYIeQaTkgsfMT</span><br><span class="line">UKOsGZgxJMCu7UT0yDJ0q9DakJqbGxZKdfXrAwIDAQABAoIBAE/hq2HiARVIT+Zp</span><br><span class="line">bH0tzmjJIhOYFBPGxzxkv10q+Lrjqj2qdtYc2qGiQXp<span class="comment">//0uxuqdaabV8GUwz+NWA</span></span><br><span class="line">b0aZO64u4dyt/BmJQOwZyc2A7Kf6hRci93P81rZ81OxBe9TkHTQSCaL27vIOUziJ</span><br><span class="line">VQQxcvHjc9tcm6wj5cDZKk2pwXR0l+tGkThuwb/fwycREZ7YB8lA8gKQ519KgC3T</span><br><span class="line">eTkWepiinl7S00D/plAANnjj6xbn16mQG1/Vx4yXG1CC/xemfpMiOh4BN9urrvqe</span><br><span class="line">etueSKr7we5rBy9IAyxqeXfCTg2FlS7w19/+Y7ToZhWEXuHc4CiaMrI9tu9os51C</span><br><span class="line">TDmer3ECgYEA4/JMKjO1MzEJmhKKA1ye8Qxaw7feVh1pa8rTcY175MWbe5Dt7NFA</span><br><span class="line">EVK37BQUgm3S872UbdkvuVASpiPTvnH3HPClROendIGalOA87qvzSaGYgBOx0gHH</span><br><span class="line">bZNH8fFakd0gIw+s5sfQHdUbFlE1JS79scc8tJVrgAjfrZb2N7zDLrkCgYEA3iCn</span><br><span class="line">cKdEyKJKKT7I0R0SntWZN5ODcOoLNRS7HLiF54/T6/n3JRfHMWpUnI9BHtG9VP0n</span><br><span class="line"><span class="number">2</span>rhS2J3jZi8SokLOxQpEOlfa3ARTDbE2AREJui6AdkLgts7SEkGVx/Dsd3RqSL+<span class="number">0</span></span><br><span class="line">btrW+<span class="number">38</span>qc1omueV4bDhJy2E4yOb/<span class="number">9</span>s+dGqU1KZsCgYBz81etC/p7XNFuj0mnJiEv</span><br><span class="line">qsIs1sYBdhqfG2BtXbQNDjvmIjX1BggaB8LJEvnP0v/AvsnXCuiM0l96JbVbJeu2</span><br><span class="line">y+<span class="number">6120</span>TCLf8tBdfY7Jzn8ox5cgs9MWx5n7a0KrqQgjQLwbiI+FE0K6gItSxcise/</span><br><span class="line">/AI0NeGmEl19ltIOTjXW+QKBgDbvPHnP5GL6P/<span class="number">0</span>TWfbdic1eZhYolUlHmJ34Eo53</span><br><span class="line"><span class="number">1</span>CYAnBiwKT8zMkA2W9acVy6YEIsEUOb2zwZjhemvmpwmiZyRfW4wbCAdsayhNwns</span><br><span class="line">fMte1MZqo8iSPcHmFnTsUI76a46yWp1P4fsw5/<span class="number">6</span>/PPScm7un8BgsYy7McmFH10LP</span><br><span class="line">uOYhAoGBAJQ8+XlmOxdrmrzWRPfA/FJoDu1OGr8alSKHdkHmKc/r7vmnUXmhDEBl</span><br><span class="line"><span class="number">4</span>IU64GqPCS0gFCoRz/vo0JwcDBvSdMnD0Gj9IgzTyYvzxLRL8G4cAH9EXbp1hjSC</span><br><span class="line">pJpenui4fA7HsFdNJDLRxkg2yONiXFnpK55ylFGyk4NHGqqXmAIU</span><br><span class="line">-----<span class="keyword">END</span> RSA <span class="keyword">PRIVATE</span> KEY-----</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1577353504404.png" alt="1577353504404"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> alipay</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> alipay <span class="keyword">import</span> AliPay</span><br><span class="line"><span class="keyword">from</span> web.settings <span class="keyword">import</span> BASE_DIR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">appid=<span class="string">'2016092600603658'</span></span><br><span class="line"><span class="keyword">def</span> Alpay():</span><br><span class="line">    <span class="keyword">ali</span> = AliPay(</span><br><span class="line">        appid=<span class="string">'2016092600603658'</span>,</span><br><span class="line">        app_notify_url=<span class="keyword">None</span>,</span><br><span class="line">        alipay_public_key_path=os.path.join(BASE_DIR,<span class="string">'public_key.txt'</span>),</span><br><span class="line">        app_private_key_path=os.path.join(BASE_DIR,<span class="string">'private_key.txt'</span>),</span><br><span class="line">        debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> = &#123;</span><br><span class="line">        <span class="string">'subject'</span>: <span class="string">'大火腿'</span>,</span><br><span class="line">        <span class="string">'out_trade_no'</span>: <span class="keyword">str</span>(random.randint(<span class="number">10000000000</span>,<span class="number">99999999999</span>)),</span><br><span class="line">        <span class="string">'total_amount'</span>: <span class="keyword">str</span>(<span class="number">9999999.99</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    order_str = ali.api_alipay_trade_page_pay(**<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">    request_url = <span class="string">'https://openapi.alipaydev.com/gateway.do?'</span> + order_str</span><br><span class="line"></span><br><span class="line">    print(request_url)</span><br><span class="line"></span><br><span class="line">Alpay()</span><br></pre></td></tr></table></figure>





<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render, redirect, HttpResponse</span><br><span class="line">from utils.pay import AliPay</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def ali():</span><br><span class="line">    # 沙箱环境地址：https:<span class="comment">//openhome.alipay.com/platform/appDaily.htm?tab=info</span></span><br><span class="line">    app_id = "2016092400583356"</span><br><span class="line">    # 支付宝收到用户的支付,会向商户（我）发两个请求,一个get请求,一个post请求 - 用于表示支付成功<span class="keyword">or</span>失败</span><br><span class="line">    # POST请求，用于最后的检测</span><br><span class="line">    notify_url = "http://42.56.89.12:80/page2/"</span><br><span class="line">    # GET请求，用于页面的跳转展示</span><br><span class="line">    return_url = "http://42.56.89.12:80/page2/"</span><br><span class="line">    # 私钥文件</span><br><span class="line">    merchant_private_key_path = "keys/app_private_2048.txt"</span><br><span class="line">    # 阿里公钥文件</span><br><span class="line">    alipay_public_key_path = "keys/alipay_public_2048.txt"</span><br><span class="line">    # 生成一个AliPay的对象</span><br><span class="line">    alipay = AliPay(</span><br><span class="line">        appid=app_id,</span><br><span class="line">        app_notify_url=notify_url,</span><br><span class="line">        return_url=return_url,</span><br><span class="line">        app_private_key_path=merchant_private_key_path,</span><br><span class="line">        alipay_public_key_path=alipay_public_key_path,  # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥</span><br><span class="line">        debug=True,  # 默认False,</span><br><span class="line">    )</span><br><span class="line">    return alipay</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def page1(request):</span><br><span class="line">    if request.method == "GET":</span><br><span class="line">        return render(request, <span class="string">'page1.html'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        money = float(request.POST.get(<span class="string">'money'</span>))</span><br><span class="line">        # 执行支付配置方法，生成一个对象</span><br><span class="line">        alipay = ali()</span><br><span class="line">        # 生成支付的url</span><br><span class="line">        # query_params:对象调用direct_pay</span><br><span class="line">        query_params = alipay.direct_pay(</span><br><span class="line">            subject="TEST商品",  # 商品简单描述</span><br><span class="line">            out_trade_no="x2" + str(time.time()),  # 商户订单号</span><br><span class="line">            total_amount=money,  # 交易金额(单位: 元 保留俩位小数)</span><br><span class="line">        )</span><br><span class="line">        # alipaydev,！！带着dev的都是沙箱环境！！</span><br><span class="line">        pay_url = "https://openapi.alipaydev.com/gateway.do?&#123;&#125;".format(query_params)</span><br><span class="line">        print(pay_url)</span><br><span class="line">        # 朝这个地址发get请求</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#定义批量删除逻辑</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group_Del</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment">#定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#接收参数</span></span><br><span class="line">        ids = request.POST.get(<span class="string">"ids"</span>)</span><br><span class="line">        <span class="comment">#使用eval方法来强转为list</span></span><br><span class="line">        ids = eval(<span class="string">"["</span>+ids+<span class="string">"]"</span>)</span><br><span class="line">        <span class="comment">#删除操作</span></span><br><span class="line">        Product.objects.filter(id__in=ids).delete()</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义批量操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoEditCart</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment">#定义post请求</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#获取参数</span></span><br><span class="line">        id = request.POST.get(<span class="string">"id"</span>)</span><br><span class="line">        count = request.POST.get(<span class="string">"count"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#读取库存</span></span><br><span class="line">        <span class="comment"># procount = Product.objects.filter(id=int(id)).values("count")</span></span><br><span class="line">        <span class="comment"># print(procount)</span></span><br><span class="line">        <span class="comment"># procount = procount[0]['count']</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#使用get方法</span></span><br><span class="line">        procount = Product.objects.get(id=int(id))</span><br><span class="line">        procount = procount.count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        print(procount)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#比对逻辑</span></span><br><span class="line">        <span class="keyword">if</span> int(count) &gt; procount:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">'库存不足'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#获取购物车</span></span><br><span class="line">        cartlist = request.session.get(<span class="string">"cartlist"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#清除购物车商品</span></span><br><span class="line">        cartlist_new = filter(<span class="keyword">lambda</span> n:n!=int(id),cartlist)</span><br><span class="line">        <span class="comment">#强转数据类型</span></span><br><span class="line">        cartlist_new = list(cartlist_new)</span><br><span class="line">        <span class="comment">#将购买数量添加到购物车</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(int(count)):</span><br><span class="line">            cartlist_new.append(int(id))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#将购物车重新赋值</span></span><br><span class="line">        request.session[<span class="string">'cartlist'</span>] = cartlist_new</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#原生sql定义用户详情页</span></span><br><span class="line"><span class="comment">#导入数据库连接方法</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment">#定义get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#获取用户名</span></span><br><span class="line">        username = request.COOKIES.get(<span class="string">'username'</span>)</span><br><span class="line">        <span class="comment">#定义游标</span></span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        <span class="comment">#execute执行sql语句</span></span><br><span class="line">        cursor.execute(<span class="string">" select c.name,c.id from user as a left join user2group as b on a.id = b.uid left join usergroup as c on b.gid = c.id where a.username =  '%s' "</span> % username )</span><br><span class="line">        <span class="comment">#调用fetchone fetchall</span></span><br><span class="line">        res = cursor.fetchall()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#查询普通用户的所有账号</span></span><br><span class="line">        cursor.execute(<span class="string">" select c.id,c.username from usergroup as a left join user2group as b on a.id = b.gid left join user as c on b.uid = c.id where a.name = '普通用户' "</span>)</span><br><span class="line">        <span class="comment">#调用fetchone fetchall</span></span><br><span class="line">        res_normal = cursor.fetchall()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">#将游标关闭</span></span><br><span class="line">        cursor.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'supermarket/userinfo.html'</span>,locals())</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>cenos7下安装Python3.7</title>
    <url>/Installs/cenos7%E4%B8%8B%E5%AE%89%E8%A3%85Python3-7/</url>
    <content><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>需要先sudo到root用户<a id="more"></a></p>
<h4 id="安装相关编译工具"><a href="#安装相关编译工具" class="headerlink" title="安装相关编译工具"></a>安装相关编译工具</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y groupinstall &quot;Development tools&quot;</span><br><span class="line">yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span><br><span class="line">yum install libffi-devel -y</span><br></pre></td></tr></table></figure>

<h4 id="下载并解压安装包"><a href="#下载并解压安装包" class="headerlink" title="下载并解压安装包"></a>下载并解压安装包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd 你自己的目录</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz</span><br><span class="line">tar -xvJf  Python-3.7.0.tar.xz</span><br></pre></td></tr></table></figure>

<h4 id="编译及安装"><a href="#编译及安装" class="headerlink" title="编译及安装"></a>编译及安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/python3 <span class="comment">#创建编译安装目录</span></span><br><span class="line"><span class="built_in">cd</span> Python-3.7.0</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h4 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/<span class="built_in">local</span>/bin/python3</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3 /usr/<span class="built_in">local</span>/bin/pip3</span><br></pre></td></tr></table></figure>

<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -V</span><br><span class="line">pip3 -V</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Installs</category>
      </categories>
      <tags>
        <tag>Installs</tag>
      </tags>
  </entry>
  <entry>
    <title>Firewalld未运行</title>
    <url>/Linux/Firewalld%E6%9C%AA%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<p>最近在阿里云服务器centos上安装了mysql数据库，默认是不开启远端访问功能，需要设置一下防火墙，在开放默认端口号 3306时提示FirewallD is not running，经过排查发现是防火墙就没打开造成的，出于安装考虑还是把防火墙开上吧，以下步骤仅供参考啦。<a id="more"></a></p>
<h2 id="工具-原料"><a href="#工具-原料" class="headerlink" title="工具/原料"></a>工具/原料</h2><ul>
<li>阿里云服务器centos</li>
</ul>
<h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h2><ol>
<li><p>执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示FirewallD is not running</p>
</li>
</ol>
<ol start="2">
<li><p>通过systemctl status firewalld查看firewalld状态，发现当前是dead状态，即防火墙未开启。</p>
</li>
</ol>
<ol start="3">
<li><p>通过systemctl start firewalld开启防火墙，没有任何提示即开启成功。</p>
</li>
</ol>
<ol start="4">
<li><p>再次通过systemctl status firewalld查看firewalld状态，显示running即已开启了。</p>
</li>
</ol>
<ol start="5">
<li><p>如果要关闭防火墙设置，可能通过systemctl stop firewalld这条指令来关闭该功能。</p>
</li>
</ol>
<ol start="6">
<li><p>再次执行执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示success，表示设置成功，这样就可以继续后面的设置了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis简介</title>
    <url>/Redis/Redis/</url>
    <content><![CDATA[<h2 id="Reids的特点"><a href="#Reids的特点" class="headerlink" title="Reids的特点"></a>Reids的特点</h2><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p>
<p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。<a id="more"></a></p>
<p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。</p>
<p>比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。</p>
<p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p>
<h3 id="使用redis有哪些好处？"><a href="#使用redis有哪些好处？" class="headerlink" title="使用redis有哪些好处？"></a>使用redis有哪些好处？</h3><p>1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p>
<p>2.支持丰富数据类型，支持string，list，set，sorted set，hash</p>
<p>3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p>
<p>4.丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p>
<h3 id="为什么redis需要把所有数据放到内存中"><a href="#为什么redis需要把所有数据放到内存中" class="headerlink" title="为什么redis需要把所有数据放到内存中?"></a>为什么redis需要把所有数据放到内存中?</h3><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p>
<p>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p>
<h3 id="Redis是单进程单线程的"><a href="#Redis是单进程单线程的" class="headerlink" title="Redis是单进程单线程的"></a>Redis是单进程单线程的</h3><p>redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销</p>
<h3 id="单线程的redis为什么这么快"><a href="#单线程的redis为什么这么快" class="headerlink" title="单线程的redis为什么这么快"></a>单线程的redis为什么这么快</h3><p>回答:主要是以下三点</p>
<p>(一)纯内存操作</p>
<p>(二)单线程操作，避免了频繁的上下文切换</p>
<p>(三)采用了非阻塞I/O多路复用机制</p>
<h3 id="redis持久化的几种方式"><a href="#redis持久化的几种方式" class="headerlink" title="redis持久化的几种方式"></a>redis持久化的几种方式</h3><p>1、快照（snapshots）</p>
<p>缺省情况情况下，Redis把数据快照存放在磁盘上的二进制文件中，文件名为dump.rdb。你可以配置Redis的持久化策略，例如数据集中每N秒钟有超过M次更新，就将数据写入磁盘；或者你可以手工调用命令SAVE或BGSAVE。</p>
<p>工作原理</p>
<p>Redis forks.</p>
<p>子进程开始将数据写到临时RDB文件中。</p>
<p>当子进程完成写RDB文件，用新文件替换老文件。</p>
<p>这种方式可以使Redis使用copy-on-write技术。</p>
<p>2、AOF</p>
<p>快照模式并不十分健壮，当系统停止，或者无意中Redis被kill掉，最后写入Redis的数据就会丢失。</p>
<p>这对某些应用也许不是大问题，但对于要求高可靠性的应用来说，Redis就不是一个合适的选择。Append-only文件模式是另一种选择。你可以在配置文件中打开AOF模式</p>
<p>3、虚拟内存方式</p>
<p>当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大.</p>
<p>当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value.</p>
<p>vm-max-threads这个参数,可以设置访问swap文件的线程数,设置最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证.</p>
<p>自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库。</p>
<h3 id="使用过Redis分布式锁么，"><a href="#使用过Redis分布式锁么，" class="headerlink" title="使用过Redis分布式锁么，"></a>使用过Redis分布式锁么，</h3><p>它是什么回事？先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p>
<h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h3 id="使用过Redis做异步队列么，你是怎么用的？"><a href="#使用过Redis做异步队列么，你是怎么用的？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？"></a>使用过Redis做异步队列么，你是怎么用的？</h3><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。 如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p>
<h3 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h3><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<h3 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h3><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p>
<h3 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h3><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<h3 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h3><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p>
<h3 id="什么是Redis的并发竞争问题"><a href="#什么是Redis的并发竞争问题" class="headerlink" title="什么是Redis的并发竞争问题"></a>什么是Redis的并发竞争问题</h3><p>Redis的并发竞争问题，主要是发生在并发写竞争。</p>
<p>考虑到redis没有像db中的sql语句，update val = val + 10 where …，无法使用这种方式进行对数据的更新。</p>
<p>假如有某个key = “price”， value值为10，现在想把value值进行+10操作。正常逻辑下，就是先把数据key为price的值读回来，加上10，再把值给设置回去。如果只有一个连接的情况下，这种方式没有问题，可以工作得很好，但如果有两个连接时，两个连接同时想对还price进行+10操作，就可能会出现问题了。</p>
<p>例如：两个连接同时对price进行写操作，同时加10，最终结果我们知道，应该为30才是正确。</p>
<p>考虑到一种情况：</p>
<p>T1时刻，连接1将price读出，目标设置的数据为10+10 = 20。</p>
<p>T2时刻，连接2也将数据读出，也是为10，目标设置为20。</p>
<p>T3时刻，连接1将price设置为20。</p>
<p>T4时刻，连接2也将price设置为20，则最终结果是一个错误值20。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用乐观锁的方式进行解决（成本较低，非阻塞，性能较高）</p>
<p>如何用乐观锁方式进行解决？</p>
<p>本质上是假设不会进行冲突，使用redis的命令watch进行构造条件。伪代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">watch price</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">get</span> price <span class="variable">$price</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$price</span> = <span class="variable">$price</span> + 10</span><br><span class="line"></span><br><span class="line">multi</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> price <span class="variable">$price</span></span><br><span class="line"></span><br><span class="line">exec</span><br></pre></td></tr></table></figure>

<p>watch这里表示监控该key值，后面的事务是有条件的执行，如果从watch的exec语句执行时，watch的key对应的value值被修改了，则事务不会执行。</p>
<p>方案2 这个是针对客户端来的，在代码里要对redis操作的时候，针对同一key的资源，就先进行加锁（java里的synchronized或lock）。</p>
<p>方案3 利用redis的setnx实现内置的锁。</p>
<h3 id="redis和memcached的区别（总结）"><a href="#redis和memcached的区别（总结）" class="headerlink" title="redis和memcached的区别（总结）"></a>redis和memcached的区别（总结）</h3><p>1、Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；</p>
<p>2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；</p>
<p>3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；</p>
<p>4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10；</p>
<p>5、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从；</p>
<p>6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；</p>
<p>7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；</p>
<p>8、Redis支持数据的备份，即master-slave模式的数据备份；</p>
<p>应用场景</p>
<p>redis：数据量较小的更性能操作和运算上</p>
<p>memcache：用于在动态系统中减少数据库负载，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）</p>
<p>MongoDB:主要解决海量数据的访问效率问题</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>八大查找</title>
    <url>/Python/%E5%85%AB%E5%A4%A7%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>算法简介 顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。 基本思路 从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。 优缺点 缺点：是当n 很大时，平均查找长度较大，效率低； 优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。 算法实现 <a id="more"></a></p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">def sequential_search(lis, <span class="meta">key</span>):</span><br><span class="line">  <span class="meta">length</span> = l<span class="meta">en(</span>lis)</span><br><span class="line">  for i <span class="meta">in</span><span class="meta"> range(</span><span class="meta">length</span>):</span><br><span class="line">    <span class="meta">if</span> lis[i] == <span class="meta">key</span>:</span><br><span class="line">      <span class="meta">return</span> i</span><br><span class="line">    <span class="meta">else</span>:</span><br><span class="line">      <span class="meta">return</span> False</span><br></pre></td></tr></table></figure>

<h1 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h1><p>二分查找（Binary Search），是一种在有序数组中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。 这种查找算法每一次比较都使查找范围缩小一半。</p>
<p>算法描述 给予一个包含 个带值元素的数组A 1、 令 L为0 ， R为 n-1 2、 如果L&gt;R，则搜索以失败告终 3、 令 m (中间值元素)为 ⌊(L+R)/2⌋ 4、 如果 AmT，令 R为 m - 1 并回到步骤二 复杂度分析 时间复杂度：折半搜索每次把搜索区域减少一半，时间复杂度为 O(logn) 空间复杂度：O(1)</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">def binary_search(lis, key):</span><br><span class="line">  low = <span class="number">0</span></span><br><span class="line">  high = <span class="built_in">len</span>(lis) - <span class="number">1</span></span><br><span class="line">  <span class="built_in">time</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> low &lt; high:</span><br><span class="line">    <span class="built_in">time</span> += <span class="number">1</span></span><br><span class="line">    <span class="keyword">mid</span> = int((low + high) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> key &lt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">    elif key &gt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 打印折半的次数</span></span><br><span class="line">      print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">      <span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">  print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">  <span class="literal">return</span> False</span><br></pre></td></tr></table></figure>

<h1 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h1><p>算法简介</p>
<p>插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。 时间复杂度o(logn)但对于表长较大而关键字分布比较均匀的查找表来说，效率较高。</p>
<p>算法思想 基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。 注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p>
<p>复杂度分析 时间复杂性：如果元素均匀分布，则O（log log n）），在最坏的情况下可能需要O（n）。 空间复杂度：O（1）。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">def binary_search(lis, key):</span><br><span class="line">  low = <span class="number">0</span></span><br><span class="line">  high = <span class="built_in">len</span>(lis) - <span class="number">1</span></span><br><span class="line">  <span class="built_in">time</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> low &lt; high:</span><br><span class="line">    <span class="built_in">time</span> += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 计算mid值是插值算法的核心代码</span></span><br><span class="line">    <span class="keyword">mid</span> = low + int((high - low) * (key - lis[low])/(lis[high] - lis[low]))</span><br><span class="line">    print(<span class="string">"mid=%s, low=%s, high=%s"</span> % (<span class="keyword">mid</span>, low, high))</span><br><span class="line">    <span class="keyword">if</span> key &lt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">    elif key &gt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 打印查找的次数</span></span><br><span class="line">      print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">      <span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">  print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">  <span class="literal">return</span> False</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  LIST = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">  <span class="built_in">result</span> = binary_search(LIST, <span class="number">444</span>)</span><br><span class="line">  print(<span class="built_in">result</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝与浅拷贝的区别</title>
    <url>/Python/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="深拷贝和浅拷贝之间的区别是什么？"><a href="#深拷贝和浅拷贝之间的区别是什么？" class="headerlink" title="深拷贝和浅拷贝之间的区别是什么？"></a>深拷贝和浅拷贝之间的区别是什么？</h1><p>对象的赋值就是简单的引用,a = [1,2,3], b=a, 在上述情况下,a和b是一样的,他们指向同一片内存,b不过是a的别名,是引用,我们可以使用b is a 去判断,返回True,表名他们地址相同内容也相同,也可以使用id()函数来查看.看两个列表地址是否相同.<a id="more"></a></p>
<p>深拷贝就是将一个对象拷贝到另一个对象中，这意味着如果你对一个对象的拷贝做出改变时，不会影响原对象。在Python中，我们使用函数deepcopy()执行深拷贝</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">copy</span></span><br><span class="line">b=<span class="built_in">copy</span>.deepcopy(a)</span><br></pre></td></tr></table></figure>

<p><img src="https://v3u.cn/book/img/deepcopy.jpg" alt="avatar"></p>
<p>而浅拷贝则是将一个对象的引用拷贝到另一个对象上，所以如果我们在拷贝中改动，会影响到原对象。我们使用函数function()执行浅拷贝</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">b=<span class="keyword">copy</span>.<span class="keyword">copy</span>(a)</span><br></pre></td></tr></table></figure>

<p><img src="https://v3u.cn/book/img/copy.jpg" alt="img"></p>
<p>切片操作是浅拷贝</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下yum Mongodb安装</title>
    <url>/Mongodb/Mongodb/</url>
    <content><![CDATA[<h1 id="CentOS下yum-Mongodb安装？"><a href="#CentOS下yum-Mongodb安装？" class="headerlink" title="CentOS下yum Mongodb安装？"></a>CentOS下yum Mongodb安装？</h1><a id="more"></a>
<p>MongoDB的安装<br>CentOS 中使用yum安装：</p>
<p>touch /etc/yum.repos.d/mongodb-org-4.2.repo<br>vim /etc/yum.repos.d/mongodb-org-4.2.repo<br>添加如下内容：<br>[mongodb-org-4.2]<br>name=MongoDB Repository<br>baseurl=<a href="https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/" target="_blank" rel="noopener">https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/</a><br>gpgcheck=1<br>enabled=1<br>gpgkey=<a href="https://www.mongodb.org/static/pgp/server-4.2.asc" target="_blank" rel="noopener">https://www.mongodb.org/static/pgp/server-4.2.asc</a><br>使用yum安装：<br>yum install -y mongodb-org<br>启动时指定配置文件：</p>
<p>mongod -f /etc/mongo/mongod.conf</p>
<p>参考：</p>
<p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</a></p>
<p>MongoDB如何导入数据？<br>wget <a href="http://labfile.oss.aliyuncs.com/courses/1196/monkey_source_docs_json.dat" target="_blank" rel="noopener">http://labfile.oss.aliyuncs.com/courses/1196/monkey_source_docs_json.dat</a><br>mongoimport -d monkey -c source_docs monkey_source_docs_json.dat<br>MongoDB如何导出数据？<br>Mongodb中的mongoexport工具可以把一个collection导出成JSON格式或CSV格式的文件。可以通过参数指定导出的数据项，也可以根据指定的条件导出数据。<br>MongoDB如何备份数据？<br>mongodump -h dbhost -d dbname -o dbdirectory<br>-h：MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017<br>-d：需要备份的数据库实例，例如：test<br>-o：备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。<br>MongoDB如何恢复数据<br>mongorestore -h <hostname>&lt;:port&gt; -d dbname <path><br>–host &lt;:port&gt;, -h &lt;:port&gt;：<br>MongoDB所在服务器地址，默认为： localhost:27017<br>–db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2<br>–drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！<br><path>：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。你不能同时指定 <path> 和 –dir 选项，–dir也可以设置备份目录。<br>–dir：指定备份的目录,你不能同时指定 <path> 和 –dir 选项。<br>结巴分词<br>参考资料：</p>
<p><a href="https://www.cnblogs.com/clsn/p/8244206.html#auto_id_9" target="_blank" rel="noopener">https://www.cnblogs.com/clsn/p/8244206.html#auto_id_9</a></p>
<p><a href="https://motor.readthedocs.io/en/stable/tutorial-asyncio.html" target="_blank" rel="noopener">https://motor.readthedocs.io/en/stable/tutorial-asyncio.html</a></p>
]]></content>
      <categories>
        <category>Mongodb</category>
      </categories>
      <tags>
        <tag>Mongdb</tag>
      </tags>
  </entry>
  <entry>
    <title>随机验证码</title>
    <url>/Python/%E9%9A%8F%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<h1 id="验证码的书写"><a href="#验证码的书写" class="headerlink" title="验证码的书写"></a>验证码的书写</h1><p>​    验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分<a href="https://baike.baidu.com/item/计算机" target="_blank" rel="noopener">计算机</a>和人类的<a href="https://baike.baidu.com/item/图灵测试" target="_blank" rel="noopener">图灵测试</a>）的缩写，是一种区分用户是计算机还是人的公共全自动<a href="https://baike.baidu.com/item/程序/71525" target="_blank" rel="noopener">程序</a>。可以防止：恶意破解密码、<a href="https://baike.baidu.com/item/刷票/6540942" target="_blank" rel="noopener">刷票</a>、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。<a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Django</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> make_password,check_password</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> web.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入图片库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入绘画库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageDraw</span><br><span class="line"><span class="comment">#字体库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont</span><br><span class="line"><span class="comment">#随机库</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#图片库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="comment">#文件流</span></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取随机6位字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_str</span><span class="params">()</span>:</span></span><br><span class="line">    a_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>)])  <span class="comment">#小写字母</span></span><br><span class="line">    A_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>)])   <span class="comment">#大写字母</span></span><br><span class="line">    num_=[str(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>)]   <span class="comment">#数字 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(a_+A_+num_,<span class="number">4</span>))  <span class="comment">#返回随机4位字符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义验证码类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mycode</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment">#定义随机取色方法,混淆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_random_color</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#三原色</span></span><br><span class="line">        R=random.randrange(<span class="number">255</span>)</span><br><span class="line">        G=random.randrange(<span class="number">255</span>)</span><br><span class="line">        B=random.randrange(<span class="number">255</span>)</span><br><span class="line">        <span class="keyword">return</span> (R,G,B)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#定义画布</span></span><br><span class="line">        image_size=(<span class="number">120</span>,<span class="number">60</span>)</span><br><span class="line">        <span class="comment">#定义图像 颜色种类  画布  背景颜色</span></span><br><span class="line">        image=Image.new(<span class="string">'RGB'</span>,image_size,<span class="string">'white'</span>)</span><br><span class="line">        <span class="comment">#定义画笔</span></span><br><span class="line">        draw=ImageDraw.Draw(image,<span class="string">'RGB'</span>)</span><br><span class="line">        <span class="comment">#随机字符串的组成</span></span><br><span class="line">        source=get_random_str()</span><br><span class="line">        <span class="comment">#定义一个容器，接收</span></span><br><span class="line">        code_str=<span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="comment">#取色</span></span><br><span class="line">            text_color=self.get_random_color()</span><br><span class="line">            <span class="comment">#获取一个字符串</span></span><br><span class="line">            tmp_num=random.randrange(len(source))</span><br><span class="line">            <span class="comment">#获取字符集</span></span><br><span class="line">            random_str=source[tmp_num]</span><br><span class="line">            <span class="comment">#将随机生成的字符串放入定义好的容器</span></span><br><span class="line">            code_str+=random_str</span><br><span class="line">            <span class="comment">#将文字输入绘图</span></span><br><span class="line">            <span class="comment">#宽高，字符，颜色</span></span><br><span class="line">            draw.text((<span class="number">10</span>+<span class="number">30</span>*i,<span class="number">20</span>),random_str,text_color)</span><br><span class="line">        <span class="comment">#建立io文件流</span></span><br><span class="line">        buf=io.BytesIO()</span><br><span class="line">        <span class="comment">#将图片内容保存在内存中</span></span><br><span class="line">        image.save(buf,<span class="string">'png'</span>)</span><br><span class="line">        <span class="comment">#将验证码放入session</span></span><br><span class="line">        request.session[<span class="string">'code'</span>]=code_str</span><br><span class="line">        <span class="comment">#可以存入redis中   建立连接   存key  取key</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(buf.getvalue(),<span class="string">'image/png'</span>)   <span class="comment">#从内存中获取数据</span></span><br></pre></td></tr></table></figure>





<h4 id="点击图片且刷新"><a href="#点击图片且刷新" class="headerlink" title="点击图片且刷新"></a>点击图片且刷新</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">&lt;image <span class="string">":src=src"</span> <span class="meta">@click</span>=<span class="string">'changecode'</span>&gt;</span><br><span class="line">src=<span class="string">'http://127.0.0.1:8000/api/mycode/'</span></span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">	<span class="comment">//点击刷新验证码</span></span><br><span class="line">	<span class="comment">//每次给它传一个随机字符,只要传了参数，就不会缓存，直接刷新</span></span><br><span class="line">	<span class="comment">//在js中随机生成字符</span></span><br><span class="line">	<span class="keyword">let</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">this</span>.src=<span class="keyword">this</span>.src+<span class="string">'?code='</span>+num;</span><br><span class="line">	</span><br><span class="line">	changecode()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>&#39;hexo快速搭建博客&#39;</title>
    <url>/Python/hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>使用Hexo建立一个轻量、简易、高逼格的博客</p>
<pre><code>在之前的一篇文章中，介绍了如何使用Hugo在三分钟之内建立一个简单的个人博客系统，它是基于go lang的，其实，市面上还有一款类似的静态页生成器，就是Hexo 读音/hækso/ ，它是基于node.js的，和Hugo一样，Hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。</code></pre><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">首先安装Hexo，在此之前，请确保电脑里已经安装好新版的<span class="keyword">node</span>.<span class="title">js</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>npm install -g hexo-cli</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">如果感觉安装速度比较慢，可以为<span class="built_in">npm</span>指定国内的源</span><br></pre></td></tr></table></figure>

<p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装完成后，创建博客项目</span><br></pre></td></tr></table></figure>

<p>hexo init blog</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">这样，就建立起了一个<span class="keyword">blog文件夹，进入到blog目录下 </span>cd <span class="keyword">blog，建立第一篇文章</span></span><br></pre></td></tr></table></figure>

<p>hexo new myfirst</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">然后运行hexo服务</span><br></pre></td></tr></table></figure>

<p>hexo server</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">就可以在本地访问你的博客网站了，默认端口号是<span class="number">4000</span></span><br><span class="line"></span><br><span class="line">那么如何将博客网站打包呢？直接运行打包命令，这样就能使用 Hexo 引擎将 Markdown 格式的文件解析成可以使用浏览器查看的 HTML 文件，HTML 文件存储在 blog/<span class="keyword">public</span> 目录下</span><br></pre></td></tr></table></figure>

<p>hexo generate</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">下面我们可以配置一下hexo主题，Hexo 提供了默认主题 landscape，主题的位置在 blog -&gt;themes 文件夹下。主题根据自己喜好可以在网上找到<span class="symbol">:https</span><span class="symbol">://hexo</span>.io/themes/</span><br><span class="line"></span><br><span class="line">主题都放在blog/themes文件夹下面，这我们下载一个新的主题</span><br></pre></td></tr></table></figure>

<p>mkdir themes/next<br>git clone –branch v5.1.2 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">然后在修改 <span class="regexp">/blog/</span>config.yml 文件，将其中的 theme 改成 <span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">如果没有自己的域名和服务器怎么办？没关系，可以申请 <span class="selector-tag">Github</span> 免费静态内容空间，在<span class="selector-tag">github</span><span class="selector-class">.com</span>注册一个账号，然后创建一个新的仓库</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">仓库名称一定要定义成 账号名<span class="selector-class">.github</span><span class="selector-class">.io</span>，这种形式，注意账号名一定要和你的<span class="selector-tag">github</span>当前登录的账号吻合</span><br></pre></td></tr></table></figure>

<p>​      </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">这样你的静态内容空间就已经创建好了，在浏览器输入你的 <span class="string">https:</span><span class="comment">//你的账号.github.io/ 就可以访问了。</span></span><br><span class="line"></span><br><span class="line">将之前打包好的<span class="keyword">public</span>中的文件push到刚刚创建好的github仓库中去</span><br><span class="line"></span><br><span class="line">访问静态空间网址<span class="string">https:</span><span class="comment">//仓库名.github.io</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>没有问题，搞定收工</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>send_verify</title>
    <url>/Python/send-verify/</url>
    <content><![CDATA[<h1 id="Django-vue-验证码发送"><a href="#Django-vue-验证码发送" class="headerlink" title="Django +vue 验证码发送"></a>Django +vue 验证码发送</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> web.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL   <span class="comment">#settings里的一些配置</span></span><br><span class="line"><span class="keyword">import</span> random </span><br><span class="line"></span><br><span class="line"><span class="comment">#settings配置具体如下:</span></span><br><span class="line">	EMAIL_USE_SSL = <span class="literal">True</span> <span class="comment"># Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议</span></span><br><span class="line">    EMAIL_HOST = <span class="string">'smtp.qq.com'</span>  <span class="comment"># 邮件服务器地址</span></span><br><span class="line">    EMAIL_PORT = <span class="number">465</span> <span class="comment"># 邮件服务器端口</span></span><br><span class="line"> </span><br><span class="line">    EMAIL_HOST_USER = <span class="string">'1315532054@qq.com'</span> <span class="comment"># 登陆邮件服务器的账号</span></span><br><span class="line">    EMAIL_HOST_PASSWORD = <span class="string">'ownkpkdkumubhdjg'</span>  <span class="comment"># 登陆邮件服务器的密码</span></span><br><span class="line">    DEFAULT_FROM_EMAIL = EMAIL_HOST_USER <span class="comment"># 邮件的发送者</span></span><br></pre></td></tr></table></figure>

<!-- < !--more--> 

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取随机6位字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_str</span><span class="params">()</span>:</span></span><br><span class="line">    a_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>)])</span><br><span class="line">    A_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>)])</span><br><span class="line">    num_=[str(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(a_+A_+num_,<span class="number">6</span>))</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#邮件发送</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">send_verify</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">           1. 先检查 对应邮件是否再memcache里已经存在了验证码</span></span><br><span class="line"><span class="string">           2. 发现没有存在,那么需要生成6位随机字符</span></span><br><span class="line"><span class="string">           3. 存储入到memcache里,并设置60s的过期时间</span></span><br><span class="line"><span class="string">               email: 6str :60s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           遇到了同步发送邮件的问题,应该怎么办</span></span><br><span class="line"><span class="string">       '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        email=request.data[<span class="string">'email'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># email=request.POST.get('email')</span></span><br><span class="line">        <span class="comment"># 1. 先检查 对应邮件是否再memcache里已经存在了验证码</span></span><br><span class="line">        token=men.get(email)</span><br><span class="line">        <span class="comment">#2.如果没有存在，那么需要生成随机字符</span></span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'code'</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="string">'message'</span>:<span class="string">'该邮箱已存在验证码'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#该邮箱没有，生成随机字符</span></span><br><span class="line">            token=get_random_str()  <span class="comment">#随机字符</span></span><br><span class="line">            subject=<span class="string">'实验楼。。。。。。。。。。。'</span></span><br><span class="line">            message=<span class="string">'你的验证码是:%s'</span>%token</span><br><span class="line">            men.set(email,token,<span class="number">100</span>)  <span class="comment">#存储到memcache</span></span><br><span class="line">            <span class="comment"># print(men.get(token))</span></span><br><span class="line">            send_mail(subject,message,DEFAULT_FROM_EMAIL,[email])</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'code'</span>:<span class="number">1</span>,</span><br><span class="line">                <span class="string">'message'</span>:<span class="string">'验证码已发送'</span></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>





<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">send_verify()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!this.email)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        let form_data=new FormData()</span><br><span class="line">        form_data.append(<span class="string">'email'</span>,this.email)</span><br><span class="line"></span><br><span class="line">        axios(&#123;</span><br><span class="line">            url:<span class="string">'http://127.0.0.1:8000/api/send_verify/'</span>,</span><br><span class="line">            method:<span class="string">'post'</span>,</span><br><span class="line">            data:form_data</span><br><span class="line">        &#125;).then(res=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.data.code==<span class="number">1</span>)&#123;</span><br><span class="line">                alert(res.data.message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="关于数据结构"><a href="#关于数据结构" class="headerlink" title="关于数据结构"></a>关于数据结构</h1><h5 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h5><p>简单地说，数据结构是以某种特定的布局方式存储数据的容器。这种“布局方式”决定了数据结构对于某些操作是高效的，而对于其他操作则是低效的。首先我们需要理解各种数据结构，才能在处理实际问题时选取最合适的数据结构。<a id="more"></a></p>
<h5 id="为什么我们需要数据结构？"><a href="#为什么我们需要数据结构？" class="headerlink" title="为什么我们需要数据结构？"></a>为什么我们需要数据结构？</h5><p>数据是计算机科学当中最关键的实体，而数据结构则可以将数据以某种组织形式存储，因此，数据结构的价值不言而喻。</p>
<p>无论你以何种方式解决何种问题，你都需要处理数据——无论是涉及员工薪水、股票价格、购物清单，还是只是简单的电话簿问题。</p>
<p>数据需要根据不同的场景，按照特定的格式进行存储。有很多数据结构能够满足以不同格式存储数据的需求。</p>
<h5 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h5><p>首先列出一些最常见的数据结构，我们将逐一说明：</p>
<p>数组 栈 队列 链表 树 字典树（这是一种高效的树形结构，但值得单独说明） 散列表（哈希表）</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均由数组演变而来。下图是一个包含元素（1，2，3和4）的简单数组，数组长度为4。</p>
<p>每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。</p>
<p>以下是数组的两种类型：</p>
<p>一维数组（如上所示） 多维数组（数组的数组）</p>
<p>数组的基本操作</p>
<p>Insert——在指定索引位置插入一个元素 Get——返回指定索引位置的元素 Delete——删除指定索引位置的元素 Size——得到数组所有元素的数量</p>
<p>面试中关于数组的常见问题</p>
<p>寻找数组中第二小的元素 找到数组中第一个不重复出现的整数 合并两个有序数组 重新排列数组中的正值和负值</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>著名的撤销操作几乎遍布任意一个应用。但你有没有思考过它是如何工作的呢？这个问题的解决思路是按照将最后的状态排列在先的顺序，在内存中存储历史工作状态（当然，它会受限于一定的数量）。这没办法用数组实现。但有了栈，这就变得非常方便了。</p>
<p>可以把栈想象成一列垂直堆放的书。为了拿到中间的书，你需要移除放置在这上面的所有书。这就是LIFO（后进先出）的工作原理。</p>
<p>下图是包含三个数据元素（1，2和3）的栈，其中顶部的3将被最先移除：</p>
<h5 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h5><p>Push——在顶部插入一个元素 Pop——返回并移除栈顶元素 isEmpty——如果栈为空，则返回true Top——返回顶部元素，但并不移除它</p>
<h5 id="面试中关于栈的常见问题"><a href="#面试中关于栈的常见问题" class="headerlink" title="面试中关于栈的常见问题"></a>面试中关于栈的常见问题</h5><p>使用栈计算后缀表达式 对栈的元素进行排序 判断表达式是否括号平衡</p>
<p>应用场景：逆序输出，语法检查，进制转换</p>
<p>在我们日常编程中，括号都是成对出现的，比如“()”“[]”“{}”“&lt;&gt;”这些成对出现的符号</p>
<p>那么具体处理的方法就是:凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p>
<p>将十进制的数转换为2-9的任意进制的数</p>
<p>我们都知道，通过求余法，可以将十进制数转换为其他进制，比如要转为八进制，将十进制数除以8，记录余数，然后继续将商除以8，一直到商等于0为止，最后将余数倒着写数来就可以了。</p>
<p>比如100的八进制，100首先除以8商12余4,4首先进栈，然后12除以8商1余4，第二个余数4进栈，接着1除以8，商0余1，第三个余数1进栈，最后将三个余数出栈，就得到了100的八进制数144,</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>与栈相似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO，即先进先出。</p>
<p>一个完美的队列现实例子：售票亭排队队伍。如果有新人加入，他需要到队尾去排队，而非队首——排在前面的人会先拿到票，然后离开队伍。</p>
<p>下图是包含四个元素（1，2，3和4）的队列，其中在顶部的1将被最先移除：</p>
<p>移除先入队的元素、插入新元素</p>
<h5 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h5><p>Enqueue()——在队列尾部插入元素 Dequeue()——移除队列头部的元素 isEmpty()——如果队列为空，则返回true Top()——返回队列的第一个元素</p>
<p>面试中关于队列的常见问题</p>
<p>使用队列表示栈 对队列的前k个元素倒序 使用队列生成从1到n的二进制数</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是另一个重要的线性数据结构，乍一看可能有点像数组，但在内存分配、内部结构以及数据插入和删除的基本操作方面均有所不同。</p>
<p>链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。 链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。</p>
<p>链表一般用于实现文件系统、哈希表和邻接表。</p>
<p>这是链表内部结构的展示：</p>
<p>链表包括以下类型：</p>
<p>单链表（单向） 双向链表（双向）</p>
<h5 id="链表的基本操作："><a href="#链表的基本操作：" class="headerlink" title="链表的基本操作："></a>链表的基本操作：</h5><p>InsertAtEnd - 在链表的末尾插入指定元素 InsertAtHead - 在链接列表的开头/头部插入指定元素 Delete - 从链接列表中删除指定元素 DeleteAtHead - 删除链接列表的第一个元素 Search - 从链表中返回指定元素 isEmpty - 如果链表为空，则返回true</p>
<p>面试中关于链表的常见问题</p>
<p>反转链表 检测链表中的循环 返回链表倒数第N个节点 删除链表中的重复项</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树形结构是一种层级式的数据结构，由顶点（节点）和连接它们的边组成。 树类似于图，但区分树和图的重要特征是树中不存在环路。</p>
<p>树形结构被广泛应用于人工智能和复杂算法，它可以提供解决问题的有效存储机制。</p>
<p>这是一个简单树的示意图，以及树数据结构中使用的基本术语：</p>
<p>Root - 根节点</p>
<p>Parent - 父节点</p>
<p>Child - 子节点</p>
<p>Leaf - 叶子节点</p>
<p>Sibling - 兄弟节点</p>
<p>以下是树形结构的主要类型：</p>
<p>N元树 平衡树 二叉树 二叉搜索树 AVL树 红黑树 2-3树</p>
<p>其中，二叉树和二叉搜索树是最常用的树。</p>
<h5 id="面试中关于树结构的常见问题："><a href="#面试中关于树结构的常见问题：" class="headerlink" title="面试中关于树结构的常见问题："></a>面试中关于树结构的常见问题：</h5><p>求二叉树的高度 在二叉搜索树中查找第k个最大值 查找与根节点距离k的节点 在二叉树中查找给定节点的祖先节点</p>
<p>字典树（Trie）</p>
<p>字典树，也称为“前缀树”，是一种特殊的树状数据结构，对于解决字符串相关问题非常有效。它能够提供快速检索，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于IP的路由。</p>
<p>这些单词以顶部到底部的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“theirs”的底部。</p>
<p>面试中关于字典树的常见问题</p>
<p>计算字典树中的总单词数 打印存储在字典树中的所有单词 使用字典树对数组的元素进行排序 使用字典树从字典中形成单词 构建T9字典（字典树+ DFS ）</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键（key）”）中的过程。因此，对象以键值对的形式存储，这些键值对的集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。</p>
<p>哈希表通常使用数组实现。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql事务</title>
    <url>/Mysql/Mysql%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h1><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！<a id="more"></a></p>
<ul>
<li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li>
<li>事务处理维护数据库的完整性，保updte,adelete 语句</li>
</ul>
<p>一般来说，事务是必须满足4个条证成批的 SQL 语句要么全部执行，要么全部不执行。</p>
<ul>
<li><p>事务用来可以用来管理 insert,件（ACID）：：原子性（<strong>A</strong>tomicity，或称不可分割性）、一致性（<strong>C</strong>onsistency）、隔离性（<strong>I</strong>solation，又称独立性）、持久性（<strong>D</strong>urability）。</p>
</li>
<li><p><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
</li>
<li><p><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
</li>
<li><p><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
</li>
<li><p><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
</li>
</ul>
<hr>
<p>‘- 显示数据库：show databases;</p>
<h5 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h5><p>​    sql server（微软）windows 专有数据<br>​    mysql    默认端口:3306<br>​    oracle（重点）甲骨文<br>​    access<br>​    sqlite<br>​    ibm db2<br>​    关系型数据库管理系统</p>
<p>-查看 mysql 版本： select version();<br>primary key 主键   auto_increment 自动递增   not null ,要求该约束所修饰的字段，不能为null或空    unsigned 约束的字段，会去掉负值，添加到正值，范围 x 2 + 1</p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>命令格式：select * from 表名 order by 字段名 asc(升序)|desc（降序）;<br>多字段排序<br>select * from department order by groups desc,kpi desc;<br>多字段排序时，先按第一字段排序，第一段相同的，再按第二字段排序。</p>
<h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ul>
<li>创建数据库命令格式： <code>create database 数据库名字 charset=字符集</code></li>
<li>创建表命令格式: <code>create table 表名( 字段 属性 );</code></li>
</ul>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul>
<li>删除表<br>命令格式：drop table 表名;</li>
<li>删库<br>格式: <code>drop database 库名;</code><br>删除主键<br>alter table 表名 drop 主键字段名;<br>删除数据<br>命令格式<br>delete from 表名 where 【条件】</li>
</ul>
<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>-修改已创建的表名<br>命令格式：alter table 原表名 rename to  新表名;</p>
<p>旧改法：<br>      alter user ‘root’@’localhost’ identified by ‘mysql’;</p>
<p>-10.1.38-MariaDB 修改密码：<br>    update mysql.user set Password = password(‘1999’) where             user=’(root）’;<br>    flush privileges;<br>    exit;</p>
<p>远程链接:<br>    GRANT ALL PRIVILEGES ON * .* TO ‘root’@’%’ IDENTIFIED BY ‘root’ WITH GRANT OPTION;</p>
<p>mysql 配置文件：<br>     windows -&gt; mysql/bin/my.ini<br>     linux -&gt; mysq/my.cnf</p>
<h5 id="修改创建好的表字"><a href="#修改创建好的表字" class="headerlink" title="修改创建好的表字"></a>修改创建好的表字</h5><p>段命令格式: alter table 表名 change 原字段名 新字段名 字段类型 字段属性（约束）;<br>添加新的字段<br>命令格式: alter table 表名 add 字段名 字段类型 字段属性（约束）;<br>修改表名<br>命令格式：alter table 旧表名 rename to 新表名;<br>创建表后修改主键<br>alter table 表名 change 原字段名（要设为主键的字段） 新字段名 int primary key auto_incremnt not null;<br>修改数据<br>update 表名 set 字段名1=要修改值1,字段名2=要修改值2 where [条件]</p>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>基本查询<br>命令格式：select [要查询的字段，如果是所有字段，就是*;如果单个，写字段名] from 【表名】 where 【条件】<br>范围查询<br>命令格式： select [字段] from 表名 where 字段名 between 开始 and 结束<br>in ( ) 在 … 里 not in<br>模糊查询<br>命令格式： select [字段] from 表名 where 字段 like …%…<br>内联接查询<br>命令格式:select [字段] from 表名1 inner join 表名2 on 表名1.连接字段=表名2.连接字段<br>右链接<br>select * from student s right join class c on s.cls_id=c.id<br>左连接<br>select *  from class c left join student s on s.cls_id=c.id;<br>全联接<br> select * from class c left join student s on c.id=s.cls_id<br> union<br> select * from class c right join student s on c.id=s.cls_id;<br>自联接（自查询)<br>表和自身的连接，使用 inner join 来完成</p>
<h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><p>命令格式:<br>insert into 表名（字段名1,字段名2,字段名3…..）values(值1,值2,值3…);<br>另外一种形式<br>insert into 表名 values(字段1的值，字段2的值，字段3的值。。。。);</p>
<p>-分组<br>group by 分组<br>分组  group_concat()+group by </p>
<h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="-聚合函数"></a>-聚合函数</h5><p>统计函数 count（）<br>命令格式： select count(要统计的字段) from 表名 where [条件]<br>求最大值<br>命令格式：select max(求最大值的字段) from 表名;<br>求最小值<br>命令格式：select min(要计算最小值的字段) from 表名;<br>求和<br>命令格式:<br>select sum(要求和/总数的字段) from 表名;<br>求平均值<br>select avg(要求平均值字段) from 表名;</p>
<p>having<br>having 和 where 都 可以对记录进行筛选；但是having跟在group by 后面，group by 跟在 where 后面；having 后面条件必须在 select 字段中出现，没有，就会报错；where 是必须是表中字段<br>where … group by … having</p>
<h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p>命令格式：<br>create view 视图名字 as select语句;<br>查看视图<br>命令格式：show tables;<br>删除视图<br>drop view 视图名字<br>修改视图<br>create or replace view 视图名字 as select语句;</p>
<h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>查看索引<br>命令格式：<br>show index from 表名；<br>创建索引的命令<br>格式：<br>create index idx_索引名  on 表名（字段名（索引长度））<br>删除索引<br>命令格式:<br>drop index 索引名称 on 表名;</p>
<h5 id="三范式："><a href="#三范式：" class="headerlink" title="三范式："></a>三范式：</h5><p>1：确保每列保持原子性<br>2：确保表中每列都和主键直接相关<br>3：确保每列都和主键列直接相关，而不是间接相关</p>
<h5 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h5><p>​    是一个操作序列，这些操作要么都执行，要么都不执行，它是一个完整的，不可分割的工作单位。<br>事务具有的特性：原子性 ，一致，隔离，持久<br>开启事务：start transaction   / begin<br>提交         commit</p>
<p>当前时间加1天<br>select date_add(now(),interyal 1day)</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器</title>
    <url>/uncategorized/%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器本质上是一个Python函数，它可以让其它哈桑农户在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。比如：插入日志，性能测试，事务处理，缓存，权限校验等。有了装饰器我们就可以抽离处大量的与函数功能无关的雷同代码进行重用。装饰器其实就是一个闭包，把一个函数当做参数返回一个替代版函数。 <a id="more"></a> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrr</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="string">'111'</span>)</span><br><span class="line">		func()</span><br><span class="line">	<span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@wrr</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'222'</span>)</span><br><span class="line">my()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算函数执行时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">(func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">		strat=time.time()</span><br><span class="line">		print(<span class="string">'信任'</span>)</span><br><span class="line">		func()</span><br><span class="line">		last=time.time()</span><br><span class="line">		print(last-strat)</span><br><span class="line">	<span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@out</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ll</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'理解'</span>)</span><br><span class="line">	time.sleep(<span class="number">3</span>)</span><br><span class="line">ll()</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#带参装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_code</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> func(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wraper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_code()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'%s是歌手'</span> % name)</span><br><span class="line">sing(<span class="string">'张三'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#定义反扒装饰器,定义形参，一秒允许请求一次</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">limit</span><span class="params">(seconds=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment">#定义内部方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rate_limit</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func_limit</span><span class="params">(request)</span>:</span></span><br><span class="line">            <span class="comment">#获取当前时间</span></span><br><span class="line">            now = time.time()</span><br><span class="line">            <span class="comment">#获取首次来访时间</span></span><br><span class="line">            request_time = request.session.get(<span class="string">'req_time'</span>,<span class="number">0</span>)</span><br><span class="line">            <span class="comment">#做减法</span></span><br><span class="line">            in_time = int(now) - request_time</span><br><span class="line">            <span class="comment">#判断访问者在一秒内来了不止一次</span></span><br><span class="line">            <span class="keyword">if</span> in_time &lt; seconds:</span><br><span class="line">                <span class="comment">#抛出异常 ,使用第二个参数来指定异常</span></span><br><span class="line">                <span class="keyword">return</span> HttpResponse(<span class="string">'你是爬虫，不要来了'</span>,status=<span class="number">403</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#来的时间点存储</span></span><br><span class="line">                request.session[<span class="string">'req_time'</span>] = time.time()</span><br><span class="line">                <span class="comment">#让访问者继续访问</span></span><br><span class="line">                ret = func(request)</span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> func_limit</span><br><span class="line">    <span class="keyword">return</span> rate_limit</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个验证登录的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_login</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warpper</span><span class="params">(request,*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="comment">#is_login = request.session.get("username",False)</span></span><br><span class="line">        is_login = request.COOKIES.get(<span class="string">"username"</span>,<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> is_login:</span><br><span class="line">            ret = func(request,*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(<span class="string">"/supermarket"</span>)</span><br><span class="line">    <span class="keyword">return</span> warpper</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>八大排序</title>
    <url>/Python/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序；首先将第一个作为已经排好序的，然后每次从后的取出插入到前面并排序；<a id="more"></a></p>
<p>时间复杂度：O(n²)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">def insert_sort(<span class="keyword">ilist</span>):</span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="keyword">ilist</span>)):</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">ilist</span>[i] &lt; <span class="keyword">ilist</span>[<span class="keyword">j</span>]:</span><br><span class="line">                <span class="keyword">ilist</span>.<span class="keyword">insert</span>(<span class="keyword">j</span>, <span class="keyword">ilist</span>.<span class="keyword">pop</span>(i))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">ilist</span></span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成</p>
<p>时间复杂度：O(n²)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">def <span class="keyword">bubble_sort(blist):</span></span><br><span class="line"><span class="keyword"> </span>   <span class="built_in">count</span> = len(<span class="keyword">blist)</span></span><br><span class="line"><span class="keyword"> </span>   for i in range(<span class="number">0</span>, <span class="built_in">count</span>):</span><br><span class="line">        for <span class="keyword">j </span>in range(i + <span class="number">1</span>, <span class="built_in">count</span>):</span><br><span class="line">            if <span class="keyword">blist[i] </span>&gt; <span class="keyword">blist[j]:</span></span><br><span class="line"><span class="keyword"> </span>               <span class="keyword">blist[i], </span><span class="keyword">blist[j] </span>= <span class="keyword">blist[j], </span><span class="keyword">blist[i]</span></span><br><span class="line"><span class="keyword"> </span>   return <span class="keyword">blist</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">blist </span>= <span class="keyword">bubble_sort([4,5,6,7,3,2,6,9,8])</span></span><br><span class="line"><span class="keyword">print(blist)</span></span><br></pre></td></tr></table></figure>

<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p>
<p>时间复杂度：O(nlog₂n)</p>
<p>空间复杂度：O(nlog₂n)</p>
<p>稳定性：不稳定</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">def quick<span class="constructor">_sort(<span class="params">qlist</span>)</span>:</span><br><span class="line">    <span class="keyword">if</span> qlist<span class="operator"> == </span><span class="literal">[]</span>:</span><br><span class="line">        return <span class="literal">[]</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        qfirst = qlist<span class="literal">[<span class="number">0</span>]</span></span><br><span class="line">        qless = quick<span class="constructor">_sort([<span class="params">l</span> <span class="params">for</span> <span class="params">l</span> <span class="params">in</span> <span class="params">qlist</span>[1:] <span class="params">if</span> <span class="params">l</span> &lt; <span class="params">qfirst</span>])</span></span><br><span class="line">        qmore = quick<span class="constructor">_sort([<span class="params">m</span> <span class="params">for</span> <span class="params">m</span> <span class="params">in</span> <span class="params">qlist</span>[1:] <span class="params">if</span> <span class="params">m</span> &gt;= <span class="params">qfirst</span>])</span></span><br><span class="line">        return qless + <span class="literal">[<span class="identifier">qfirst</span>]</span> + qmore</span><br><span class="line"></span><br><span class="line">qlist = quick<span class="constructor">_sort([4,5,6,7,3,2,6,9,8])</span></span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕</p>
<p>时间复杂度：O(n²)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：不稳定</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">def select_sort(slist):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(slist)):</span><br><span class="line">        x = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(slist)):</span><br><span class="line">            <span class="keyword">if</span> slist[j] &lt; slist[x]:</span><br><span class="line">                x = j</span><br><span class="line">        slist[i], slist[x] = slist[x], slist[i]</span><br><span class="line">    <span class="keyword">return</span> slist</span><br><span class="line"></span><br><span class="line">slist = select_sort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序：采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并</p>
<p>时间复杂度：O(nlog₂n)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">def merge_sort(array):</span><br><span class="line">    def merge_arr(arr_l, arr_r):</span><br><span class="line">       <span class="built_in"> array </span>= []</span><br><span class="line">        while len(arr_l)<span class="built_in"> and </span>len(arr_r):</span><br><span class="line">           <span class="built_in"> if </span>arr_l[0] &lt;= arr_r[0]:</span><br><span class="line">                array.append(arr_l.pop(0))</span><br><span class="line">            elif arr_l[0] &gt; arr_r[0]:</span><br><span class="line">                array.append(arr_r.pop(0))</span><br><span class="line">       <span class="built_in"> if </span>len(arr_l) != 0:</span><br><span class="line">           <span class="built_in"> array </span>+= arr_l</span><br><span class="line">        elif len(arr_r) != 0:</span><br><span class="line">           <span class="built_in"> array </span>+= arr_r</span><br><span class="line">       <span class="built_in"> return </span>array</span><br><span class="line"></span><br><span class="line">    def recursive(array):</span><br><span class="line">       <span class="built_in"> if </span>len(array) == 1:</span><br><span class="line">           <span class="built_in"> return </span>array</span><br><span class="line">        mid = len(array) // 2</span><br><span class="line">        arr_l = recursive(array[:mid])</span><br><span class="line">        arr_r = recursive(array[mid:])</span><br><span class="line">       <span class="built_in"> return </span>merge_arr(arr_l, arr_r)</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> return </span>recursive(array)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟环境</title>
    <url>/Linux/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="构建爬虫系统"><a href="#构建爬虫系统" class="headerlink" title="构建爬虫系统"></a>构建爬虫系统</h1><h2 id="一、实现目的"><a href="#一、实现目的" class="headerlink" title="一、实现目的"></a>一、实现目的</h2><p>爬虫是文档的重要来源，所以这一节也比较重要，我会从爬虫的基础讲起，爬虫的构成如何编写爬虫等等，希望大家能跟着文档一步步动手做下去。<a id="more"></a></p>
<h4 id="1-1-实验知识点"><a href="#1-1-实验知识点" class="headerlink" title="1.1 实验知识点"></a>1.1 实验知识点</h4><ul>
<li>爬虫的基本概念</li>
<li>异步爬虫框架ruia的使用介绍</li>
<li>基于ruia构造异步爬虫系统</li>
</ul>
<h4 id="1-2-实验环境"><a href="#1-2-实验环境" class="headerlink" title="1.2 实验环境"></a>1.2 实验环境</h4><ul>
<li>Python 3.6+</li>
<li>MongoDB</li>
</ul>
<h2 id="二、开发准备"><a href="#二、开发准备" class="headerlink" title="二、开发准备"></a>二、开发准备</h2><h5 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建项目代码目录</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">-p ~/Code/monkey</span></span><br><span class="line"><span class="comment"># 进入项目根目录</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">~/Code/monkey</span></span><br><span class="line"><span class="comment"># 创建一个名叫env的虚拟环境(注：Python3自带pyenv)</span></span><br><span class="line"><span class="attr">python3</span> <span class="string">-m venv env  </span></span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line"><span class="attr">source</span> <span class="string">env/bin/activate</span></span><br><span class="line"><span class="comment"># 安装项目依赖的包</span></span><br><span class="line"><span class="attr">pip</span> <span class="string">install -r requirements.txt</span></span><br></pre></td></tr></table></figure>

<h2 id="三、小试牛刀"><a href="#三、小试牛刀" class="headerlink" title="三、小试牛刀"></a>三、小试牛刀</h2><h3 id="3-1-使用requests-lxml爬取网页"><a href="#3-1-使用requests-lxml爬取网页" class="headerlink" title="3.1 使用requests + lxml爬取网页"></a>3.1 使用requests + lxml爬取网页</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注：以下代码未经过运行测试，只是手写思路</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://movie.douban.com/subject/1292052/'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>:<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Safari/605.1.15"</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(url,headers=headers)</span><br><span class="line">tree = etree.HTML(r.text)</span><br><span class="line">el = tree.xpath(<span class="string">'//*[@id="content"]/h1/span[1]/text()'</span>)</span><br><span class="line">print(el)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-使用ruia框架爬取网页"><a href="#3-2-使用ruia框架爬取网页" class="headerlink" title="3.2 使用ruia框架爬取网页"></a>3.2 使用ruia框架爬取网页</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ruia <span class="keyword">import</span> Item, TextField</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanItem</span><span class="params">(Item)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    定义爬虫的目标字段</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    title = TextField(css_select=<span class="string">'#content &gt; h1 &gt; span:nth-child(1)'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async_func = DoubanItem.get_item(url=<span class="string">"https://movie.douban.com/subject/1292052/"</span>)</span><br><span class="line">item = asyncio.get_event_loop().run_until_complete(async_func)</span><br><span class="line">print(item.title)</span><br></pre></td></tr></table></figure>



<h2 id="上午主要内容总结"><a href="#上午主要内容总结" class="headerlink" title="上午主要内容总结"></a>上午主要内容总结</h2><ul>
<li><p>掌握快速学习的能力，任何框架都是那么容易</p>
</li>
<li><p>做项目时，一定要用虚拟环境，学会使用pip freeze &gt;&gt; requirements.txt命令，学会使用pip install -r requirements.txt</p>
<p>我们通常会把项目依赖的环境命名为“requirements.txt”</p>
</li>
<li><p>学会借力：例如，借助浏览器的copy xpath功能快速定位元素位置</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础</title>
    <url>/Python/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h6 id="解释下Python中的三元运算？"><a href="#解释下Python中的三元运算？" class="headerlink" title="解释下Python中的三元运算？"></a>解释下Python中的三元运算？</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[on true <span class="keyword">if</span> [expression] <span class="keyword">else</span> [on false]]</span><br><span class="line"><span class="comment">#如果表达式为True,就执行[on true]中的语句。否则，就执行[on false]中的语句</span></span><br><span class="line">a,b=<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">min=a <span class="keyword">if</span> a&lt;b <span class="keyword">else</span> b</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h6 id="Python中的继承"><a href="#Python中的继承" class="headerlink" title="Python中的继承?"></a>Python中的继承?</h6><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">#当一个类继承自另一个类，它就被称为一个子类/派生类，继承自父类/基类/超类。它会继承/获取所有类成员(属性和方法)。继承能让我们重新使用代码，也能更容易的创建个维护使用。</span><br><span class="line">Python支持如下种类的继承：</span><br><span class="line">	<span class="number">1</span>.单继承：一个类继承自单个基类</span><br><span class="line">	<span class="number">2</span>.多继承:一个类继承自多个基类</span><br><span class="line">	<span class="number">3</span>.多级继承:一个类继承自单个基类，后者则继承自另一个基类</span><br><span class="line">	<span class="number">4</span>.分层继承:多个类继承自单个基类</span><br><span class="line">	<span class="number">5</span>.混合继承:俩种或多种类型继承的混合</span><br></pre></td></tr></table></figure>

<h6 id="解释Python中的help-和dir-函数"><a href="#解释Python中的help-和dir-函数" class="headerlink" title="解释Python中的help()和dir()函数"></a>解释Python中的help()和dir()函数</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">help()函数是一个内置函数，用于查看函数或模块用途的详细说明</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">help(copy.copy)</span><br><span class="line">dir()函数也是Python内置函数，dir()函数不带参数时，返回当前范围内的变量，方法和定义的类型列表；带参数时，返回参数的属性，方法列表</span><br><span class="line">dir(copy.copy)</span><br></pre></td></tr></table></figure>

<h6 id="什么是猴子补丁"><a href="#什么是猴子补丁" class="headerlink" title="什么是猴子补丁"></a>什么是猴子补丁</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在运行期间动态修改一个类或模块。通常功能是添加模块或者是修改功能</span></span><br></pre></td></tr></table></figure>

<h6 id="解释使用args和-kwargs的含义"><a href="#解释使用args和-kwargs的含义" class="headerlink" title="解释使用args和*kwargs的含义"></a>解释使用args和*kwargs的含义</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">当我们不知道向函数传递多少参数时，比如我们先传递一个列表或元组，我们就使用*args</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        print(i)  </span><br><span class="line">func(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">在我们不知道该传递多少关键字参数时，使用**kwargs来手机关键字参数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> kwargs:</span><br><span class="line">        print(i,kwargs[i])</span><br><span class="line">func(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<h6 id="什么是负索引"><a href="#什么是负索引" class="headerlink" title="什么是负索引"></a>什么是负索引</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">负索引和正索引不同，它是从右边开始检索。</span><br><span class="line">它也能用于列表中的切片：</span><br><span class="line">mylist=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">mylist[<span class="number">-3</span>]  <span class="number">3</span></span><br><span class="line">mylist[<span class="number">-6</span>:<span class="number">-1</span>]    <span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span></span><br></pre></td></tr></table></figure>

<h6 id="Python中的join-和split-函数"><a href="#Python中的join-和split-函数" class="headerlink" title="Python中的join()和split()函数"></a>Python中的join()和split()函数</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Join()能让我们将指定字符添加至字符串中。</span><br><span class="line">Split()能让我们用指定字符分割字符串。</span><br></pre></td></tr></table></figure>

<h6 id="怎么移除一个字符串中的前导空格"><a href="#怎么移除一个字符串中的前导空格" class="headerlink" title="怎么移除一个字符串中的前导空格"></a>怎么移除一个字符串中的前导空格</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串中的前导空格就是出现在字符串中第一个非空格字符前的空格。我们使用方法lstrip()可以将之移除</span><br><span class="line"><span class="string">'  Hello World ! '</span>.lstrip()</span><br><span class="line">当然也有后缀字符，调用rstrip()将之移除</span><br><span class="line"><span class="string">'  Hello World ! '</span>.rstrip()</span><br></pre></td></tr></table></figure>

<h6 id="python中的pass语句是什么"><a href="#python中的pass语句是什么" class="headerlink" title="python中的pass语句是什么"></a>python中的pass语句是什么</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在使用python写代码时，有时可能还没想好函数怎么写，只写了函数声明，但为了保证语法正确，必须输入一些东西，在这种情况下，我们会使用<span class="keyword">pass</span>语句。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">同样，<span class="keyword">break</span>语句能让我们跳出循环</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">3</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(i)    <span class="comment">#0,1,2</span></span><br><span class="line">最后，<span class="keyword">continue</span>语句能让我们跳到一个循环</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">3</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(i)   <span class="comment">#0,1,2,4</span></span><br></pre></td></tr></table></figure>

<h6 id="python中的闭包是什么"><a href="#python中的闭包是什么" class="headerlink" title="python中的闭包是什么"></a>python中的闭包是什么</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">但一个嵌套函数在其外部区域引用了一个值时，该嵌套函数就是一个闭包。其意义就是会记录这个值</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">        print(x)</span><br><span class="line">     <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>

<h6 id="python的装饰器"><a href="#python的装饰器" class="headerlink" title="python的装饰器"></a>python的装饰器</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'先过我这一关！'</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@out</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">My</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'哈哈哈'</span>)</span><br><span class="line">My()</span><br><span class="line">装饰器本质上是一个python函数，它可以让其他函数在不做任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。比如：插入日志、性能测试、事务处理、缓存、权限校验等。有了装饰器我们就可以抽离出大量的与函数功能无关的雷同代码进行重用。</span><br><span class="line">装饰器其实就是一个闭包，把一个函数当做参数然后返回一个替代版函数</span><br></pre></td></tr></table></figure>

<h6 id="python中的逻辑运算符"><a href="#python中的逻辑运算符" class="headerlink" title="python中的逻辑运算符"></a>python中的逻辑运算符</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="keyword">or</span> <span class="keyword">not</span></span><br></pre></td></tr></table></figure>

<h6 id="python支持什么数据类型"><a href="#python支持什么数据类型" class="headerlink" title="python支持什么数据类型"></a>python支持什么数据类型</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Number(数字) 用于保存数值</span><br><span class="line">String(字符串) 字符串是一个字符序列。我们用单引号或双引号来声明字符串</span><br><span class="line">List(列表) 列表就是一些值的有序集合，我们用方括号声明列表。</span><br><span class="line">Tuples（元组）——元组和列表一样，也是一些值的有序集合，区别是元组是不可变的，意味着我们无法改变元组内的值。</span><br><span class="line">Dictionary（字典）——字典是一种数据结构，含有键值对。我们用大括号声明字典</span><br></pre></td></tr></table></figure>

<h6 id="什么是切片"><a href="#什么是切片" class="headerlink" title="什么是切片"></a>什么是切片</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">切片是python中的一种方法，能让我们只检索列表，元素或字符串的一部分。在切片时，我们使用切片操作符[]</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)[<span class="number">2</span>:<span class="number">4</span>]    <span class="comment">#(3,4)</span></span><br></pre></td></tr></table></figure>

<h6 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span>函数是一个简短的匿名函数</span><br><span class="line"><span class="keyword">lambda</span>函数可以接收任意数量的参数，但只能包含一个表达式</span><br><span class="line">接收参数，执行表达式，返回结果</span><br><span class="line">x= <span class="keyword">lambda</span> a: a+<span class="number">10</span>    <span class="comment">#一个lambda函数，把参数加10，然后返回结果</span></span><br><span class="line">print(x(<span class="number">5</span>))  <span class="comment">#15</span></span><br><span class="line">x=<span class="keyword">lambda</span> a,b :a+b  <span class="comment">#一个lambda函数，将参数a与b相加</span></span><br><span class="line">print(x(<span class="number">5</span>,<span class="number">6</span>))  <span class="comment">#11</span></span><br><span class="line">fib = <span class="keyword">lambda</span> n : n <span class="keyword">if</span> n &lt;= <span class="number">2</span> <span class="keyword">else</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>)  <span class="comment">#斐波那契</span></span><br></pre></td></tr></table></figure>

<h6 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在调用一个函的过程中，直接或间接的调用了函数本身这个就叫做递归，为了避免出现死循环，必须要有结束条件。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">facto</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n*facto(n<span class="number">-1</span>)</span><br><span class="line">print(facto(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion</span><span class="params">(n)</span>:</span>  <span class="comment"># 定义递归函数</span></span><br><span class="line">    print(n)  <span class="comment"># 打印n</span></span><br><span class="line">    recursion(n+<span class="number">1</span>)  <span class="comment"># 在函数的运行种调用递归 要有结束条件，负责无限递归</span></span><br><span class="line">    <span class="comment">#可为什么执行了900多次就报错了呢?还说超过了最大递归深度限制,为什么要限制呢?</span></span><br><span class="line">	<span class="comment">#通俗来讲,是因为每个函数在调用自己的时候,还没有退出,占内存,多了肯定会导致内存崩溃.</span></span><br><span class="line">recursion(<span class="number">1</span>)  <span class="comment"># 调用函数</span></span><br></pre></td></tr></table></figure>

<h6 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在 Python 中，使用了 <span class="keyword">yield</span> 的函数被称为生成器（generator）。</span><br><span class="line">生成器会生成一系列的值用于迭代，这样看它又是一种可迭代对象。它是在<span class="keyword">for</span>循环的过程中不断计算出下一个元素，并在适当的条件下结束循环。</span><br><span class="line">生成器也是一种迭代器，但是你只能对其迭代一次 [<span class="number">1</span>]  。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。你通过遍历来使用它们，要么用一个“<span class="keyword">for</span>”循环，要么将它们传递给任意可以进行迭代的函数和结构。大多数时候生成器是以函数来实现的。然而，它们并不返回一个值，而是<span class="keyword">yield</span>(暂且译作“生出”)一个值。</span><br></pre></td></tr></table></figure>

<h6 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">类中实现俩个方法__iter__() 与__next__()</span><br><span class="line">迭代器只能返回不能后退</span><br><span class="line">__init__() 它会在对象初始化的时候执行</span><br><span class="line">__iter__()返回一个特殊的迭代器对象，这个迭代器对象实现了__next__()方法并通过stoplteration异常标识迭代的完成。</span><br><span class="line">__next__()方法 会返回下一个迭代器对象。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br></pre></td></tr></table></figure>

<h6 id="迭代器和生成器的区别"><a href="#迭代器和生成器的区别" class="headerlink" title="迭代器和生成器的区别"></a>迭代器和生成器的区别</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在使用生成器时，我们创建一个函数；在使用迭代器时，我们使用内置函数iter()和next()。 在生成器中，我们使用关键字‘<span class="keyword">yield</span>’来每次生成/返回一个对象。 生成器中有多少‘<span class="keyword">yield</span>’语句，你可以自定义。 每次‘<span class="keyword">yield</span>’暂停循环时，生成器会保存本地变量的状态。而迭代器并不会使用局部变量，它只需要一个可迭代对象进行迭代。 使用类可以实现你自己的迭代器，但无法实现生成器。 生成器运行速度快，语法简洁，更简单。 迭代器更能节约内存。</span><br></pre></td></tr></table></figure>

<h6 id="如何在python中创建自己的包"><a href="#如何在python中创建自己的包" class="headerlink" title="如何在python中创建自己的包"></a>如何在python中创建自己的包</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python中创建包是比较方便的，只需在当前目录建立一个文件夹，文件夹中包含一个init.py文件和若干个模块文件，其中init.py可以是一个空文件，但还是建议将包中所有需要导出的变量放到all中，这样可以确保包的接口清晰明了，易于使用。</span><br></pre></td></tr></table></figure>

<h6 id="什么是元类"><a href="#什么是元类" class="headerlink" title="什么是元类"></a>什么是元类</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">元类是类的类对象，换言之类是元类的实列，python中默认的元类为type,可以自定义元类的方法实现对类创建的空中。</span><br></pre></td></tr></table></figure>

<h6 id="在python中是如何管理内存的"><a href="#在python中是如何管理内存的" class="headerlink" title="在python中是如何管理内存的"></a>在python中是如何管理内存的</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python有一个私有堆空间来保存所有的对象和数据结构。</span><br><span class="line">python采用的是引用计数为主，分代回收为辅(引用计数，标记-清楚，分代回收)</span><br><span class="line">从三个方面来说</span><br><span class="line">一.对象的引用计数机制</span><br><span class="line">	引用计数增加的情况:</span><br><span class="line">        <span class="number">1.</span>一个对象分配一个新名称</span><br><span class="line">        <span class="number">2.</span>将其放入一个容器中(如列表，元组或字典)</span><br><span class="line">    引用计数减少的情况:</span><br><span class="line">        <span class="number">1.</span>使用<span class="keyword">del</span>语句对对象别名显示的销毁</span><br><span class="line">        <span class="number">2.</span>引用超出作用域或被重新赋值</span><br><span class="line">     sys.getrefcount()函数可以获得对象的当前引用计数</span><br><span class="line">二.垃圾回收机制</span><br><span class="line">	<span class="number">1.</span>当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。</span><br><span class="line">    <span class="number">2.</span>当俩个对象a和b相互引用时，<span class="keyword">del</span>语句可以减少a和b的引用计数，并销毁用于底层对象的名称</span><br><span class="line">三.内存机制</span><br><span class="line">	python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统</span><br><span class="line">    <span class="number">1.</span>pumalloc机制，为了加速python的执行效率，python引入了一个内存池机制，用于管理对小块内存的申请和施放</span><br><span class="line">    <span class="number">2.</span>对于python对象，如整数，浮点数，list都具有独立的私有的内存池，对详见不共享他们的内存池，也就是说如果你分配了又施放了大量的整数，用于缓存这些整数的内存就不再分配给浮点数。</span><br></pre></td></tr></table></figure>

<h6 id="深拷贝和浅拷贝之间的区别是什么"><a href="#深拷贝和浅拷贝之间的区别是什么" class="headerlink" title="深拷贝和浅拷贝之间的区别是什么"></a>深拷贝和浅拷贝之间的区别是什么</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">深拷贝就是将一个对象拷贝到另一个对象中，这意味着如果你对一个对象的拷贝做出改变时，不会影响原对象。</span><br><span class="line">浅拷贝是将一个对象的引用拷贝到另一个对象上，所以我们在拷贝中改动，会影响原对象。是对对象的顶层拷贝</span><br></pre></td></tr></table></figure>

<h6 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">普通实例方法，第一个参数需要是self,它表示一个具体的实例本身。</span><br><span class="line">如果用了staticmethod,那么就可以无视这个self.而将这个方法当成一个普通的函数使用。不需要任何参数，当然它也不能传递任何实列的属性和方法。静态方法，参数随意</span><br><span class="line">classmethod第一个参数必须是当前类的cls参数，通常它被预定为cls，通过它来调用类的属性和方法</span><br></pre></td></tr></table></figure>

<h6 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span>是一种上下文管理协议，目的在于从流程图 中把<span class="keyword">try</span>,excerpt和<span class="keyword">finally</span>关键字和资源分配施放相关代码统统去掉，简化<span class="keyword">try</span>....excerpt...<span class="keyword">finally</span>的处理流程。<span class="keyword">with</span>通过enter方法初始化，然后在exit中做善后及处理异常。所以使用<span class="keyword">with</span>处理的对象必须又enter()和exit()这俩个方法。<span class="keyword">with</span>语句适用于对资源进行访问的场合。</span><br><span class="line"><span class="keyword">with</span>的使用场景 如果某项工作后完成需要有施放资源或者其他清理工作，比如说文件操作时，就可以适用<span class="keyword">with</span>优雅的处理，不用自己手动关闭文件包炳，而且<span class="keyword">with</span>还能很好的管理上下文异常。</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'demo.py'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">        print(i,end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<h6 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__new__是在一个对象实例化的时候所调用的第一个方法。它的第一个参数是这个类</span><br><span class="line">__init__用来构建初始化函数</span><br><span class="line">__str__如果类定义__Str__方法，那么就会打印从这个方法中<span class="keyword">return</span>的数据</span><br><span class="line">__del__当删除对象时，python解释器会调用</span><br><span class="line">__doc__打印当前类的描述信息，也就是注释部分</span><br><span class="line">__dict__ 打印类中的属性</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django相关</title>
    <url>/Django/Django/</url>
    <content><![CDATA[<h1 id="Django-、Flask、Tornado的对比"><a href="#Django-、Flask、Tornado的对比" class="headerlink" title="Django 、Flask、Tornado的对比"></a>Django 、Flask、Tornado的对比</h1><p>1.Django走的是大而全的方向,开发效率高。它的MTV框架,自带的ORM,admin后台管理,自带的sqlite数据库和开发测试用的服务器 给开发者提高了超高的开发效率</p>
<p>2.Flask是轻量级的框架,自由,灵活,可扩展性很强,核心基于Werkzeug WSGI工具和jinja2模板引擎</p>
<p>3.Tornado走的是少而精的方向,性能优越。它最出名的是异步非阻塞的设计方式</p>
<p>Tornado的两大核心模块： 1.iostraem：对非阻塞式的socket进行简单的封装 2.ioloop：对I/O多路复用的封装，它实现了一个单例<a id="more"></a></p>
<h2 id="什么是wsgi？"><a href="#什么是wsgi？" class="headerlink" title="什么是wsgi？"></a>什么是wsgi？</h2><p>WSGI，描述web server如何与web application通信的一种规范</p>
<p>WSGI协议主要包括server和application两部分：</p>
<p>WSGI server负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端； WSGI application接收由server转发的request，处理请求，并将处理结果返回给server。</p>
<p>application中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现server与application，因此可以在WSGI服务器与WSGI应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。</p>
<h2 id="简述什么是FBV和CBV？"><a href="#简述什么是FBV和CBV？" class="headerlink" title="简述什么是FBV和CBV？"></a>简述什么是FBV和CBV？</h2><p>FBV（function base views） 基于函数的视图 CBV（class base views） 基于类的视图</p>
<p>使用fbv的模式,在url匹配成功之后,会直接执行对应的视图函数</p>
<p>使用cbv模式,在url匹配成功之后,会找到视图函数中对应的类,然后这个类回到请求头中找到对应的Request Method</p>
<p>用户发送url请求,Django会依次遍历路由映射表中的所有记录,一旦路由映射表其中的一条匹配成功了,就执行视图函数中对应的函数名,这是fbv的执行流程</p>
<p>当服务端使用cbv模式的时候,用户发给服务端的请求包含url和method,这两个信息都是字符串类型 服务端通过路由映射表匹配成功后会自动去找dispatch方法,然后Django会通过dispatch反射的方式找到类中对应的方法并执行 类中的方法执行完毕之后,会把客户端想要的数据返回给dispatch方法,由dispatch方法把数据返回经客户端</p>
<h2 id="django请求的生命周期"><a href="#django请求的生命周期" class="headerlink" title="django请求的生命周期"></a>django请求的生命周期</h2><p>1.wsgi,请求封装后交给web框架 （Flask、Django）</p>
<p>2.中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf、request.session</p>
<p>3.路由匹配 根据浏览器发送的不同url去匹配不同的视图函数</p>
<p>4.视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm、templates =&gt; 渲染</p>
<p>5.中间件，对响应的数据进行处理。</p>
<p>6.wsgi,将响应的内容发送给浏览器。</p>
<h2 id="说一下Django，MIDDLEWARES中间件的作用和应用场景？"><a href="#说一下Django，MIDDLEWARES中间件的作用和应用场景？" class="headerlink" title="说一下Django，MIDDLEWARES中间件的作用和应用场景？"></a>说一下Django，MIDDLEWARES中间件的作用和应用场景？</h2><p>中间件是介于request与response处理之间的一道处理过程,用于在全局范围内改变Django的输入和输出。</p>
<p>简单的来说中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作</p>
<p>例如：</p>
<p>1.Django项目中默认启用了csrf保护,每次请求时通过CSRF中间件检查请求中是否有正确#token值</p>
<p>2.当用户在页面上发送请求时，通过自定义的认证中间件，判断用户是否已经登陆，未登陆就去登陆。</p>
<p>3.当有用户请求过来时，判断用户是否在白名单或者在黑名单里</p>
<p>其内置的五个方法:</p>
<p>1.process_request : 请求进来时,权限认证</p>
<p>2.process_view : 路由匹配之后,能够得到视图函数</p>
<p>3.process_exception : 异常时执行</p>
<p>4.process_template_responseprocess : 模板渲染时执行</p>
<p>5.process_response : 请求有响应时执行</p>
<p>如果你想修改请求，例如被传送到view中的HttpRequest对象</p>
<p>或者你想修改view返回的HttpResponse对象，这些都可以通过中间件来实现</p>
<p>可能你还想在view执行之前做一些操作，这种情况也可以用 middleware来实现。 比如我们写一个判断浏览器来源，是pc还是手机，这里手机我们采用iphone，因为暂时没有其他设备。我们有不想把这个逻辑加到视图函数里，想作为一个通用服务，作为一个可插拔的组件被使用，最好的方法就是实现为中间件</p>
<p>或者说做一个拦截器，发现一定的时间内某个ip对网页的访问次数过多，则将其加入黑名单</p>
<h2 id="使用orm和原生sql的优缺点？"><a href="#使用orm和原生sql的优缺点？" class="headerlink" title="使用orm和原生sql的优缺点？"></a>使用orm和原生sql的优缺点？</h2><p>使用 ORM 最大的优点就是快速开发，让我们将更多的精力放在业务上而不是数据库上，下面是 ORM 的几个优点</p>
<p>隐藏了数据访问细节，使通用数据库交互变得简单易行。同时 ORM 避免了不规范、冗余、风格不统一的 SQL 语句，可以避免很多人为的 bug，方便编码风格的统一和后期维护。 将数据库表和对象模型关联，我们只需针对相关的对象模型进行编码，无须考虑对象模型和数据库表之间的转化，大大提高了程序的开发效率。 方便数据库的迁移。当需要迁移到新的数据库时，不需要修改对象模型，只需要修改数据库的配置。 ORM 的最令人诟病的地方就是性能问题，不过现在已经提高了很多，下面是 ORM 的几个缺点</p>
<p>性能问题 自动化进行数据库关系的映射需要消耗系统资源 程序员编码 在处理多表联查、where 条件复杂的查询时，ORM 可能会生成的效率低下的 SQL 通过 Lazy load 和 Cache 很大程度上改善了性能问题 SQL 调优，SQL 语句是由 ORM 框架自动生成，虽然减少了 SQL 语句错误的发生，但是也给 SQL 调优带来了困难。 越是功能强大的 ORM 越消耗内存，因为一个 ORM Object 会带有很多成员变量和成员函数。 对象和关系之间并不是完美映射 一般来说 ORM 足以满足我们的需求，如果对性能要求特别高或者查询十分复杂，可以考虑使用原生 SQL 和 ORM 共用的方式 使用原生sql优点：</p>
<p>进行复杂的查询时更加灵活 可以根据需要编写特殊的sql语句 使用原生sql缺点：</p>
<p>需要对输入进行严格的检测 自己写的sql语句，很多时候使用的是字符串拼接，可能会有sql注入的漏洞 不能使用django orm相关的一些特性</p>
<p>Django,Flask,tornado的对比</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Django走的是大而全的方向，开发效率高。它的MTV框架，自带的ORM，admin后台管理，自带的sqlite数据库和开发测试用的服务器给开发者提高了超高的开发效率</span><br><span class="line"></span><br><span class="line">Flask是轻量级的框架，自由，灵活，可扩展性很强，核心基于werkzeug wsgi 工具和jinja2模板引擎</span><br><span class="line"></span><br><span class="line">tornado走的是少而精的方向，性能优越。它最出名的是异步非阻塞的设以方式</span><br><span class="line">tornado的两大核心模块:</span><br><span class="line">    <span class="number">1.</span>iostraem:对非阻塞式的socket进行简单的封装</span><br><span class="line">    <span class="number">2.</span>ioloop: 对I/O多路复用的封装</span><br></pre></td></tr></table></figure>

<h6 id="什么是WSGI"><a href="#什么是WSGI" class="headerlink" title="什么是WSGI"></a>什么是WSGI</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">WSGI 描述web server如何与 web application通信的一种规范</span><br><span class="line"></span><br><span class="line">WSGI server负责从客户端接收请求，将request转发给application.将application返回的response返回给客户端</span><br></pre></td></tr></table></figure>

<h6 id="FBV和CBV"><a href="#FBV和CBV" class="headerlink" title="FBV和CBV"></a>FBV和CBV</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FBV基于函数的视图  CBV基于类的视图</span><br><span class="line">使用fbv的模式，在url匹配成功之后，会直接执行对应的视图函数</span><br><span class="line">使用cbv模式，在url匹配成功之后，会找到视图函数中对应的类，然后这个类回到请求头中找到对应的RequestMethod</span><br><span class="line">用户发送url请求，Django会依此遍历路由映射表中的所有记录，一旦路由映射表其中的一条匹配成功了，就执行视图函数中对应的函数名，这是fbv的执行流程</span><br><span class="line"></span><br><span class="line">当服务端使用cbv模式的时候，用户发给服务端的请求包含url，method这俩个信息都是字符串类型 服务端通过路由映射表匹配成功后会自动去找dispatch方法，然后Django会通过dispatch反射的方法找到类中对应的方法并执行类中的方法执行完毕之后，会把客户端想要的数据返回给dispatch方法，由dispatch方法把数据返回客户端</span><br></pre></td></tr></table></figure>

<h6 id="Django请求的生命周期"><a href="#Django请求的生命周期" class="headerlink" title="Django请求的生命周期"></a>Django请求的生命周期</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">WSGI（Web Server Gateway Interface）python web开发的标准，它定义了Web服务器和Web应用程序之间通信的接口规范。</span><br><span class="line"><span class="number">1.</span>wsgi,请求封装后交给web框架(flask,django)  </span><br><span class="line"><span class="number">2.</span>中间件，对请求进行校验或在请求对象中添加其他相关数据  列如:(csrf,request.session)</span><br><span class="line"><span class="number">3.</span>路由匹配 根据浏览器发送的不同url去匹配不同的视图函数</span><br><span class="line"><span class="number">4.</span>视图函数 在视图函数中进行业务逻辑的处理</span><br><span class="line"><span class="number">5.</span>中间件 对响应的数据进行处理</span><br><span class="line"><span class="number">6.</span>wsgi 将响应内容发送给浏览器</span><br></pre></td></tr></table></figure>

<h6 id="说一下Django，MIDDLEWARES中间件的作用和应用场景？-1"><a href="#说一下Django，MIDDLEWARES中间件的作用和应用场景？-1" class="headerlink" title="说一下Django，MIDDLEWARES中间件的作用和应用场景？"></a>说一下Django，MIDDLEWARES中间件的作用和应用场景？</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">中间件是介于request和response处理之间的一道处理过程，用于在全局范围内改变DJANGO的输入和输出。</span><br><span class="line">简单的来说中间件是帮助我们在视图函数执行前和执行之后都可以做一些额外操作</span><br><span class="line">列如：</span><br><span class="line">	<span class="number">1.</span>django项目中默认启用了csrf保护，每次请求时通过csrf中间件检查请求中是否有正确token值</span><br><span class="line">    <span class="number">2.</span>当用户在页面发送请求时，通过自定义的认证中间件，判断用户是否已经登陆，未登陆就去登陆</span><br><span class="line">    <span class="number">3.</span>当有用户请求过来时，判断用户是否在白名单或者黑名单</span><br><span class="line">    </span><br><span class="line">其内置的五个方法:</span><br><span class="line">    <span class="number">1.</span>process_request：请求进来时，权限认证</span><br><span class="line">    <span class="number">2.</span>process_view:路由匹配之后，能够得到视图函数</span><br><span class="line">    <span class="number">3.</span>process_exception:异常时执行</span><br><span class="line">    <span class="number">4.</span>process_template_responseprocess:模板渲染时执行</span><br><span class="line">    <span class="number">5.</span>process_response:请求有响应时执行</span><br><span class="line">        </span><br><span class="line">如果你想修改请求，列如被传送到view中的httprequest对象 或者你想修改view返回的httpresponse对象，这些都可以通过中间件来实现</span><br><span class="line">或者说做一个拦截器，发现一定的时间内某个ip对网页的访问次数过多，则即其加入黑名单</span><br></pre></td></tr></table></figure>

<h6 id="Django-orm"><a href="#Django-orm" class="headerlink" title="Django orm"></a>Django orm</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">O(object)：类和对象</span><br><span class="line">R(relation): 关系，关系数据库中的表格</span><br><span class="line">M(mapping) : 映射</span><br><span class="line">django orm框架的功能:</span><br><span class="line">    建立模型类和表之间的对应关系，允许我们通过面向对象的方式来操作数据库</span><br><span class="line">    根据设计的模型类生成数据库中的表格</span><br><span class="line">    通过方便的配置就可以进行数据库的切换</span><br><span class="line">缺点:</span><br><span class="line">    性能损耗，过度封装</span><br><span class="line">    有一定的学习成本</span><br></pre></td></tr></table></figure>

<h6 id="使用orm和原生sql的优缺点"><a href="#使用orm和原生sql的优缺点" class="headerlink" title="使用orm和原生sql的优缺点"></a>使用orm和原生sql的优缺点</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用orm最大的优点就是快速开发，让我们将更多的精力放在业务上而不是数据库</span><br><span class="line">隐藏了数据访问细节，使用数据库交互变得简单易行。同时orm避免了不规范，风格不统一的sql语句，可以避免很多人为的bug,方便编码风格的统一和后期维护。性能问题:越是功能强大的orm越消耗内存。</span><br><span class="line">    </span><br><span class="line"> 使用原生sql:</span><br><span class="line">  		优:  进行复杂的查询时更加灵活，可以根据需要编写特殊的sql语句</span><br><span class="line">    	缺: 需要对输入进入严格的检测 可能会有Sql注入的漏洞</span><br></pre></td></tr></table></figure>

<h6 id="Django本身提供了runserver-为什么不能用来部署"><a href="#Django本身提供了runserver-为什么不能用来部署" class="headerlink" title="Django本身提供了runserver,为什么不能用来部署"></a>Django本身提供了runserver,为什么不能用来部署</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>runserver方式时调式django时经常用到的运行方式，它使用django自带的wsgi server运行，主要在测试和开发中使用，并且runserver开启的方式也是单进程。</span><br><span class="line"><span class="number">2.</span>uwsgi是一个web服务器，他实现了wsgi协议，uwsgi,http等协议。注意uwsgi是一种通信协议。</span><br><span class="line">uwsgi具有超快的性能，低内存占用和多app管理等优点并且搭配着nginx就是一个生产环境了。</span><br><span class="line">相对来讲，支持的并发量更高，方便管理多进程，发货多核的优势，提升性能</span><br></pre></td></tr></table></figure>

<h6 id="restful规范的认识"><a href="#restful规范的认识" class="headerlink" title="restful规范的认识"></a>restful规范的认识</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">首先restful是一种软件架构风格或者说是一种设计风格，并不是标准，它只是提供了一组设计原则和约束条件，主要用于客户端和服务器交互类的软件。</span><br><span class="line">每一个url代表一种资源</span><br><span class="line">客户端使用get,post,delete,put4个表示操作方式的动词对服务端资源进行操作；get用来获取资源，post用来新建资源(也可以用于更新资源),put用来更新资源，delete用来删除资源。</span><br><span class="line">客户端与服务端之间的交互在请求之间是无状态的。</span><br><span class="line">状态码必须精确(客户端的每一次请求，服务器都必须给出回应。回应包括http状态码和数据俩部分)</span><br><span class="line">http 状态码就是一个三位数，分成五个类别</span><br><span class="line">	<span class="number">1</span>** ：相关信息</span><br><span class="line">    <span class="number">2</span>** ：操作成功</span><br><span class="line">    <span class="number">3</span>** ：重定向</span><br><span class="line">    <span class="number">4</span>** ：客户端错误</span><br><span class="line">    <span class="number">5</span>** ：服务器错误</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse,HttpResponseRedirect,HttpResponseForbidden</span><br><span class="line"><span class="comment">#导入自定义的数据库模型</span></span><br><span class="line"><span class="keyword">from</span> mysite.models <span class="keyword">import</span> User</span><br><span class="line"><span class="comment">#导内置模板方法</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义视图方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment">#打印头部信息</span></span><br><span class="line">    <span class="comment">#print(request.META)</span></span><br><span class="line">    <span class="comment">#获取ip信息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'HTTP_X_FORWARDED_FOR'</span> <span class="keyword">in</span> request.META:</span><br><span class="line">        ip = request.META.get(<span class="string">'HTTP_X_FORWARDED_FOR'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ip = request.META.get(<span class="string">'REMOTE_ADDR'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"来访者的ip是"</span>+str(ip))</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"您的ip是"</span>+str(ip))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义首页视图方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment">#入库操作（增）</span></span><br><span class="line">    <span class="comment">#建立实例</span></span><br><span class="line">    <span class="comment">#user = User(username='新用户',password='你好')</span></span><br><span class="line">    <span class="comment">#入库操作</span></span><br><span class="line">    <span class="comment">#user.save()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#删除数据（删）</span></span><br><span class="line">    <span class="comment">#User.objects.filter(username='新用户').delete()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#修改数据(改) 第一种方式</span></span><br><span class="line">    <span class="comment">#user = User.objects.get(id=9)</span></span><br><span class="line">    <span class="comment">#修改字段</span></span><br><span class="line">    <span class="comment">#user.username = '1234'</span></span><br><span class="line">    <span class="comment">#保存修改</span></span><br><span class="line">    <span class="comment">#user.save()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#修改数据（改） 第二种方式</span></span><br><span class="line">    <span class="comment">#return HttpResponse('',status=403)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#User.objects.filter(id=9).update(password='新密码')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#查询全部数据 翻译为 select * from user; all()返回值是list</span></span><br><span class="line">    res = User.objects.all()</span><br><span class="line">    <span class="comment">#print(res)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#查询限定条件的数据 翻译为 select * from user where username = '新用户123' and逻辑使用多个参数传递</span></span><br><span class="line">    res = User.objects.filter(username=<span class="string">'新用户'</span>,password=<span class="string">'你好'</span>)</span><br><span class="line">    <span class="comment">#print(res)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#只取一条 翻译 select * from user where id = 1</span></span><br><span class="line">    res_one = User.objects.get(id=<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#print(res_one)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#排除条件  翻译为 select * from user where username != '新用户123'   &lt;&gt;</span></span><br><span class="line">    res = User.objects.exclude(username=<span class="string">'新用户'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#定制字段显示 翻译为 select password from user where name = '新用户'</span></span><br><span class="line">    res_s = User.objects.filter(username=<span class="string">'新用户'</span>).values(<span class="string">'password'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#排序 翻译为 select * from user order by id asc  倒序使用 reverse()</span></span><br><span class="line">    res = User.objects.filter(username=<span class="string">'新用户'</span>).order_by(<span class="string">"password"</span>).reverse()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#去重 翻译为 select distinct(username) from user where username = '新用户'</span></span><br><span class="line">    res_dis = User.objects.filter(username=<span class="string">'新用户'</span>).values(<span class="string">'username'</span>).distinct()</span><br><span class="line">    <span class="comment">#print(res_dis)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#取数量 翻译为 select count(*) from user</span></span><br><span class="line">    res_count = User.objects.filter(username=<span class="string">'新用户'</span>).count()</span><br><span class="line">    print(res_count)</span><br><span class="line"></span><br><span class="line">    res_list = [&#123;<span class="string">'name'</span>:<span class="string">'小王'</span>,<span class="string">'score'</span>:<span class="number">100</span>,<span class="string">'gender'</span>:<span class="string">'男'</span>&#125;,&#123;<span class="string">'name'</span>:<span class="string">'小宏'</span>,<span class="string">'score'</span>:<span class="number">50</span>,<span class="string">'gender'</span>:<span class="string">'女'</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'d4_index.html'</span>,locals())</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义捕获500的异常</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_error</span><span class="params">(request,**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"捕获500异常"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/Docker/Docker/</url>
    <content><![CDATA[<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><ul>
<li>什么是docker：小海腾<ul>
<li>KVM、Xen、VMware、VirtualBox、Hyper-V</li>
<li>VMM</li>
</ul>
</li>
<li>容器技术：在计算机的世界中, 容器拥有一段漫长且传奇的历史。容器与管理程序虚拟化 (hypervisor virtualization，HV)有所不同，管理程序虚拟化通过中间层将一台或者多台独立 的机器虚拟运行与物理硬件之上，而容器则是直接运行在操作系统内核之上的用户空间。因 此，容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行 在同一台宿主机上。</li>
<li>docker-ee：收费的</li>
<li>docker-ce：免费的<a id="more"></a></li>
</ul>
<h3 id="docker特点"><a href="#docker特点" class="headerlink" title="docker特点"></a>docker特点</h3><ul>
<li><p>上手快：用户只需要几分钟，就可以把自己的程序“Docker 化”。Docker 依赖于“写时复制” (copy-on-write)模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改” 的境界；随后，就可以创建容器来运行应用程序了。大多数 Docker 容器只需要不到 1 秒中即可 启动。由于去除了管理程序的开销，Docker 容器拥有很高的性能，同时同一台宿主机中也 可以运行更多的容器，使用户尽可能的充分利用系统资源</p>
</li>
<li><p>职责的逻辑分类：使用 Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如 何管理容器。Docker 设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署 的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题(测试环境都是正 常的，上线后出了问题就归结为肯定是运维的问题)”</p>
</li>
<li><p>快速高效的开发生命周期：Docker 的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用 程序具备可移植性，易于构建，并易于协作。(通俗一点说，Docker 就像一个盒子，里面 可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件 件的取。)</p>
</li>
<li><p>鼓励使用面向服务的架构：Docker 还鼓励面向服务的体系结构和微服务架构。Docker 推荐单个容器只运行一个应 用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服 务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序 都变得非常简单，同时也提高了程序的内省性。(当然，可以在一个容器中运行多个应用程 序)</p>
</li>
</ul>
<h3 id="Docker客户端和服务器"><a href="#Docker客户端和服务器" class="headerlink" title="Docker客户端和服务器"></a>Docker客户端和服务器</h3><ul>
<li>Docker 是一个客户端-服务器(C/S)架构程序。Docker 客户端只需要向 Docker 服务器 或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker 提供了 一个命令行工具 Docker 以及一整套 RESTful API。你可以在同一台宿主机上运行 Docker 守护 进程和客户端，也可以从本地的 Docker 客户端连接到运行在另一台宿主机上的远程 Docker 守护进程</li>
</ul>
<h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><ul>
<li>镜像是构建 Docker 的基石。用户基于镜像来运行自己的容器，镜像也是 Docker 生命周 期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构 建出来。例如:<ul>
<li>添加一个文件;</li>
<li>执行一个命令;</li>
<li>打开一个窗口。</li>
</ul>
</li>
<li>也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新</li>
</ul>
<h3 id="Registry镜像注册"><a href="#Registry镜像注册" class="headerlink" title="Registry镜像注册"></a>Registry镜像注册</h3><ul>
<li>Docker 用 Registry 来保存用户构建的镜像。</li>
<li>Registry 分为公共和私有两种。Docker 公司 运营公共的 Registry 叫做 Docker Hub</li>
<li>用户可以在 Docker Hub 注册账号，分享并保存自己的 镜像(说明:在 Docker Hub 下载镜像巨慢，可以自己构建私有的 Registry）</li>
</ul>
<h3 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h3><ul>
<li>Docker 可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容 器即可</li>
<li>容器是基于镜像启动起来的，容器中可以运行一个或多个进程</li>
<li>我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。容器基于 镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务</li>
<li>安装好的一个虚拟机</li>
</ul>
<h3 id="Docker镜像-1"><a href="#Docker镜像-1" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><ul>
<li>Docker 把应用程序及其依赖，打包在 image 文件里面</li>
<li>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例</li>
<li>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在自己操作系统所使用的image 基础上，往里面加入 Apache 服务器，形成你的image</li>
<li>就是一个操作系统文件</li>
</ul>
<h3 id="Docker容器操作"><a href="#Docker容器操作" class="headerlink" title="Docker容器操作"></a>Docker容器操作</h3><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">sudo docker run [option] 镜像名</span><br><span class="line"><span class="deletion">-i 表示以“交互模式”运行容器</span></span><br><span class="line"><span class="deletion">-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。</span></span><br><span class="line">–name 为创建的容器命名</span><br><span class="line"><span class="deletion">-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。</span></span><br><span class="line"><span class="deletion">-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不 会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。</span></span><br><span class="line"><span class="deletion">-p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射</span></span><br><span class="line"><span class="deletion">-e 为容器设置环境变量</span></span><br><span class="line">–network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同</span><br></pre></td></tr></table></figure>

<h4 id="停止或启动容器"><a href="#停止或启动容器" class="headerlink" title="停止或启动容器"></a>停止或启动容器</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">docker container <span class="keyword">stop</span> 容器名或<span class="keyword">ID</span></span><br></pre></td></tr></table></figure>

<h3 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h3><ul>
<li>FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制， 充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务</li>
<li>FastDFS架构包括 <strong>Tracker server</strong> 和 <strong>Storage server</strong>。客户端请求Trackerserver进行过文件上传、下载<ul>
<li>通过<code>Tracker server</code>调度最终由Storage server完成文件上传、下载</li>
</ul>
</li>
<li><strong>Tracker server</strong><ul>
<li>作用是负载均衡和调度,通过Tracker server在文件上传时可以根据一些策略找到Storage server提供文件上传服务。可以将tracker称为<strong>追踪服务器</strong>或 <strong>调度服务器</strong></li>
</ul>
</li>
<li><strong>Storage server</strong><ul>
<li>作用是文件存储,客户端上传的文件最终存储在Storage存储器上,Storageserver没有实现自己的文件系统而是利用操作系统的文件系统来管理文件。可以将storage称为<strong>存储服务器</strong></li>
</ul>
</li>
</ul>
<h3 id="centos部署docker"><a href="#centos部署docker" class="headerlink" title="centos部署docker"></a>centos部署docker</h3><ul>
<li>安装docker</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加docker-repo源</span></span><br><span class="line">yum install docker-ce</span><br><span class="line"><span class="meta">#</span><span class="bash"> 尝试安装docker-ce</span></span><br><span class="line">yum erase docker-common-2:1.13.1-96.gitb2f74b2.el7.centos.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已安装的docker</span></span><br></pre></td></tr></table></figure>

<ul>
<li>开启docker服务</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure>

<ul>
<li>查看docker镜像<ul>
<li>REPOSITORY：镜像所在的仓库名称</li>
<li>TAG：镜像标签</li>
<li>IMAGEID：镜像ID</li>
<li>CREATED：镜像的创建日期(不是获取该镜像的日期)</li>
<li>SIZE：镜像大小</li>
</ul>
</li>
</ul>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">image</span> <span class="keyword">ls</span></span><br><span class="line">docker  rm</span><br></pre></td></tr></table></figure>

<ul>
<li>拉取镜像及删除镜像</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">image</span> pull delron/fastdfs</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面代码中，docker image pull是抓取 image 文件的命令。delron/fastdfs是 image 文件在仓库里面的位置，其中delron是 image 文件所在的组，fastdfs是 image 文件的名字</p>
</blockquote>
<ul>
<li>开启fastdfs的tracker服务</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">docker run -dti <span class="params">--network=host</span> <span class="params">--name</span> tracker -v <span class="string">/var/fdfs/tracker</span>:<span class="string">/var/fdfs</span> delron/fastdfs tracker</span><br></pre></td></tr></table></figure>

<ul>
<li>开启fastdfs的storage服务</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -dti <span class="attribute">--network</span>=host --name storage -e <span class="attribute">TRACKER_SERVER</span>=47.97.210.11:22122 -v /var/fdfs/storage:/var/fdfs delron/fastdfs storage</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭docker容器</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">stop</span> container_id</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前运行的容器</li>
</ul>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">container</span> <span class="keyword">ls</span></span><br></pre></td></tr></table></figure>

<h2 id="Fastdfs使用"><a href="#Fastdfs使用" class="headerlink" title="Fastdfs使用"></a>Fastdfs使用</h2><h3 id="python客户端"><a href="#python客户端" class="headerlink" title="python客户端"></a>python客户端</h3><ul>
<li>下载安装<code>fastdfs</code>的<code>python</code>客户端</li>
</ul>
<blockquote>
<p><a href="https://github.com/JaceHo/fdfs_client-py" target="_blank" rel="noopener">https://github.com/JaceHo/fdfs_client-py</a></p>
</blockquote>
<ul>
<li>windows兼容问题</li>
</ul>
<blockquote>
<p>解压下载好的压缩包，提取fdfs_client文件夹</p>
</blockquote>
<ul>
<li>将该文件夹放入python的三方包目录下</li>
</ul>
<blockquote>
<p>C:\Python37\Lib\site-packages</p>
</blockquote>
<ul>
<li>安装所需的两个额外模块</li>
</ul>
<blockquote>
<p>pip install mutagen<br>pip isntall requests </p>
</blockquote>
<ul>
<li>注释fdfs_client/storage_client.py文件中的第十二行</li>
</ul>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">from</span> fdfs_client.sendfile <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<ul>
<li>创建client.conf文件到django下</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># project/client.conf</span></span><br><span class="line"><span class="comment"># connect timeout in seconds</span></span><br><span class="line"><span class="comment"># default value is 30s</span></span><br><span class="line">connect_timeout=<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network timeout in seconds</span></span><br><span class="line"><span class="comment"># default value is 30s</span></span><br><span class="line">network_timeout=<span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the base path to store log files</span></span><br><span class="line">base_path=\static <span class="comment">#FastDFS客户端存放日志文件的目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tracker_server can ocur more than once, and tracker_server format is</span></span><br><span class="line"><span class="comment">#  "host:port", host can be hostname or ip address</span></span><br><span class="line">tracker_server=<span class="number">123.57</span><span class="number">.61</span><span class="number">.168</span>:<span class="number">22122</span> <span class="comment">#运行tracker服务的机器IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#standard log level as syslog, case insensitive, value list:</span></span><br><span class="line"><span class="comment">### emerg for emergency</span></span><br><span class="line"><span class="comment">### alert</span></span><br><span class="line"><span class="comment">### crit for critical</span></span><br><span class="line"><span class="comment">### error</span></span><br><span class="line"><span class="comment">### warn for warning</span></span><br><span class="line"><span class="comment">### notice</span></span><br><span class="line"><span class="comment">### info</span></span><br><span class="line"><span class="comment">### debug</span></span><br><span class="line">log_level=info</span><br><span class="line"></span><br><span class="line"><span class="comment"># if use connection pool</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">use_connection_pool = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># connections whose the idle time exceeds this time will be closed</span></span><br><span class="line"><span class="comment"># unit: second</span></span><br><span class="line"><span class="comment"># default value is 3600</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">connection_pool_max_idle_time = <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if load FastDFS parameters from tracker server</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line">load_fdfs_parameters_from_tracker=false</span><br><span class="line"></span><br><span class="line"><span class="comment"># if use storage ID instead of IP address</span></span><br><span class="line"><span class="comment"># same as tracker.conf</span></span><br><span class="line"><span class="comment"># valid only when load_fdfs_parameters_from_tracker is false</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">use_storage_id = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify storage ids filename, can use relative or absolute path</span></span><br><span class="line"><span class="comment"># same as tracker.conf</span></span><br><span class="line"><span class="comment"># valid only when load_fdfs_parameters_from_tracker is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">storage_ids_filename = storage_ids.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#HTTP settings</span></span><br><span class="line">http.tracker_server_port=<span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#use "#include" directive to include HTTP other settiongs</span></span><br><span class="line"><span class="comment">##include http.conf</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上传测试代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#client.upload_by_filename(文件名)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line">client = Fdfs_client(<span class="string">"client.conf"</span>)</span><br><span class="line"></span><br><span class="line">ret = client.upload_by_filename(<span class="string">'1.jpg'</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中返回结果中的Remote file_id就是上传成功的保存文件名</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	'Group name': 'group1', </span><br><span class="line">	'Remote file_id': 'group1\\M00/00/00/rBEUWlz_HzSAPPzBAAQ2UAPajsU035.jpg', </span><br><span class="line">	'Status': 'Upload successed.', </span><br><span class="line">	'Local file name': '1.jpg', </span><br><span class="line">	'Uploaded size': '269.00KB', </span><br><span class="line">	'Storage IP': '123.57.61.168\x008'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Django文件引擎"><a href="#Django文件引擎" class="headerlink" title="Django文件引擎"></a><code>Django</code>文件引擎</h3><ul>
<li>重构<code>django</code>文件上传引擎</li>
</ul>
<blockquote>
<p>存储类中必须实现_open()和_save()方法,以及任何后续使用中可能用到的其他方法。</p>
</blockquote>
<ul>
<li><code>_open(name, mode = ‘rb’)</code>：被<code>Storage.open()</code>调用,在打开文件时被调用</li>
<li><code>save(name, content)</code>：被<code>Storage.save()</code>调用,name是传入的文件名,<code>content</code>是<code>Django</code>接收到的文件内容,该方法需要将<code>content</code>文件内容保存。<code>Django</code>会将该方法的返回值保存到数据库中对应的文件字段,也就是说该方法应该返回要保存在数据库中的文件名信息。</li>
<li><code>exists(name)</code>：如果名为<code>name</code>的文件在文件系统中存在，按返回<code>True</code>，否则返回<code>False</code></li>
<li><code>url(name)</code>：返回文件的完整访问<code>URL</code></li>
<li><code>delete(name)</code>：删除<code>name</code>文件</li>
<li><code>listdir(path)</code>：列出指定路径的文件</li>
<li><code>size(name)</code>：返回<code>name</code>文件的总大小</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.core.files.storage <span class="keyword">import</span> Storage</span><br><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastDFSStroage</span><span class="params">(Storage)</span>:</span></span><br><span class="line">    <span class="string">"""定义FastDFS客户端类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, base_url = None, client_conf = None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化对象</span></span><br><span class="line"><span class="string">        :param base_url:</span></span><br><span class="line"><span class="string">        :param client_conf:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> base_url <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            base_url = settings.FDAS_URL</span><br><span class="line">            <span class="comment"># 'http://123.57.61.168:8888' </span></span><br><span class="line">        self.base_url = base_url</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> client_conf <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            client_conf = settings.FDFS_CLIENT_CONF</span><br><span class="line">            <span class="comment"># FDFS_CLIENT_CONF = os.path.join(BASE_DIR, 'client.conf')</span></span><br><span class="line">        self.client_conf = client_conf</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_open</span><span class="params">(self, name, mode = <span class="string">'rb'</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        打开文件</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :param mode:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_save</span><span class="params">(self, name, content)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        保存文件</span></span><br><span class="line"><span class="string">        :param name: 传入文件名</span></span><br><span class="line"><span class="string">        :param content: 文件内容</span></span><br><span class="line"><span class="string">        :return:保存到数据库中的FastDFSDE文件名</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        client = Fdfs_client(self.client_conf)</span><br><span class="line">        ret = client.upload_by_buffer(content.read())</span><br><span class="line">        <span class="keyword">if</span> ret.get(<span class="string">"Status"</span>) != <span class="string">"Upload successed."</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"upload file failed"</span>)</span><br><span class="line">        file_name = ret.get(<span class="string">"Remote file_id"</span>)</span><br><span class="line">        <span class="keyword">return</span> file_name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exists</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        检查文件是否重复, FastDFS自动区分重复文件</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">url</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取name文件的完整url</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.base_url + name</span><br></pre></td></tr></table></figure>

<ul>
<li>将文件引擎设置到settings中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#settings.py</span></span><br><span class="line">DEFAULT_FILE_STORAGE = <span class="string">'goods.views.FastDFSStorage'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上传成功后的访问地址</li>
</ul>
<blockquote>
<p>在服务器IP地址的<code>8888</code>端口，记得打开对应阿里云的端口规则</p>
</blockquote>
<ul>
<li>注意：在新版本的Remote file_id，由<code>\\</code>斜杠变为了<code>/</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">'Remote file_id'</span>].replace(<span class="string">'\\'</span>,<span class="string">'/'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>&#39;Jwt的应用&#39;</title>
    <url>/Python/Jwt/</url>
    <content><![CDATA[<h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><p>​     Json web token（JWT）是为了网络应用环境间传递声明而执行的一种基于JSON的开发标准（RFC 7519），该token被设计为紧凑且安全的，特别适用于分布式站点的单点登陆（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。<a id="more"></a></p>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>   说起JWT，我们应该来谈一谈基于token的认证和传统的Session认证的区别。</p>
<h2 id="传统的session认证"><a href="#传统的session认证" class="headerlink" title="传统的session认证"></a>传统的session认证</h2><p>​    我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发送的请求，所以为了让我们的应用能识别是哪个用户发出的，我们只能在服务器存储一份用户登陆的信息，这份登陆信息会在响应时传递给服务器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的英哟个就能识别请求来自哪个用户了，这就是传统的基于sessino认证</p>
<p>​       但是这种基于session的认证使应用本身很难得扩展，随着不用客户端的增加，独立的服务器已无法承载更多的用户，而这个时候基于session认证应用的问题就会暴露出来</p>
<h2 id="基于session认证所显露的问题"><a href="#基于session认证所显露的问题" class="headerlink" title="基于session认证所显露的问题"></a>基于session认证所显露的问题</h2><p>​       Session：每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大</p>
<p>​        扩展性：用户认证之后，服务端做认证记录，如果认证的记录被保存在内存的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，响应的限制了负载均衡器的能力，也意味着限制了应用的扩展性</p>
<p>​        CSRF：因为是基于cookie来进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
<h2 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h2><p>​    基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或会话信息。这也就意味着机遇tokent认证机制的应用不需要去考虑用户在哪一台服务器登陆了，这就为应用的扩展提供了便利</p>
<p>​     流程是这样的</p>
<ul>
<li>用户使用用户名密码请求服务器</li>
<li>服务器进行验证用户信息</li>
<li>服务器通过验证发送给用户一个token</li>
<li>客户端存储token，并在每次请求时附加这个token值</li>
<li>服务器验证token，并返回数据</li>
</ul>
<p>​      这个token必须要在每次请求时发送给服务器，它应该保存在请求头中，另外，服务器要支持CORS（跨来源资源共享）策略，一般我们在服务端这么做就可以了 Access-Control-Allow-Origin：*</p>
<h2 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h2><p>​      JWT是由三部分构成，将这三段信息文本用链接构成了JWT字符串。就像这样</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">eyJ<span class="number">0</span>eXAiOiJKV<span class="number">1</span>QiLCJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiJ9</span>.eyJ<span class="attr">Vc2</span>VySWQiOjEyMywiVX<span class="symbol">Nlck5</span>hbWUiOiJhZ<span class="name">G1</span>pbiJ<span class="number">9.</span>Qjw<span class="number">1</span>epD<span class="number">5</span>P<span class="number">6</span>p<span class="number">4</span>Yy<span class="number">2</span>yju<span class="number">3</span>-fkq<span class="number">28</span>Pddz<span class="symbol">nqRj3</span>ESfALQy_U</span><br></pre></td></tr></table></figure>

<p>​    第一部分我们称它为头部（header）第二部分我们称其为载荷（payload，类似于飞机上承载的物品），第三部分是签证（signature）</p>
<h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>​      JWT的头部承载的两部分信息：</p>
<ul>
<li><p>声明类型，这里是jwt</p>
</li>
<li><p>声明加密的算法，通常直接使用HMAC SHA256</p>
<p> 完整的头部就像下面这样的JSON</p>
</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     'typ':'JWT',</span><br><span class="line">     'alg':'HS256'  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    然后将头部进行base64加密（该加密是可以对称解密的），构成了第一部分</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">eyJ<span class="number">0</span>eXAiOiJKV<span class="number">1</span>QiLCJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiJ9</span></span><br></pre></td></tr></table></figure>

<h2 id="plyload"><a href="#plyload" class="headerlink" title="plyload"></a>plyload</h2><p>​      载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p>
<ul>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明 </li>
</ul>
<p>​     标注中注册的声明（建议不强制使用）</p>
<ul>
<li>iss：jwt签发者</li>
<li>sub：jwt所面向的用户</li>
<li>aud：接收jwt的一方</li>
<li>exp：jwt的过期时间，这个过期时间必须大于签发时间</li>
<li>nbf：定义在什么时间之前，该jwt都是不可用的</li>
<li>iat：jwt的签发时间</li>
<li>jti：jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击 </li>
</ul>
<p>​    <strong>公共的声明：</strong></p>
<p>​       公共的声明可以添加任何的信息，一般添加用户的相关信息或其它业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密；</p>
<p>​     <strong>私有的声明</strong></p>
<p>​         私有的声明是提供者和消费者功能定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为名文信息。</p>
<p>​     定义一个payload</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    然后将其base64加密，得到jwt的一部分</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">eyJzdWIiOiIxMj<span class="name">M0</span><span class="symbol">NTY3</span>ODkwIiwibmFtZSI<span class="number">6</span>Ikpva<span class="name">G4</span>gR<span class="name">G9</span>lIiwiYWRtaW<span class="number">4</span>iO<span class="symbol">nRydWV9</span></span><br></pre></td></tr></table></figure>

<p>Signature</p>
<p>​    jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<ul>
<li>header(base64后的)</li>
<li>payload(base64后的)</li>
<li>secred     </li>
</ul>
<p>​       这个部分需要base64加密后的header和base64加密后的payload使用“.”连接组成的字符串，然后通过header中声明的加密方式进行加secret组合加密，然后就构成了jwt的第三部分</p>
<p>​      </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var encodedString = base64<span class="constructor">UrlEncode(<span class="params">header</span>)</span> + <span class="character">'.'</span> + base64<span class="constructor">UrlEncode(<span class="params">payload</span>)</span>;</span><br><span class="line">var signature = <span class="constructor">HMACSHA256(<span class="params">encodedString</span>, '<span class="params">secret</span>')</span>; <span class="comment">// TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure>

<p>​    将这三部分用“.”连接成一个完整的字符串，构成了最终的jwt：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiIsInR5</span>cCI<span class="number">6</span>IkpX<span class="attr">VCJ9</span>.eyJzdWIiOiIxMj<span class="name">M0</span><span class="symbol">NTY3</span>ODkwIiwibmFtZSI<span class="number">6</span>Ikpva<span class="name">G4</span>gR<span class="name">G9</span>lIiwiYWRtaW<span class="number">4</span>iO<span class="symbol">nRydWV9</span>.TJVA<span class="number">95</span><span class="keyword">Or</span><span class="name">M7</span>E<span class="number">2</span>cBab<span class="number">30</span>RMHrHDcEfxjoYZgeFO<span class="symbol">NFh7</span>HgQ</span><br></pre></td></tr></table></figure>

<p>​     注意：secret是保存在服务器端的，jwt的签发也是在服务端的，secret就是用来进行jwt的签发和jwt的验证，所以它就是你服务端的私钥，在任何场景都不应该流露出去，一旦客户端得知这个secret，那就意味着客户端可以自我签发jwt了</p>
<p> 应用 </p>
<p>​      一般是在请求头里加入Authorization，并加上Bearer标注：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">fetch</span>(<span class="string">'api/user/1'</span>, &#123;</span><br><span class="line">  <span class="attribute">headers</span>: &#123;</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">'Bearer '</span> + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​       服务端会验证token，如果验证通过就会返回相应的资源，整个流程就是这样</p>
<p><img src="https://images2017.cnblogs.com/blog/1147658/201711/1147658-20171118202151718-1630139158.png" alt="img"></p>
<p>   总结</p>
<p>​      优点：</p>
<ul>
<li>因为json的通用性，所以JWT是可以跨语言支持的，像C#，JavaScript，NodeJS，PHP等许多语言都可以使用</li>
<li>因为由了payload部分，所以JWT可以在自身存储一些其它业务逻辑所必要的非敏感信息</li>
<li>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的</li>
<li>它不需要在服务端保存会话信息，所以它易于应用的扩展</li>
</ul>
<p>​       安全相关</p>
<ul>
<li>不应该在jwt的payload部分存储敏感信息，因为该部分是客户端可解密的部分</li>
<li>保护好secret私钥。该私钥非常重要</li>
<li>如果可以，请使用https协议</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="comment">#加密</span></span><br><span class="line"><span class="comment">#第一个参数 用户敏感信息  第二个参数 密钥  第三个参数 加密算法 hs256</span></span><br><span class="line">encode_jwt=jwt.encode(&#123;<span class="string">'uid'</span>:<span class="string">'1'</span>&#125;,<span class="string">'123'</span>,algorithm=<span class="string">'HS256'</span>)</span><br><span class="line"><span class="comment">#返回一个字节码  加密后两个点分割，分成三部分。第一部分token头部，声明它是token  第二部分 载荷 存用户敏感信息  第三部分 算法</span></span><br><span class="line"><span class="comment">#转码  字符串  进行解密</span></span><br><span class="line">encode_str=str(encode_jwt,<span class="string">'utf-8'</span>)  <span class="comment">#强转， 声明编码python3 utf-8</span></span><br><span class="line"><span class="comment">#变成可用字符串</span></span><br><span class="line">print(encode_str)</span><br><span class="line"><span class="comment">#解码</span></span><br><span class="line">de_Code=jwt.decode(<span class="string">'加密后的字符串'</span>,<span class="string">'密钥'</span>，<span class="string">'声明算法'</span>)   (<span class="string">'12dcs'</span>,<span class="string">'123'</span>,algorithms=[<span class="string">'HS256'</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#声明载荷</span></span><br><span class="line">improt datetime</span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line">过期时间  时间戳  敏感信息</span><br><span class="line">playlod=&#123;</span><br><span class="line">    <span class="string">'exp'</span>:int((datetime.datetime.now()) +datetime.timedelta(seconds=<span class="number">20</span>).timestap()),<span class="string">'data'</span>:&#123;<span class="string">'uid'</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#加密token</span></span><br><span class="line">encode_jwt=jwt.encode(playload,<span class="string">'123'</span>,algorithm=<span class="string">'HS256'</span>)</span><br><span class="line"><span class="comment">#解码</span></span><br><span class="line">algorithms=[<span class="string">'HS256'</span>]</span><br><span class="line"><span class="comment">#判断token过期</span></span><br><span class="line">datetime.datetime.now()</span><br><span class="line">如果当前时间大于过期时间则token过期</span><br></pre></td></tr></table></figure>



<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#装饰器就是一个封装的闭包</span></span><br><span class="line"><span class="comment">#自定义装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_de</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">decortor</span><span class="params">(view_func)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">_wrapped_view</span><span class="params">(request,*args,**kwargs)</span>:</span></span><br><span class="line">				<span class="comment">#此处写判断逻辑</span></span><br><span class="line">				print(<span class="string">'请求开始'</span>)</span><br><span class="line">				<span class="keyword">return</span> view_func(request,*args,**kwargs)</span><br><span class="line">		<span class="keyword">return</span> _wrapped_viw</span><br><span class="line">	<span class="keyword">return</span> decoror</span><br><span class="line">	</span><br><span class="line"><span class="meta">@my_de()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">haha</span><span class="params">(name)</span>:</span></span><br><span class="line">	print(<span class="string">'谁是 %s'</span> name)</span><br><span class="line">haha(<span class="string">'张三'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Pymsql</title>
    <url>/Mysql/Pymsql/</url>
    <content><![CDATA[<h6 id="什么是PyMysql"><a href="#什么是PyMysql" class="headerlink" title="什么是PyMysql"></a>什么是PyMysql</h6><p>Pymsql是在Python3.x版本中用于连接Mysql服务器的一个库，Python2中则适用mysqldb</p>
<h6 id="Pymsql安装"><a href="#Pymsql安装" class="headerlink" title="Pymsql安装"></a>Pymsql安装</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PyMySQL下载地址：https://github.com/PyMySQL/PyMySQL</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h6 id="适用pip命令进行安装"><a href="#适用pip命令进行安装" class="headerlink" title="适用pip命令进行安装"></a>适用pip命令进行安装</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install Pymsql</span><br></pre></td></tr></table></figure>

<h6 id="使用git命令下载安装包安装"><a href="#使用git命令下载安装包安装" class="headerlink" title="使用git命令下载安装包安装"></a>使用git命令下载安装包安装</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/PyMySQL/PyMySQL</span><br><span class="line">$ cd PyMySQL/</span><br><span class="line">$ python3 setup.py install</span><br></pre></td></tr></table></figure>

<h6 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入Pymsql库</span></span><br><span class="line"><span class="keyword">import</span> Pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#打开数据库连接</span></span><br><span class="line">db = pymysql.connect(host=<span class="string">"localhost"</span>,user=<span class="string">"root"</span>,password=<span class="string">""</span>,db=<span class="string">"mydb"</span>,charset=<span class="string">"utf8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 cursor() 方法创建一个游标对象 cursor</span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 execute()  方法执行 SQL 查询 </span></span><br><span class="line">cursor.execute(<span class="string">"SELECT VERSION()"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 fetchone() 方法获取单条数据.</span></span><br><span class="line">data = cursor.fetchone()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Database version : %s "</span> % data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据库连接</span></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<h6 id="执行数据查询"><a href="#执行数据查询" class="headerlink" title="执行数据查询"></a>执行数据查询</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#打开数据库连接</span></span><br><span class="line">db = pymysql.connect(host=<span class="string">"localhost"</span>,user=<span class="string">"root"</span>,password=<span class="string">""</span>,db=<span class="string">"mydb"</span>,charset=<span class="string">"utf8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用cursor()方法创建一个游标对象cursor</span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义查询sql语句</span></span><br><span class="line"><span class="comment">#sql = "select * from stu"</span></span><br><span class="line">sql = <span class="string">"select * from stu where classid='%s'"</span>%(<span class="string">"python03"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 使用execute()方法执行SQL查询 </span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"本次查询条数："</span>,cursor.rowcount)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    # 使用fetchone()方法获取单条数据.</span></span><br><span class="line"><span class="string">    while True:</span></span><br><span class="line"><span class="string">        data = cursor.fetchone();</span></span><br><span class="line"><span class="string">        if data == None:</span></span><br><span class="line"><span class="string">            break;</span></span><br><span class="line"><span class="string">        print (data)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment">#使用fetchall()获取所有结果</span></span><br><span class="line">    alist = cursor.fetchall()</span><br><span class="line">    <span class="keyword">for</span> vo <span class="keyword">in</span> alist:</span><br><span class="line">        print(vo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">    print(<span class="string">"SQL执行错误，原因："</span>,err)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据库连接</span></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<h6 id="执行数据添加"><a href="#执行数据添加" class="headerlink" title="执行数据添加"></a>执行数据添加</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#打开数据库连接</span></span><br><span class="line">db = pymysql.connect(host=<span class="string">"localhost"</span>,user=<span class="string">"root"</span>,password=<span class="string">""</span>,db=<span class="string">"mydb"</span>,charset=<span class="string">"utf8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用cursor()方法创建一个游标对象cursor</span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义添加sql语句</span></span><br><span class="line">data = (<span class="string">"uu100"</span>,<span class="number">28</span>,<span class="string">'w'</span>,<span class="string">'python05'</span>)</span><br><span class="line">sql = <span class="string">"insert into stu(name,age,sex,classid) values('%s','%d','%s','%s')"</span>%(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 使用execute()方法执行SQL </span></span><br><span class="line">    m = cursor.execute(sql)</span><br><span class="line">    <span class="comment"># 事务提交</span></span><br><span class="line">    db.commit()</span><br><span class="line">    print(<span class="string">"成功操作条数："</span>,m)</span><br><span class="line">    <span class="comment">#print("成功操作条数：",cursor.rowcount)</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">    <span class="comment">#事务回滚</span></span><br><span class="line">    db.rollback()</span><br><span class="line">    print(<span class="string">"SQL执行错误，原因："</span>,err)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据库连接</span></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<h6 id="执行删除操作"><a href="#执行删除操作" class="headerlink" title="执行删除操作"></a>执行删除操作</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#打开数据库连接</span></span><br><span class="line">db = pymysql.connect(host=<span class="string">"localhost"</span>,user=<span class="string">"root"</span>,password=<span class="string">""</span>,db=<span class="string">"mydb"</span>,charset=<span class="string">"utf8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用cursor()方法创建一个游标对象cursor</span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义删除sql语句</span></span><br><span class="line">sql = <span class="string">"delete from stu where id=%d"</span>%(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 使用execute()方法执行SQL </span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    <span class="comment"># 事务提交</span></span><br><span class="line">    db.commit()</span><br><span class="line">    print(<span class="string">"成功删除条数："</span>,cursor.rowcount)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">    <span class="comment">#事务回滚</span></span><br><span class="line">    db.rollback()</span><br><span class="line">    print(<span class="string">"SQL执行错误，原因："</span>,err)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据库连接</span></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<h6 id="数据库查询操作"><a href="#数据库查询操作" class="headerlink" title="数据库查询操作"></a>数据库查询操作</h6><ul>
<li>Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。<ul>
<li>fetchone(): 该方法获取下一个查询结果集。结果集是一个对象，最后返回None结束</li>
<li>fetchall(): 接收全部的返回结果行.</li>
</ul>
</li>
<li>rowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。</li>
</ul>
<h6 id="pip命令"><a href="#pip命令" class="headerlink" title="pip命令"></a>pip命令</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列出已安装的包：</span><br><span class="line">    $ pip list</span><br><span class="line">    $ pip freeze     <span class="comment"># 查看自己安装的</span></span><br><span class="line"></span><br><span class="line">安装软件（安装特定版本的package，通过使用==, &amp;gt;=, &amp;lt;=, &amp;gt;, &amp;lt;来指定一个版本号）**</span><br><span class="line">    $ pip install SomePackage</span><br><span class="line">    $ pip install <span class="string">'Markdown&lt;2.0'</span></span><br><span class="line">    $ pip install <span class="string">'Markdown&gt;2.0,&lt;2.0.3'</span></span><br><span class="line"></span><br><span class="line">卸载软件pip uninstall SomePackage</span><br><span class="line">    $ pip uninstall SomePackage</span><br><span class="line"></span><br><span class="line">下载所需的软件包：</span><br><span class="line">    $ pip download SomePackage -d directory </span><br><span class="line">    例如下载PyMySQL软件包</span><br><span class="line">    $ pip download PyMySQL -d D:/pypackage</span><br><span class="line"></span><br><span class="line">安装下载好的软件包文件</span><br><span class="line">    $ pip install 目录/软件包文件名</span><br><span class="line">    如安装PyMySQL软件包</span><br><span class="line">    $ pip3<span class="number">.6</span> install D:/pypackage/PyMySQL<span class="number">-0.7</span><span class="number">.11</span>-py2.py3-none-any.whl</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Pymsql</tag>
      </tags>
  </entry>
  <entry>
    <title>添加萌萌的宠物live2d</title>
    <url>/Happy/%E6%B7%BB%E5%8A%A0%E8%90%8C%E8%90%8C%E7%9A%84%E5%AE%A0%E7%89%A9live2d/</url>
    <content><![CDATA[<h1 id="Hexo-Next-添加萌萌的宠物live2d"><a href="#Hexo-Next-添加萌萌的宠物live2d" class="headerlink" title="Hexo Next 添加萌萌的宠物live2d"></a>Hexo Next 添加萌萌的宠物live2d</h1><h5 id="添加萌宠来装饰Hexo站点-使用到的插件hexo-helper-live2d"><a href="#添加萌宠来装饰Hexo站点-使用到的插件hexo-helper-live2d" class="headerlink" title="添加萌宠来装饰Hexo站点, 使用到的插件hexo-helper-live2d"></a>添加萌宠来装饰Hexo站点, 使用到的插件hexo-helper-live2d</h5><p>添加萌宠</p>
<h6 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1.安装插件"></a>1.安装插件</h6><p>命令行cmd进入站点文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd .\TestBlog\</span><br><span class="line"></span><br><span class="line">npm install hexo-helper-live2d --save</span><br></pre></td></tr></table></figure>



<p>下载完插件后, 使用hexo s启动服务器发现左下角已经有live2d模型了</p>
<h6 id="2-在站点配置文件-config-yml中添加配置"><a href="#2-在站点配置文件-config-yml中添加配置" class="headerlink" title="2.在站点配置文件_config.yml中添加配置"></a>2.在站点配置文件_config.yml中添加配置</h6><p>配置信息可以设置live2d的位置、大小、透明度等</p>
<p>更多配置信息可看Github hexo-helper-live2d上的介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  model:</span><br><span class="line">    # 这是白猫的模型</span><br><span class="line">    use: live2d-widget-model-tororo</span><br><span class="line">  display:</span><br><span class="line">    # 设置模型的位置</span><br><span class="line">    position: right</span><br><span class="line">    width: 120</span><br><span class="line">    height: 240</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 1</span><br><span class="line">    opacityOnHover: 1</span><br></pre></td></tr></table></figure>



<h6 id="3-下载你喜欢的模型"><a href="#3-下载你喜欢的模型" class="headerlink" title="3.下载你喜欢的模型"></a>3.下载你喜欢的模型</h6><p>命令行cmd进入站点文件夹, 使用npm install {your model’s package name}下载你喜欢的模型</p>
<p>模型列表<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">模型预览</a></p>
<p>效果如图</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">比如下载  这是猫的</span><br><span class="line">tororo npm install live2d-widget-model-tororo</span><br></pre></td></tr></table></figure>

<p>完成上述，你会发现有一个可爱的小老虎</p>
]]></content>
      <categories>
        <category>Happy</category>
      </categories>
      <tags>
        <tag>Happy</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫代理爬取</title>
    <url>/uncategorized/%E7%88%AC%E8%99%AB%E4%BB%A3%E7%90%86%E7%88%AC%E5%8F%96/</url>
    <content><![CDATA[<h5 id="使用代理爬取-信息"><a href="#使用代理爬取-信息" class="headerlink" title="使用代理爬取 信息"></a>使用代理爬取 信息</h5><h3 id="14-1-目标："><a href="#14-1-目标：" class="headerlink" title="14.1 目标："></a>14.1 目标：</h3><ul>
<li>本节目标是利用代理爬取微信公众号的文章信息，从中提取标题、摘要、发布日期、公众号以及url地址等内容。</li>
<li>本节爬取的是搜索关键字为<code>python</code>的，类别为<code>微信</code>的所有文章信息，并将信息存储到MongoDB中。</li>
<li>URL地址：<a href="http://weixin.sogou.com/weixin?type=2&amp;query=python&amp;ie=utf8&amp;s_from=input" target="_blank" rel="noopener">http://weixin.sogou.com/weixin?type=2&amp;query=python&amp;ie=utf8&amp;s_from=input</a><a id="more"></a>

</li>
</ul>
<h3 id="14-2-准备工作："><a href="#14-2-准备工作：" class="headerlink" title="14.2 准备工作："></a>14.2 准备工作：</h3><ul>
<li>首先对要爬取的微信公众号的文章信息进行分析，确定url地址。</li>
<li>分析要爬取的信息加载方式，确定属性普通加载（在响应里使用xpath或css解析）。</li>
<li>分析如何获取更多页信息的爬取。就是如何跳转下一页。(没有登录的用户只能看到10页，登陆后才可看到其他页)</li>
<li>本次案例需要使用的Python库：Scrapy、requests、pymongo。</li>
<li>在MongoDB中创建一个数据库<code>wenxin</code>，让后在此库中创建一个集合<code>wx</code>，最后开启MongoDB数据库</li>
</ul>
<h3 id="14-3-具体实现："><a href="#14-3-具体实现：" class="headerlink" title="14.3 具体实现："></a>14.3 具体实现：</h3><h4 id="①-创建项目"><a href="#①-创建项目" class="headerlink" title="① 创建项目"></a>① 创建项目</h4><ul>
<li>首先新建项目，名为weixin：</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scrapy startproject weixin</span></span><br></pre></td></tr></table></figure>

<ul>
<li>进入项目weixin目录下，创建一个Spider（爬虫类wx）：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">cd</span> <span class="selector-tag">weixin</span></span><br><span class="line"><span class="selector-tag">scrapy</span> <span class="selector-tag">genspider</span> <span class="selector-tag">wx</span> <span class="selector-tag">weixin</span><span class="selector-class">.sogou</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure>

<ul>
<li>进入settings.py的配置文件：将ROBOTSTXT_OBEY改为false，忽略爬虫协议</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">ROBOTSTXT_OBEY</span> = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="②-定义Item类"><a href="#②-定义Item类" class="headerlink" title="② 定义Item类"></a>② 定义Item类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义信息封装类（标题、摘要、公众号、时间、URL地址）</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WxItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    collection = ‘wx’</span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    content = scrapy.Field()</span><br><span class="line">    nickname = scrapy.Field()</span><br><span class="line">    date = scrapy.Field()</span><br><span class="line">    url = scrapy.Field()</span><br></pre></td></tr></table></figure>

<h4 id="③-解析页面"><a href="#③-解析页面" class="headerlink" title="③ 解析页面"></a>③ 解析页面</h4><ul>
<li>进入spider/wx.py文件中编写，代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> weixin.items <span class="keyword">import</span> WxItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WxSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'wx'</span></span><br><span class="line">    allowed_domains = [<span class="string">'weixin.sogou.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://weixin.sogou.com/weixin?query=python&amp;type=2&amp;page=1&amp;ie=utf8'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="comment">#解析出当前页面中的所有文章信息</span></span><br><span class="line">        ullist = response.selector.css(<span class="string">"ul.news-list li"</span>)</span><br><span class="line">        <span class="comment">#遍历文章信息</span></span><br><span class="line">        <span class="keyword">for</span> ul <span class="keyword">in</span> ullist:</span><br><span class="line">            <span class="comment">#解析具体信息并封装到item中</span></span><br><span class="line">            item = WxItem()</span><br><span class="line">            item[<span class="string">'title'</span>] = ul.css(<span class="string">"h3 a"</span>).re_first(<span class="string">"&lt;a.*?&gt;(.*?)&lt;/a&gt;"</span>)  </span><br><span class="line">            item[<span class="string">'content'</span>] = ul.css(<span class="string">"p.txt-info::text"</span>).extract_first()</span><br><span class="line">            item[<span class="string">'nickname'</span>] = ul.css(<span class="string">"a.account::text"</span>).extract_first()</span><br><span class="line">            item[<span class="string">'date'</span>] = ul.re_first(<span class="string">"document.write\(timeConvert\('([0-9]+)'\)\)"</span>)</span><br><span class="line">            item[<span class="string">'url'</span>] = ul.css(<span class="string">"h3 a::attr(href)"</span>).extract_first()</span><br><span class="line">            print(item)</span><br><span class="line">            <span class="comment"># 交给pipelines（item管道）处理</span></span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">        <span class="comment">#解析出下一頁的url地址</span></span><br><span class="line">        next_url = response.selector.css(<span class="string">"#sogou_next::attr(href)"</span>).extract_first()</span><br><span class="line">        <span class="comment">#判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> next_url:</span><br><span class="line">            url = response.urljoin(next_url) <span class="comment">#构建绝对url地址</span></span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=url,callback=self.parse) <span class="comment">#交给调度去继续爬取下一页信息</span></span><br></pre></td></tr></table></figure>

<h4 id="④-存储结果"><a href="#④-存储结果" class="headerlink" title="④ 存储结果"></a>④ 存储结果</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">''' 完成MongoDB数据库对Item信息的存储'''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mongo_uri, mongo_db)</span>:</span></span><br><span class="line">        <span class="string">'''对象初始化'''</span></span><br><span class="line">        self.mongo_uri = mongo_uri</span><br><span class="line">        self.mongo_db = mongo_db</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="string">'''通过依赖注入方式实例化当前类，并返回，参数是从配置文件获取MongoDB信息'''</span></span><br><span class="line">        <span class="keyword">return</span> cls(mongo_uri=crawler.settings.get(<span class="string">'MONGO_URI'</span>), mongo_db=crawler.settings.get(<span class="string">'MONGO_DB'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        <span class="string">'''Spider开启自动调用此方法，负责连接MongoDB，并选择数据库'''</span></span><br><span class="line">        self.client = pymongo.MongoClient(self.mongo_uri)</span><br><span class="line">        self.db = self.client[self.mongo_db]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="string">'''选择对应集合并写入Item信息'''</span></span><br><span class="line">        self.db[item.collection].insert(dict(item))</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        <span class="string">'''Spider关闭时自动调用，负责关闭MongoDB的连接'''</span></span><br><span class="line">        self.client.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件settings.py信息：（开启MongoPipeline管道类，设置MongoDB的连接信息）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="string">'scrapyseleniumtest.pipelines.MongoPipeline'</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MONGO_URI = <span class="string">'localhost'</span></span><br><span class="line"></span><br><span class="line">MONGO_DB = <span class="string">'taobao'</span></span><br></pre></td></tr></table></figure>

<h4 id="⑤-执行爬虫文件开始信息爬取"><a href="#⑤-执行爬虫文件开始信息爬取" class="headerlink" title="⑤ 执行爬虫文件开始信息爬取"></a>⑤ 执行爬虫文件开始信息爬取</h4><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scrapy crawl wx</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：当前爬取信息过多时会报如下302错误：</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-05</span><span class="number">-30</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">10</span> [scrapy.downloadermiddlewares.redirect] DEBUG: Redirecting (</span><br><span class="line"><span class="number">302</span>) to &lt;GET http:<span class="comment">//weixin.sogou.com/antispider/?from=%2fweixin%3Fquery%3dpython</span></span><br><span class="line">%<span class="number">26</span>type%<span class="number">3</span>d2%<span class="number">26</span>page%<span class="number">3</span>d1%<span class="number">26</span>ie%<span class="number">3</span>dutf8&gt; <span class="keyword">from</span> &lt;GET http:<span class="comment">//weixin.sogou.com/weixin?que</span></span><br><span class="line">ry=python&amp;type=<span class="number">2</span>&amp;page=<span class="number">1</span>&amp;ie=utf8&gt;</span><br></pre></td></tr></table></figure>



<h4 id="⑥-在中间件中使用付费代理服务来解决上面错误："><a href="#⑥-在中间件中使用付费代理服务来解决上面错误：" class="headerlink" title="⑥ 在中间件中使用付费代理服务来解决上面错误："></a>⑥ 在中间件中使用付费代理服务来解决上面错误：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在middlewares.py文件中定义一个Downloader中间件</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpbinProxyMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></span><br><span class="line">        pro_addr = requests.get(<span class="string">'http://tvp.daxiangdaili.com/ip/?tid=559775358931681&amp;num=1'</span>).text</span><br><span class="line">        request.meta[<span class="string">'proxy'</span>] = <span class="string">'http://'</span> + pro_addr</span><br><span class="line">        <span class="comment"># 设置启动上面我们写的这个代理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在settings.py配置文件中.设置我们自定义的Downloader MiddleWares中间件设置：</span></span><br><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">   <span class="string">'httpbin.middlewares.HttpbinProxyMiddleware'</span>: <span class="number">543</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>web基础</title>
    <url>/uncategorized/web%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h6 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第一次握手：建立连接时，客户端发送syn包到服务器，并进入syn_sent状态，等待服务器确认；syn:同步序列编号</span><br><span class="line">第二次握手:服务器收到syn包，必须确认客户的syn,同时自己也发送一个syn包，即syn+ack包，此时服务器进入syn_recv状态</span><br><span class="line"> 第三次握手:客户端收到服务器的syn+ack包，向服务器发送确认包，次包发送完毕。完成三次握手</span><br></pre></td></tr></table></figure>

<h6 id="Tcp的四次挥手"><a href="#Tcp的四次挥手" class="headerlink" title="Tcp的四次挥手"></a>Tcp的四次挥手</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接</span><br><span class="line"></span><br><span class="line">那对于TCP的断开连接，这里就有了“四次挥手”</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=<span class="number">1</span>，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加<span class="number">1</span>），此时，客户端进入FIN-WAIT<span class="number">-1</span>（终止等待<span class="number">1</span>）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）服务器收到连接释放报文，发出确认报文，ACK=<span class="number">1</span>，ack=u+<span class="number">1</span>，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT<span class="number">-2</span>（终止等待<span class="number">2</span>）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=<span class="number">1</span>，ack=u+<span class="number">1</span>，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）客户端收到服务器的连接释放报文后，必须发出确认，ACK=<span class="number">1</span>，ack=w+<span class="number">1</span>，而自己的序列号是seq=u+<span class="number">1</span>，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过<span class="number">2</span>∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</span><br></pre></td></tr></table></figure>

<h6 id="同步，异步编程差异是"><a href="#同步，异步编程差异是" class="headerlink" title="同步，异步编程差异是"></a>同步，异步编程差异是</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">你打电话问书店老板有没有《python开发》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下<span class="string">"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。</span></span><br><span class="line"><span class="string">而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</span></span><br></pre></td></tr></table></figure>

<h6 id="阻塞于非阻塞的差异是啥"><a href="#阻塞于非阻塞的差异是啥" class="headerlink" title="阻塞于非阻塞的差异是啥"></a>阻塞于非阻塞的差异是啥</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">还是你打电话问书店老板有没有《python开发》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果</span><br><span class="line">如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去干别的了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</span><br><span class="line">大部分Web应用都是阻塞性质的，也就是说当一个请求被处理时，这个进程就会被挂起直至请求完成，比如Django,而Tornado的思想是当我们在等待结果的时候不阻塞，转而我们给框架一个回调函数作为参数，让框架在收到结果的时候通过回调函数继续操作。这样，服务器就可以被解放去接受其他客户端的请求了。</span><br></pre></td></tr></table></figure>

<h6 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">get在浏览器回退时是无害的，而post会再次提交请求</span><br><span class="line">get产生的url地址可以被Bookmark(书签),而post不可以</span><br><span class="line">get请求会被浏览器主动cache(缓存),而post不会除非手动设置</span><br><span class="line">get请求只能进行url编码，而post支持多种编码方式</span><br><span class="line">get请求在url中传送的参数是有长度限制的，而post没有</span><br><span class="line">get比post更不安全，因为参数直接暴露在url上，所以不能用来传递铭感信息</span><br><span class="line">get参数通过url传参，post放在request body中</span><br></pre></td></tr></table></figure>

<h6 id="MVC模式MVT模式"><a href="#MVC模式MVT模式" class="headerlink" title="MVC模式MVT模式"></a>MVC模式MVT模式</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Django的mvt模式本质上和mvc是一样的，也是为了各组件件保持松耦合关系</span><br><span class="line">MTV</span><br><span class="line">M代表模型(model)负责业务对象和数据库的关系映射</span><br><span class="line">T代表模板(template) 负责如何把页面展示给用户</span><br><span class="line">V代表视图(view):负责业务逻辑，并在适当时候调用model和template</span><br><span class="line">除了以上三层之外，还需要一个url分发器，它的作用是将一个url的页面请求分发给不同的view处理，view再调用相应的model和template</span><br><span class="line"></span><br><span class="line">MVC</span><br><span class="line">所谓mvc就是把web应用分为模型(m),控制器(c)和视图(v)三层，他们之间以一种插件式的，松耦合的方式连接在一起，模型负责业务对象与数据库的映射，视图负责与用户的交互(页面)，控制器接收用户的输入调用模型和视图完成用户的请求。</span><br></pre></td></tr></table></figure>

<h6 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http 超文本传输协议 是一种用于分布式，协作式和超媒体信息系统的应用层协议。 端口<span class="number">80</span></span><br><span class="line">简单来说就是一种发布和接收HTML页面的方法，被用于在web浏览器和网站服务器之间传递信息。http协议以明文方式发送内容，不提供任何方式的数据加密，因此http协议不适合传输一些敏感信息，比如：信用卡号，密码支付等信息。</span><br><span class="line"></span><br><span class="line">https 超文本传输安全协议 https经由http进行通信，但利用ssl/tls来加密数据包。</span><br><span class="line">https开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。https默认工作在tcp协议<span class="number">443</span>端口</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">http明文传输，数据都是未加密的，安全性较差，https(ssl+http)数据传输过程都是加密的，安全性较好。</span><br><span class="line">使用https协议需要到CA(数字证书认证机构)申请证书，一般免费证书较少，因而需要一定费用。</span><br><span class="line">http页面响应速度比https快，主要业务http使用tcp三次握手建立连接，客户端和服务器需要交换三个包，而https除了tcp的三个包，还要加上ssl握手需要的<span class="number">9</span>个包，所以一共是<span class="number">12</span>个包</span><br><span class="line">http和https使用的是完全不同的连接方式，用的端口也不一样，前者是<span class="number">80</span>，后者是<span class="number">443.</span></span><br><span class="line">https其实就是建构在ssl/tls之上的http协议，所以，https比http更耗费服务器资源</span><br></pre></td></tr></table></figure>



<h6 id="什么是websocket"><a href="#什么是websocket" class="headerlink" title="什么是websocket"></a>什么是websocket</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">websocket是html5下一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的。它与http一样通过已建立的tcp连接来传输数据，但是它和http最大不同是:websocket是一种双向通信协议。在建立连接后，websocket服务器端和客户端都能主动向对方发送或接收数据。</span><br><span class="line"> Websocket有以下特点：是真正的全双共方式，建立连接后客户端与服务端是完全平等的，可以互相主动请求。扩展了浏览器与服务器的通信功能，是服务端也可以主动向客户端发送数据。</span><br></pre></td></tr></table></figure>

<h6 id="websocket心跳及重连机制"><a href="#websocket心跳及重连机制" class="headerlink" title="websocket心跳及重连机制"></a>websocket心跳及重连机制</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在使用websocket的过程中，有时候会遇到网络断开的情况，但是在网络断开的时候服务器并没有触发oneclose的事件。这样会有：服务器会继续向客户端发送多余的连接，并且这些数据还会丢失。所以就需要一种机制来检测客户端和服务端是否处于正常的连接状态。因此就有了websocket的心跳。</span><br></pre></td></tr></table></figure>

<h6 id="websocket心跳包"><a href="#websocket心跳包" class="headerlink" title="websocket心跳包"></a>websocket心跳包</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">所谓的心跳包就是服务器每隔固定的一段时间向客户端发送一个包，如果客户端收到这个包证明它还活着，同时它也会给服务端也返回一个包，证明它也还活着。</span><br></pre></td></tr></table></figure>



<h6 id="JSON-Web-Token"><a href="#JSON-Web-Token" class="headerlink" title="JSON Web Token"></a>JSON Web Token</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">jwt</span><br><span class="line">基于jwt的token身份认证方案</span><br><span class="line">	Browser                                  Server</span><br><span class="line">    		<span class="number">1.</span>发送带有用户名密码的post请求</span><br><span class="line">        							<span class="number">2.</span>验证通过后生成jwt并将用户信息放入jwt</span><br><span class="line">            		<span class="number">3.</span>将jwt存入cookie中</span><br><span class="line">                	<span class="number">4.</span>发送带有jwt cookie的请求</span><br><span class="line">                    		<span class="number">5.</span>验证签名后从jwt中获取用户信息</span><br><span class="line">                        <span class="number">6.</span>放回响应信息</span><br><span class="line">                        </span><br><span class="line">jwt 特点 体积小，因而传输速度快</span><br><span class="line">传输方式多样，可以通过url/post参数/http头部等方式传输</span><br><span class="line">严格的结构化。它自身(在payload中)就包含了所有与用户有关的验证信息，如用户可以访问路由，访问有效期等信息。</span><br><span class="line">支持跨域验证，可以应用于单点登陆</span><br><span class="line">签名的目的：</span><br><span class="line">	签名实际上是对头部以及载荷内容进行签名。所以，如果说有人对头部以及载荷的内容解码之后进行修改，在进行编码的话，那么新的签名和之前的签名就是不一样的。我们因此可以知道它是一个非法请求进行拦截。这样能保证token不会被纂改。</span><br><span class="line"> 最后，我们将上面拼接完的字符进行加密。在加密的时候，我们还需要提供提供一个密钥(sercet).类似盐</span><br><span class="line"></span><br><span class="line">使用json web token的好处？</span><br><span class="line"><span class="number">1.</span>性能问题。jwt方式将用户状态分散到了客户端中，相比于session,可以很明显减轻服务端的内存压力。session方式存储用户id的最大弊病在于session是存储在服务器端的，所以需要占用大量服务器内存，一般还需借助nosql和缓存机制来实现session的存储，如果分布式应用还需session共享。</span><br><span class="line"><span class="number">2.</span>单点登陆.jwt能轻松的实现单点登陆，因为用户的状态已经被传送到了客户端。tokem可保存自定义信息，如用户基本信息。</span><br><span class="line"><span class="number">3.</span>前后端分离。以前的传统模式下，后台对应的客户端就是浏览器，就可以使用session+cookie的方式实现登陆，但是在前后分离的情况下，后端只负责通过暴力的restApi提供数据，而页面的渲染，路由都由前端完成。因为rest是无状态的，因此也就不会有session记录到服务器端。</span><br><span class="line"><span class="number">4.</span>兼容性。支持移动设备，支持跨域程序调用，cookied是不允许跨域访问的。</span><br><span class="line"><span class="number">5.</span>可扩展性。jwt是无状态的，特别适用于分布式站点的单点登陆。</span><br><span class="line">jwt不适合存放大量信息，信息越多token越长。</span><br></pre></td></tr></table></figure>

<h6 id="什么是csrf"><a href="#什么是csrf" class="headerlink" title="什么是csrf"></a>什么是csrf</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CSRF 中文名称：跨站请求伪造。</span><br><span class="line">你可以这么理解csrf攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。csrf能够做的事情包括:以你名义发送邮件，发信息，盗取你的账号，甚至于购买商品，虚拟货币转账.....个人隐私泄露以及财产安全。</span><br></pre></td></tr></table></figure>

<h6 id="什么是sql注入"><a href="#什么是sql注入" class="headerlink" title="什么是sql注入"></a>什么是sql注入</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql注入是属于注入式攻击，这种攻击是因为在项目中没有将代码与数据(比如用户敏感数据)隔离，在读取数据的时候，错误的将数据作为代码的一部分执行而导致的。</span><br><span class="line">将sql代码注入到sql服务器中，解析并执行的一种攻击手法。</span><br><span class="line"></span><br><span class="line">任何防止？</span><br><span class="line"><span class="number">1.</span>过滤用户输入参数中的特殊字符，降低风险。</span><br><span class="line"><span class="number">2.</span>禁止通过字符串拼接sql语句，要严格适用参数绑定来传入参数。</span><br><span class="line"><span class="number">3.</span>合理使用数据库框架提供的机制。禁止拼接Sql语句，</span><br><span class="line">就是要正确使用参数化绑定sql变量</span><br></pre></td></tr></table></figure>

<h6 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xss:跨站脚本攻击，为了和前端的css避免重名，简称为xss,是指通过技术手段，向正常用户请求的HTML页面中插入恶意脚本，执行。</span><br><span class="line">    这种攻击主要是用于信息窃取和破坏等目的。</span><br><span class="line">    </span><br><span class="line">关于防范xss，主要就是通过对用户输入的数据做过滤或者是转义。总结扼，过滤html标签。</span><br></pre></td></tr></table></figure>

<h6 id="什么是celery"><a href="#什么是celery" class="headerlink" title="什么是celery?"></a>什么是celery?</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Django的请求处理过程都是同步的无法实现异步任务，若要实现异步任务处理需要通过其他方式(前端的一般解决方案是ajax操作)，而后台celery就是不错的选择。倘若一个用户在执行某些操作需要等待很就才放回，这大大降低了网站的吞吐量。</span><br><span class="line">celery是由python开发，简单，灵活，可靠的分布式任务队列，其本质是生产者消费者模型，生产者发送任务到消息队列，消费者负责处理任务。celery侧重于实时操作</span><br><span class="line">高可用:当任务执行失败或执行过程中发送连续中断，celery会自动吃屎重新执行任务。</span><br><span class="line">快速:一个单进程的celery每分钟可处理上百万个任务</span><br><span class="line"> 灵活:几乎celery的每个组件都可以被扩展及自定制</span><br><span class="line">工作原理：</span><br><span class="line"></span><br><span class="line">任务模块Task包含异步任务和定时任务。其中，异步任务通常在业务逻辑中被触发并发往消息队列，而定时任务由Celery Beat进程周期性地将任务发往消息队列； 任务执行单元Worker实时监视消息队列获取队列中的任务执行； Woker执行完任务后将结果保存在Backend中;</span><br><span class="line"></span><br><span class="line">消息中间件Broker 　　消息中间件Broker官方提供了很多备选方案，支持RabbitMQ、Redis、Amazon SQS、MongoDB、Memcached 等，官方推荐RabbitMQ。</span><br><span class="line"></span><br><span class="line">任务执行单元Worker 　　Worker是任务执行单元，负责从消息队列中取出任务执行，它可以启动一个或者多个，也可以启动在不同的机器节点，这就是其实现分布式的核心。</span><br><span class="line"></span><br><span class="line">结果存储Backend 　　Backend结果存储官方也提供了诸多的存储方式支持：RabbitMQ、 Redis、Memcached,SQLAlchemy, Django ORM、Apache Cassandra、Elasticsearch。</span><br><span class="line"></span><br><span class="line">Celery管理和监控功能是通过flower组件实现的，flower组件不仅仅提供监控功能，还提供HTTP API可实现对woker和task的管理。</span><br></pre></td></tr></table></figure>

<h6 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">因为浏览器的同源策略规定某域下的客户端在没明确授权的情况下，不能读写另一个域的资源</span><br><span class="line">而在实际开发中，前后端是常常相互分离的。</span><br><span class="line">所谓同源(域名，协议，端口相同)</span><br></pre></td></tr></table></figure>

<h6 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>开头(请求成功)表示成功处理了请求的状态码</span><br><span class="line"><span class="number">200</span>(成功)服务器已成功处理了请求</span><br><span class="line"><span class="number">201</span> （已创建） 请求成功并且服务器创建了新的资源。</span><br><span class="line"></span><br><span class="line"><span class="number">202</span> （已接受） 服务器已接受请求，但尚未处理。</span><br><span class="line"></span><br><span class="line"><span class="number">203</span> （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</span><br><span class="line"></span><br><span class="line"><span class="number">204</span> （无内容） 服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line"></span><br><span class="line"><span class="number">205</span> （重置内容） 服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line"></span><br><span class="line"><span class="number">206</span> （部分内容） 服务器成功处理了部分 GET 请求。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</span><br><span class="line"></span><br><span class="line"><span class="number">300</span> （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</span><br><span class="line"></span><br><span class="line"><span class="number">301</span> （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</span><br><span class="line"></span><br><span class="line"><span class="number">302</span> （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class="line"></span><br><span class="line"><span class="number">303</span> （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</span><br><span class="line"></span><br><span class="line"><span class="number">304</span> （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</span><br><span class="line"></span><br><span class="line"><span class="number">305</span> （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</span><br><span class="line"></span><br><span class="line"><span class="number">307</span> （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</span><br><span class="line"></span><br><span class="line"><span class="number">400</span> （错误请求） 服务器不理解请求的语法。</span><br><span class="line"></span><br><span class="line"><span class="number">401</span> （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</span><br><span class="line"></span><br><span class="line"><span class="number">403</span> （禁止） 服务器拒绝请求。</span><br><span class="line"></span><br><span class="line"><span class="number">404</span> （未找到） 服务器找不到请求的网页。</span><br><span class="line"></span><br><span class="line"><span class="number">405</span> （方法禁用） 禁用请求中指定的方法。</span><br><span class="line"></span><br><span class="line"><span class="number">406</span> （不接受） 无法使用请求的内容特性响应请求的网页。</span><br><span class="line"></span><br><span class="line"><span class="number">407</span> （需要代理授权） 此状态代码与 <span class="number">401</span>（未授权）类似，但指定请求者应当授权使用代理。</span><br><span class="line"></span><br><span class="line"><span class="number">408</span> （请求超时） 服务器等候请求时发生超时。</span><br><span class="line"></span><br><span class="line"><span class="number">409</span> （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</span><br><span class="line"></span><br><span class="line"><span class="number">410</span> （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</span><br><span class="line"></span><br><span class="line"><span class="number">411</span> （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</span><br><span class="line"></span><br><span class="line"><span class="number">412</span> （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</span><br><span class="line"></span><br><span class="line"><span class="number">413</span> （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</span><br><span class="line"></span><br><span class="line"><span class="number">414</span> （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</span><br><span class="line"></span><br><span class="line"><span class="number">415</span> （不支持的媒体类型） 请求的格式不受请求页面的支持。</span><br><span class="line"></span><br><span class="line"><span class="number">416</span> （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</span><br><span class="line"></span><br><span class="line"><span class="number">417</span> （未满足期望值） 服务器未满足<span class="string">"期望"</span>请求标头字段的要求。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</span><br><span class="line"></span><br><span class="line"><span class="number">500</span> （服务器内部错误） 服务器遇到错误，无法完成请求。</span><br><span class="line"></span><br><span class="line"><span class="number">501</span> （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</span><br><span class="line"></span><br><span class="line"><span class="number">502</span> （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</span><br><span class="line"></span><br><span class="line"><span class="number">503</span> （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</span><br><span class="line"></span><br><span class="line"><span class="number">504</span> （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</span><br><span class="line"></span><br><span class="line"><span class="number">505</span> （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</span><br></pre></td></tr></table></figure>

<h6 id="列举django-orm中所有的方法"><a href="#列举django-orm中所有的方法" class="headerlink" title="列举django orm中所有的方法"></a>列举django orm中所有的方法</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">从数据库中查询出来的结果一般是一个集合。Queryset</span><br><span class="line">filter过滤     all放回所有结果</span><br><span class="line">exclude排除    distince 去除查询结果中重复的行</span><br><span class="line">order_by排序</span><br><span class="line">reverse反向排序</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Gunicorn+Nginx+Web服务部署</title>
    <url>/Linux/Gunicorn-Nginx-Web%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="Nginx-Gunicorn-部署-web服务"><a href="#Nginx-Gunicorn-部署-web服务" class="headerlink" title="Nginx  + Gunicorn 部署 web服务"></a>Nginx  + Gunicorn 部署 web服务</h1><h6 id="Gunicorn是什么？"><a href="#Gunicorn是什么？" class="headerlink" title="Gunicorn是什么？"></a>Gunicorn是什么？</h6><p>Gunicorn是一个用于UNIX的Python WSGI HTTP服务器。它是一个前叉工作者模型，从Ruby的Unicorn项目移植而来。Gunicorn服务器与许多Web服务器框架广泛 兼容，轻松服务器资源并且速度相当快。</p>
<ul>
<li><h6 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h6><ul>
<li>自动化工作流程管理</li>
<li>简单的 Python 配置</li>
<li>多个工人配置</li>
<li>各种服务器挂钩，可扩展性</li>
<li>兼容 Python 2.6+和 Python 3.2+</li>
</ul>
<p>Gunicorn 是一个 unix 上被广泛使用的高性能的 Python WSGI UNIX HTTP Server。和大多数的 web 框架兼容，并具有实现简单，轻量级，高性能等特点。</p>
<p>Gunicorn 服务器作为 wsgi app 的容器，能够与各种 Web 框架兼容（flask，django 等）,得益于 gevent 等技术，使用 Gunicorn 能够在基本不改变 wsgi app 代码的前提下，大幅度提高 wsgi app 的性能。 <a id="more"></a> </p>
<h6 id="服务模型-Server-Model"><a href="#服务模型-Server-Model" class="headerlink" title="服务模型(Server Model)"></a>服务模型(Server Model)</h6><p>Gunicorn 是基于 pre-fork 模型的。也就意味着有一个中心管理进程( master process )用来管理 worker 进程集合。Master 从不知道任何关于客户端的信息。所有的请求和响应处理都是由 worker 进程来处理的。</p>
<h6 id="Master-管理者"><a href="#Master-管理者" class="headerlink" title="Master(管理者)"></a>Master(管理者)</h6><p>主程序是一个简单的循环,监听各种信号以及相应的响应进程。master 管理着正在运行的 worker 集合,通过监听各种信号比如 TTIN, TTOU, and CHLD. TTIN and TTOU 响应的增加和减少 worker 的数目。CHLD 信号表明一个子进程已经结束了,在这种情况下 master 会自动的重启失败的 worker。</p>
<h6 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h6><p>woker 有很多种，包括：ggevent、geventlet、gtornado 等等。</p>
<p>这里主要分析 ggevent。每个 ggevent worker 启动的时候会启动多个 server 对象：worker 首先为每个 listener 创建一个 server 对象（注：为什么是一组 listener,因为 gunicorn 可以绑定一组地址,每个地址对于一个 listener），每个 server 对象都有运行在一个单独的 gevent pool 对象中。真正等待链接和处理链接的操作是在 server 对象中进行的。</p>
</li>
</ul>
<h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p>在一个Django项目中，下载gunicorn</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install gunicorn</span><br></pre></td></tr></table></figure>

<p>加入Gunicorn的配置文件gunicorn.conf.py具体如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"><span class="keyword">from</span> logging.handlers <span class="keyword">import</span> WatchedFileHandler</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">bind = <span class="string">"127.0.0.1:8080"</span>   <span class="comment">#绑定的ip与端口             &lt;&lt;&lt;————————————</span></span><br><span class="line">backlog = <span class="number">512</span>                <span class="comment">#监听队列数量，64-2048</span></span><br><span class="line">chdir = <span class="string">'/root/sites/DjangoBlog'</span>  <span class="comment">#gunicorn要切换到的目的工作目录    &lt;&lt;&lt;————————————</span></span><br><span class="line">worker_class = <span class="string">'sync'</span> <span class="comment">#使用gevent模式，还可以使用sync 模式，默认的是sync模式</span></span><br><span class="line">workers = multiprocessing.cpu_count()</span><br><span class="line"><span class="comment">#workers = 4 # multiprocessing.cpu_count()    #进程数</span></span><br><span class="line">threads = <span class="number">16</span> <span class="comment">#multiprocessing.cpu_count()*4 #指定每个进程开启的线程数</span></span><br><span class="line">loglevel = <span class="string">'info'</span> <span class="comment">#日志级别，这个日志级别指的是错误日志的级别，而访问日志的级别无法设置</span></span><br><span class="line">access_log_format = <span class="string">'%(t)s %(p)s %(h)s "%(r)s" %(s)s %(L)s %(b)s %(f)s" "%(a)s"'</span> <span class="comment"># 日志格式</span></span><br><span class="line"></span><br><span class="line">accesslog = <span class="string">"/root/sites/DjangoBlog/log/gunicorn_access.log"</span>  <span class="comment">#访问日志文件  &lt;&lt;&lt;———————————</span></span><br><span class="line">errorlog = <span class="string">"/root/sites/DjangoBlog/log/gunicorn_error.log"</span>    <span class="comment">#错误日志文件  &lt;&lt;&lt;———————————</span></span><br><span class="line"><span class="comment"># accesslog = "-"  #访问日志文件，"-" 表示标准输出</span></span><br><span class="line"><span class="comment"># errorlog = "-"   #错误日志文件，"-" 表示标准输出</span></span><br><span class="line"></span><br><span class="line">proc_name = <span class="string">'fof_api'</span>   <span class="comment">#进程名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面有箭头的地方都要修改</span></span><br></pre></td></tr></table></figure>



<p>启动命令</p>
<p>Gunicorn常见参数</p>
<p>-c 指定一个配置文件(py文件)</p>
<p>-b 与指定的socket进行绑定</p>
<p>-D 以守护进程形式来运行Gunicorn进程，就是将这个服务放到后台运行</p>
<p>-w 工作的进程数量</p>
<p>根据Gunicorn配置文件和Django自带wsgi启动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gunicorn -c gunicorn.conf.py djangodemo.wsgi -D <span class="comment"># djangodemo 是djangodemo项目的名字</span></span><br></pre></td></tr></table></figure>

<p>指定端口和工作的进程运行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gunicorn -w <span class="number">3</span> djangodemo.wsgi -b <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8100</span></span><br></pre></td></tr></table></figure>

<p>这里使用的djangodemo.wsgi是Django自带的wsgi</p>
<p>wsgi(Web Server Gateway interface),翻译为Python web服务器网关接口，即Python的Web应用程序(如flask)和web服务器(如nginx)之间的一种通信协议。也就是说，如果让你的web应用在任何服务器上运行，就必须遵守这个协议。</p>
<p>那么实现WSGI协议的web服务器有哪些呢？就比如uWSGI与gunicorn。两者都可以作为Web服务器。可能你在许多地方看到的都是采用Nginx + uWSGI（或gunicorn）的部署方式。</p>
<p>实际上，直接通过uWSGI或gunicorn直接部署也是可以让外网访问的，那你可能会说，我用Gunicorn直接部署也能够做到外网访问，那么在Gunicorn上再套一层Nginx是为了什么呢？</p>
<p>首先，我们先了解下Nginx.</p>
<h6 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h6><p><em>Nginx</em> (engine x) 是一个高性能的<a href="https://baike.baidu.com/item/HTTP" target="_blank" rel="noopener">HTTP</a>和<a href="https://baike.baidu.com/item/反向代理/7793488" target="_blank" rel="noopener">反向代理</a>web服务器，同时也提供了IMAP/POP3/SMTP<a href="https://baike.baidu.com/item/服务/100571" target="_blank" rel="noopener">服务</a>。Nginx是由伊戈尔·赛索耶夫为<a href="https://baike.baidu.com/item/俄罗斯/125568" target="_blank" rel="noopener">俄罗斯</a>访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p>
<p>其将<a href="https://baike.baidu.com/item/源代码" target="_blank" rel="noopener">源代码</a>以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而<a href="https://baike.baidu.com/item/闻名/2303308" target="_blank" rel="noopener">闻名</a>。2011年6月1日，nginx 1.0.4发布。</p>
<p>Nginx是一款<a href="https://baike.baidu.com/item/轻量级/10002835" target="_blank" rel="noopener">轻量级</a>的<a href="https://baike.baidu.com/item/Web/150564" target="_blank" rel="noopener">Web</a> 服务器/<a href="https://baike.baidu.com/item/反向代理/7793488" target="_blank" rel="noopener">反向代理</a>服务器及<a href="https://baike.baidu.com/item/电子邮件/111106" target="_blank" rel="noopener">电子邮件</a>（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，<a href="https://baike.baidu.com/item/并发/11024806" target="_blank" rel="noopener">并发</a>能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、<a href="https://baike.baidu.com/item/京东/210931" target="_blank" rel="noopener">京东</a>、<a href="https://baike.baidu.com/item/新浪/125692" target="_blank" rel="noopener">新浪</a>、<a href="https://baike.baidu.com/item/网易/185754" target="_blank" rel="noopener">网易</a>、<a href="https://baike.baidu.com/item/腾讯/112204" target="_blank" rel="noopener">腾讯</a>、<a href="https://baike.baidu.com/item/淘宝/145661" target="_blank" rel="noopener">淘宝</a>等。</p>
<p>Nginx 是一个很强大的高性能<a href="https://baike.baidu.com/item/Web/150564" target="_blank" rel="noopener">Web</a>和<a href="https://baike.baidu.com/item/反向代理" target="_blank" rel="noopener">反向代理</a>服务，它具有很多非常优越的特性：</p>
<p>在连接高并发的情况下，Nginx是<a href="https://baike.baidu.com/item/Apache/6265" target="_blank" rel="noopener">Apache</a>服务不错的替代品：Nginx在美国是做虚拟主机生意的老板们经常选择的软件平台之一。能够支持高达 50,000 个并发连接数的响应，感谢Nginx为我们选择了 epoll and kqueue作为开发模型。</p>
<h6 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h6><p>Nginx作为负载均衡服务：Nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务，也可以支持作为 HTTP<a href="https://baike.baidu.com/item/代理服务" target="_blank" rel="noopener">代理服务</a>对外进行服务。Nginx采用C进行编写，不论是系统资源开销还是CPU使用效率都比 Perlbal 要好很多。</p>
<p>处理静态文件，索引文件以及自动索引;打开文件描述符缓冲。</p>
<p>无缓存的反向代理加速，简单的负载均衡和容错。</p>
<p>FastCGI，简单的负载均衡和容错。</p>
<p>模块化的结构。包括 gzipping, byte ranges, chunked responses,以及 SSI-filter 等 filter。如果由 FastCG或其它代理服务器处理单页中存在的多个 SSI，则这项处理可以并行运行，而不需要相互等待。</p>
<p>支持 SSL 和 TLSSNI。 [1] </p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><p>Nginx代码完全用<a href="https://baike.baidu.com/item/C语言" target="_blank" rel="noopener">C语言</a>从头写成，已经移植到许多体系结构和<a href="https://baike.baidu.com/item/操作系统/192" target="_blank" rel="noopener">操作系统</a>，包括：<a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>、<a href="https://baike.baidu.com/item/FreeBSD" target="_blank" rel="noopener">FreeBSD</a>、<a href="https://baike.baidu.com/item/Solaris/3517" target="_blank" rel="noopener">Solaris</a>、[Mac OS X](<a href="https://baike.baidu.com/item/Mac" target="_blank" rel="noopener">https://baike.baidu.com/item/Mac</a> OS X)、<a href="https://baike.baidu.com/item/AIX" target="_blank" rel="noopener">AIX</a>以及[Microsoft Windows](<a href="https://baike.baidu.com/item/Microsoft" target="_blank" rel="noopener">https://baike.baidu.com/item/Microsoft</a> Windows)。Nginx有自己的函数库，并且除了<a href="https://baike.baidu.com/item/zlib" target="_blank" rel="noopener">zlib</a>、<a href="https://baike.baidu.com/item/PCRE" target="_blank" rel="noopener">PCRE</a>和<a href="https://baike.baidu.com/item/OpenSSL" target="_blank" rel="noopener">OpenSSL</a>之外，标准模块只使用系统C<a href="https://baike.baidu.com/item/库函数" target="_blank" rel="noopener">库函数</a>。而且，如果不需要或者考虑到潜在的授权冲突，可以不使用这些第三方库。</p>
<h6 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h6><p>作为邮件<a href="https://baike.baidu.com/item/代理服务" target="_blank" rel="noopener">代理服务</a>：Nginx 同时也是一个非常优秀的邮件<a href="https://baike.baidu.com/item/代理服务" target="_blank" rel="noopener">代理服务</a>（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。</p>
<p>Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、<a href="https://baike.baidu.com/item/Bug" target="_blank" rel="noopener">Bug</a>非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的<a href="https://baike.baidu.com/item/升级/8358284" target="_blank" rel="noopener">升级</a>。</p>
<p>gunicorn自己是WSGI服务器。pre-fork是第一个进程启动监听的socket，然后开始fork，fork出去的进程会继承这个socket，于是所有的子进程都可以监听这个socket，有请求进来大家都可以accept（当然每个连接只会有一个进程accept到），这样就实现了负载均衡。worker数量一般不会变吧，变它作甚……只会挂了之后重新fork一个出去。工作都在子进程里面做，父进程保持这个状态，随时准备fork新的子进程出去。Nginx：负载均衡，静态文件支持，抗并发压力</p>
<hr>
<p>修改Nginx文件目录中的nginx.conf，将Server片段注释或者删掉(建议备份)，修改如下</p>
<p>我们可以给它专门一个配置文件，尽量不要去触碰原有配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name  <span class="number">47.97</span><span class="number">.210</span><span class="number">.11</span>; <span class="comment">#此处写你的域名或者ip</span></span><br><span class="line">    charset utf<span class="number">-8</span>;</span><br><span class="line">    client_max_body_size <span class="number">200</span>m;</span><br><span class="line">    access_log  /var/log/nginx/build-access.log;</span><br><span class="line">    error_log  /var/log/nginx/build-err.log;</span><br><span class="line">    location = /favicon.ico &#123; access_log off; log_not_found off; &#125;</span><br><span class="line">    location /static/ &#123;</span><br><span class="line">        <span class="comment">#静态文件如js，css的存放目录  静态文件配置</span></span><br><span class="line">        alias /root/Code/monkey/bogs/DjangoBlog-master/collectedstatic/;</span><br><span class="line">    &#125;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8080</span>; <span class="comment"># 这里要配合启动文件使用 跑的端口</span></span><br><span class="line">        proxy_redirect     off;</span><br><span class="line">        proxy_set_header   Host                 $http_host;</span><br><span class="line">        proxy_set_header   X-Real-IP            $remote_addr;</span><br><span class="line">        proxy_set_header   X-Forwarded-For      $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header   X-Forwarded-Proto    $scheme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用Django项目的一个特性，将Django项目 生成静态文件,命令如下</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">python</span> manage.<span class="keyword">py</span> collectstatic</span><br></pre></td></tr></table></figure>

<p>然后将Nginx的配置文件进行修改</p>
<p>重启Nginx</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nginx -s reload</span></span><br></pre></td></tr></table></figure>

<p>运行Nginx就可以了</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
