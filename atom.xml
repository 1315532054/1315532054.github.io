<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>可乐</title>
  
  <subtitle>“我在寻找丢失的记忆”“说人话!”“我在复习”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luckyle.top/"/>
  <updated>2019-12-29T11:13:07.200Z</updated>
  <id>https://luckyle.top/</id>
  
  <author>
    <name>杜家乐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进程间任何通信？</title>
    <link href="https://luckyle.top/uncategorized/%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BB%BB%E4%BD%95%E9%80%9A%E4%BF%A1%EF%BC%9F/"/>
    <id>https://luckyle.top/uncategorized/%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BB%BB%E4%BD%95%E9%80%9A%E4%BF%A1%EF%BC%9F/</id>
    <published>2020-09-09T11:06:27.000Z</published>
    <updated>2019-12-29T11:13:07.200Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程之间究竟有哪些通信方式？如何通信？"><a href="#进程之间究竟有哪些通信方式？如何通信？" class="headerlink" title="进程之间究竟有哪些通信方式？如何通信？"></a>进程之间究竟有哪些通信方式？如何通信？</h3><h6 id="1、管道"><a href="#1、管道" class="headerlink" title="1、管道"></a>1、管道</h6><p>我们来看一条 Linux 的语句</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulnp | grep <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>学过 Linux 命名的估计都懂这条语句的含义，其中”|“是管道的意思，它的作用就是把前一条命令的输出作为后一条命令的输入。在这里就是把 netstat -tulnp 的输出结果作为 grep 8080 这条命令的输入。如果两个进程要进行通信的话，就可以用这种管道来进行通信了，并且我们可以知道这条竖线是没有名字的，所以我们把这种通信方式称之为匿名管道。</p><p>并且这种通信方式是单向的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。<a id="more"></a></p><p>居然有匿名管道，那也意味着有命名管道，下面我们来创建一个命名管道。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo  test</span><br></pre></td></tr></table></figure><p>这条命令创建了一个名字为 test 的命名管道。</p><p>接下来我们用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"this is a pipe"</span> &gt; <span class="built_in">test</span>   // 写数据</span><br></pre></td></tr></table></figure><p>这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束。接下来我们用另外一个进程来读取</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cat</span> &lt; <span class="keyword">test</span>  <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure><p>我们可以看到，test 里面的数据被读取出来了。上一条命令也执行结束了。</p><p>从上面的例子可以看出，管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是单向传输的。</p><p>这种通信方式有什么缺点呢？显然，这种通信方式效率低下，你看，a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。</p><p>所以管道不适合频繁通信的进程。当然，他也有它的优点，例如比较简单，能够保证我们的数据已经真的被其他进程拿走了。我们平时用 Linux 的时候，也算是经常用。</p><h6 id="2、消息队列"><a href="#2、消息队列" class="headerlink" title="2、消息队列"></a>2、消息队列</h6><p>那我们能不能把进程的数据放在某个内存之后就马上让进程返回呢？无需等待其他进程来取就返回呢？</p><p>答是可以的，我们可以用消息队列的通信模式来解决这个问题，例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的<br>消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于缓存吧。</p><p>这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味<strong>发送消息（拷贝）</strong>这个过程需要花很多时间来读内存。</p><p>哪有没有什么解决方案呢？答是有的，请继续往下看。</p><h6 id="3、共享内存"><a href="#3、共享内存" class="headerlink" title="3、共享内存"></a>3、共享内存</h6><p>共享内存这个通信方式就可以很好着解决拷贝所消耗的时间了。</p><p>这个可能有人会问了，每个进程不是有自己的独立内存吗？两个进程怎么就可以共享一块内存了？</p><p>我们都知道，系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。</p><h6 id="4、信号量"><a href="#4、信号量" class="headerlink" title="4、信号量"></a>4、信号量</h6><p>共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的线程安全问题。如何解决这个问题？这个时候我们的信号量就上场了。</p><p>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p><h6 id="5、Socket"><a href="#5、Socket" class="headerlink" title="5、Socket"></a>5、Socket</h6><p>上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？</p><p>答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p><p>总结<br>所以，进程之间的通信方式有：</p><p>1、管道</p><p>2、消息队列</p><p>3、共享内存</p><p>4、信号量</p><p>5、Socket</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;进程之间究竟有哪些通信方式？如何通信？&quot;&gt;&lt;a href=&quot;#进程之间究竟有哪些通信方式？如何通信？&quot; class=&quot;headerlink&quot; title=&quot;进程之间究竟有哪些通信方式？如何通信？&quot;&gt;&lt;/a&gt;进程之间究竟有哪些通信方式？如何通信？&lt;/h3&gt;&lt;h6 id=&quot;1、管道&quot;&gt;&lt;a href=&quot;#1、管道&quot; class=&quot;headerlink&quot; title=&quot;1、管道&quot;&gt;&lt;/a&gt;1、管道&lt;/h6&gt;&lt;p&gt;我们来看一条 Linux 的语句&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;netstat -tulnp | grep &lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;学过 Linux 命名的估计都懂这条语句的含义，其中”|“是管道的意思，它的作用就是把前一条命令的输出作为后一条命令的输入。在这里就是把 netstat -tulnp 的输出结果作为 grep 8080 这条命令的输入。如果两个进程要进行通信的话，就可以用这种管道来进行通信了，并且我们可以知道这条竖线是没有名字的，所以我们把这种通信方式称之为匿名管道。&lt;/p&gt;
&lt;p&gt;并且这种通信方式是单向的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>利用Docker搭建分布式文件系统FastDfs</title>
    <link href="https://luckyle.top/Linux/%E5%88%A9%E7%94%A8Docker%E6%90%AD%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FFastDfs/"/>
    <id>https://luckyle.top/Linux/%E5%88%A9%E7%94%A8Docker%E6%90%AD%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FFastDfs/</id>
    <published>2020-01-13T07:31:25.000Z</published>
    <updated>2020-01-13T07:33:29.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用Docker搭建分布式文件系统FastDfs"><a href="#利用Docker搭建分布式文件系统FastDfs" class="headerlink" title="利用Docker搭建分布式文件系统FastDfs"></a>利用Docker搭建分布式文件系统FastDfs</h1><p>​        对于文件存储来说，一般情况下简单的处理就是在Django配置文件中配置存储目录，按照规则对文件进行上传或者下载。</p><p>​        实际上，当文件较少的时候，Django是可以应付的过来的。但当文件以海量形式出现的时候，Django就并不是那么好用了，于是FastDfs应用而生。</p><p>​        FastDfs是一个开源的分布式文件系统，它对文件进行管理，功能包括：文件存储，文件同步，文件访问(文件上传，文件下载)等，解决了大容量存储和负载均衡的问题。特别适合在以文件为载体的在线服务，如相册网站，视频网站等。可以说它就是为互联网而生，为大数据而生的。</p><p>​        FastDfs服务端有两个角色：跟踪器(tracker)和存储节点(storage)。跟踪器主要做调度工作，在访问上起负载均衡的作用。存储节点存储文件，完成文件管理的所有功能：存储，同步和提供存取接口，FastDfs同时对文件的meta data进行管理。跟踪器和存储节点都可以由多台服务器构成。跟踪器和存储节点中的服务器均可随时增加或下线而不会影响上线服务。其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。</p><h5 id="说人话，为什么要用FastDfs"><a href="#说人话，为什么要用FastDfs" class="headerlink" title="说人话，为什么要用FastDfs?"></a>说人话，为什么要用FastDfs?</h5><p>1.解决海量存储，同时存储容量扩展方便。</p><p>2.解决文件内容重复。如果用户上传的文件重复(文件指纹一样)，那么系统只存储一份数据，这项技术目前被广泛应用在网盘中。</p><p>3.结合Nginx提高网站读取图片的效率。</p><p>​        如果我们从头搭建fastdfs服务器那么就太Low了，网上有大把的Docker镜像供你选择，所以有到了利用Docker优越性的时候了，首先下载fastdfs镜像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search fastdfs</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull delron/fastdfs</span><br></pre></td></tr></table></figure><p>你会发现区区四百多兆就承载了Nginx和FastDfs服务</p><p>然后使用Docker镜像构建tracker容器(跟踪服务器，起到调度的作用)，这里tracker服务将会自动映射到宿主机上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --network=host --name tracker -v /var/fdfs/tracker:/var/fdfs delron/fastdfs tracker</span><br></pre></td></tr></table></figure><p>使用docker镜像构建storage容器（存储服务器，提供容量和备份服务），这里storage容器需要依赖tracker服务，传入你的tracker服务的ip地址，端口默认是22122，ip地址也就是你宿主机的ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --network=host --name storage -e TRACKER_SERVER=ip:22122 -v /var/fdfs/storage:/var/fdfs -e GROUP_NAME=group1 delron/fastdfs storage</span><br></pre></td></tr></table></figure><p>上面需要填写你的tracker服务的ip地址，端口默认是22122</p><p>此时两个服务都已启动，进行服务的配置。</p><p>进入storage容器，到storage的配置文件中配置http访问的端口，配置文件在/etc/fdfs目录下的storage.conf</p><p>端口默认是8888，也可以不进行更改。</p><p>这时，进入正在后台运行的storage容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it storage /bin/bash</span><br></pre></td></tr></table></figure><p>随便下载一张图片,这个不用担心，因为在容器中如果不提交仓库的话，该图片是不会保存的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://v3u.cn/v3u/Public/images/logo.png</span><br></pre></td></tr></table></figure><p>将该图片通过命令上传到分布式系统中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/fdfs_upload_file /etc/fdfs/client.conf logo.png</span><br></pre></td></tr></table></figure><p>ip +端口 +返回网络地址</p><p>这时该图片已上传至文件系统，并在执行该语句后返回图片存储的网络地址</p><p>最后通过浏览器访问以下存储在Fastdfs的图片，这张图片是通过nginx代理的静态资源，默认nginx监听8888端口，所以需要加上端口号，如果是在阿里云上部署，则需要暴露外部端口8888</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用Docker搭建分布式文件系统FastDfs&quot;&gt;&lt;a href=&quot;#利用Docker搭建分布式文件系统FastDfs&quot; class=&quot;headerlink&quot; title=&quot;利用Docker搭建分布式文件系统FastDfs&quot;&gt;&lt;/a&gt;利用Docker搭建分布式文
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://luckyle.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql主从复制</title>
    <link href="https://luckyle.top/uncategorized/Mysql%E5%9F%BA%E7%A1%80/"/>
    <id>https://luckyle.top/uncategorized/Mysql%E5%9F%BA%E7%A1%80/</id>
    <published>2020-01-06T07:04:02.000Z</published>
    <updated>2020-01-12T11:11:11.002Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h4><hr><h5 id="什么是主从复制？"><a href="#什么是主从复制？" class="headerlink" title="什么是主从复制？"></a>什么是主从复制？</h5><p>主从复制(也称AB复制)允许将来自一个Mysql数据库服务器(主服务器)的数据复制到一个或多个Mysql数据库服务器(从服务器)</p><p>主从复制至少需要两台服务器，或两个mysql服务，可以配置一主多从，多主多从</p><p>建立于某个业务数据库一样的数据库环境，即为主从复制</p><p>一般情况下，主库用以写，而从库用以读</p><h5 id="为什么要搭建主从复制？"><a href="#为什么要搭建主从复制？" class="headerlink" title="为什么要搭建主从复制？"></a>为什么要搭建主从复制？</h5><p>1.构建主从热备，当某天数据库宕机或数据丢失情况，可以有备份数据库继续工作</p><p>2.降低IO频次，多库之间可以合理分配读写压力，提高单个数据库服务的数据库访问压力</p><p>3.隔离读写，在某些锁表情况下，可以使数据库读操作继续进行</p><h5 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h5><p>利用数据库 bin-log二进制文件，该文件包含有数据库操作的所有SQL语句</p><p>复制该文件至其余数据库服务中并执行即可</p><h5 id="主从复制过程"><a href="#主从复制过程" class="headerlink" title="主从复制过程"></a>主从复制过程</h5><p>当主库具有新数据时，主库会被从库请求，建立线程进行连接，用以传输binlog日志</p><p>从库开启两个线程</p><p>​    A线程:也叫做IO线程，连接主库，并请求binlog中的更新记录至从库中，写入从库的relaylog文件中</p><p>​    B线程:也叫做SQL线程，读取relaylog文件中的更新操作并执行</p><p>如果，有多个从库同时存在，主库会为每个从库建立一个binlog输出线程</p><h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h4><p>索引是存储引擎用于快速找到记录的一种数据结构。</p><p>一个常见的例子就是书的目录，我们都已经养成了看目录的习惯，拿到一本书时，我们首先会去查看它的目录，并且当我们要查找某个内容时，我们会在目录中查找，然后找到该片段相应的页码，在根据相应的页码去书中查找，如果没有索引(目录)的话，我们就只能一页一页的去查找了。</p><p>在MySQL中,假设我们有一张如下记录的表:</p><table><thead><tr><th>id</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>xiaoming</td><td>10</td></tr><tr><td>2</td><td>xiaohong</td><td>15</td></tr><tr><td>3</td><td>xiaofang</td><td>18</td></tr></tbody></table><p>如果我们希望查找到年龄为15的人的名字,在没有索引的情况下我们只能遍历所有的数据去做逐一的对比,那么时间复杂度是O(n).</p><p>而如果我们在插入数据的过程中, 额外维护一个数组,将age字段有序的存储.得到如下数组.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>,<span class="number">15</span>,<span class="number">18</span>,<span class="number">20</span>,<span class="number">21</span>]</span><br><span class="line"> |  |  |  |  |</span><br><span class="line">[x1,x4,x2,x3,x5]</span><br></pre></td></tr></table></figure><p>下面的x是模拟数据再磁盘上的存储位置.这个时候如果我们需要查找15岁的人的名字.我们可以对盖数组进行二分查找.众所周知,二分查找的时间复杂度为O(logn).查找到之后再根据具体的位置去获取真正的数据.</p><p>PS:MySQL中的索引不是使用的数组,而是使用的B+树(后面讲),这里用数组举例只是因为比较好理解.</p><h4 id="索引能为我们带来什么？"><a href="#索引能为我们带来什么？" class="headerlink" title="索引能为我们带来什么？"></a>索引能为我们带来什么？</h4><p>如上面所说，索引能帮助我们快速的查找到数据，其次因为索引中的值是顺序储存，那么可以帮助我们进行orderby操作。而且索引中也是存储了真正的值的，因此有一些的查询直接可以在索引中完成。</p><p>总结下索引的优点:</p><p>1.减少查询需要扫描的数据量(加快了查询速度)</p><p>2.减少服务器的排序操作和创建临时表的操作(加快了groupby和orderby等操作)</p><p>3.将服务器的随机IO变为顺序IO(加快查询速度)。</p><p>索引有哪些缺点呢？</p><p>首先索引也是数据，也需要存储，因此会带来额外的存储空间占用。其次，在插入，更新和删除操作的同时，需要维护索引，因此会带来额外的事件开销。</p><p>索引占用磁盘或者内存空间。</p><p>减慢了插入更新操作的速度</p><p>实际上，在一定数据范围内(索引没有超级多的情况下)，建立索引带来的开销是远远小于它带来的好处，但是我们仍然要防止索引的滥用。</p><h4 id="都有哪些类型的索引？"><a href="#都有哪些类型的索引？" class="headerlink" title="都有哪些类型的索引？"></a>都有哪些类型的索引？</h4><p>对于Mysq来说，在服务器层并不实现索引，而不是交给存储引擎来实现的，因此不同的存储引擎实现的索引类型不同意义。INNODB作为当前使用最广泛的存储引擎，使用的是B+树索引，因此我们大部分事件提到的索引也都是指的它。</p><p>Mysql主要有以下几种索引：</p><p>B-树索引/B+树索引</p><p>哈希索引</p><p>空间数据索引</p><p>全文索引</p><h6 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h6><p>B-树是一颗多路平衡查找树，对于一颗M阶的B-树有以下的性质:</p><p>根节点至少有两个子女.<br>每个节点包含k-1个元素和k个孩子,其中m/2 &lt;= k &lt;= m.<br>每一个叶子节点都包含k-1个元素,其中m/2 &lt;= k &lt;= m.<br>所有的叶子节点位于同一层.<br>每个节点中的元素从小到大排列,那么k-1个元素正好是k个孩子包含的值域的划分.<br>这么说可能会有一些难理解,可以将B-树理解为一棵更加矮胖的二叉搜索树.</p><h6 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h6><p>B+树是B-树的进阶版本，在B-树的基础上有做了如下的限制:</p><p>1.每个中间节点不保存数据，只用来索引，也就意味着所有非叶子结点的值都被保存了一份在叶子节点中。</p><p>2.叶子节点之间根据自身的顺序进行了链接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Mysql主从复制&quot;&gt;&lt;a href=&quot;#Mysql主从复制&quot; class=&quot;headerlink&quot; title=&quot;Mysql主从复制&quot;&gt;&lt;/a&gt;Mysql主从复制&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;什么是主从复制？&quot;&gt;&lt;a href=&quot;#什么是主从复制？&quot; cl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vue拦截器</title>
    <link href="https://luckyle.top/Vue/vue%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://luckyle.top/Vue/vue%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2019-12-26T14:01:48.000Z</published>
    <updated>2019-12-27T00:43:36.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-router的beforeEach"><a href="#Vue-router的beforeEach" class="headerlink" title="Vue:router的beforeEach"></a>Vue:router的beforeEach</h1><h6 id="在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。"><a href="#在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。" class="headerlink" title="在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。"></a>在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。</h6><h6 id="定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。"><a href="#定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。" class="headerlink" title="定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。"></a>定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。</h6><p>两种函数：</p><p>​            1.Vue.beforeEach(function(to,form,next){}) /<em>在跳转之前执行</em>/</p><p>​            2.Vue.afterEach(function(to,form))/<em>在跳转之后判断</em>/</p><h3 id="beforeEach函数有三个参数："><a href="#beforeEach函数有三个参数：" class="headerlink" title="beforeEach函数有三个参数："></a>beforeEach函数有三个参数：</h3><ul><li>to:router即将进入的路由对象</li><li>from:当前导航即将离开的路由</li><li>next:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航。<a id="more"></a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//我们可以在main.js中定义一个白名单</span><br><span class="line">var witelist=[<span class="string">'Detail'</span>,<span class="string">'Order'</span>]  //定义白名单 需要登陆后访问页面</span><br><span class="line">//  router.beforEach  访问路由前</span><br><span class="line">// to:Route :即将要进入的路由对象</span><br><span class="line">// <span class="keyword">from</span> :Route:  当前导航正要离开的路由</span><br><span class="line">// next : Funcation  进行管道中的下一个钩子</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">router.beforeEach((to,from,next)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">//我们取出存取的token</span><br><span class="line">  let token = sessionStorage.getItem(<span class="string">'token'</span>);</span><br><span class="line">//判断它是否存在并且白名单定义的路由存在</span><br><span class="line">  <span class="keyword">if</span>(token|| whitelist.indexOf(to.name) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    console.log(<span class="string">'下一页！'</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">'请登陆后访问详情页'</span>)</span><br><span class="line">   </span><br><span class="line">    router.push(&#123;name:<span class="string">'Login'</span>&#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Vue-router的beforeEach&quot;&gt;&lt;a href=&quot;#Vue-router的beforeEach&quot; class=&quot;headerlink&quot; title=&quot;Vue:router的beforeEach&quot;&gt;&lt;/a&gt;Vue:router的beforeEach&lt;/h1&gt;&lt;h6 id=&quot;在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。&quot;&gt;&lt;a href=&quot;#在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。&quot; class=&quot;headerlink&quot; title=&quot;在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。&quot;&gt;&lt;/a&gt;在路由跳转的时候，我们需要一些权限判断或者其他操作。这个时候就需要使用路由的钩子函数。&lt;/h6&gt;&lt;h6 id=&quot;定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。&quot;&gt;&lt;a href=&quot;#定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。&quot; class=&quot;headerlink&quot; title=&quot;定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。&quot;&gt;&lt;/a&gt;定义：路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数。&lt;/h6&gt;&lt;p&gt;两种函数：&lt;/p&gt;
&lt;p&gt;​            1.Vue.beforeEach(function(to,form,next){}) /&lt;em&gt;在跳转之前执行&lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;​            2.Vue.afterEach(function(to,form))/&lt;em&gt;在跳转之后判断&lt;/em&gt;/&lt;/p&gt;
&lt;h3 id=&quot;beforeEach函数有三个参数：&quot;&gt;&lt;a href=&quot;#beforeEach函数有三个参数：&quot; class=&quot;headerlink&quot; title=&quot;beforeEach函数有三个参数：&quot;&gt;&lt;/a&gt;beforeEach函数有三个参数：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;to:router即将进入的路由对象&lt;/li&gt;
&lt;li&gt;from:当前导航即将离开的路由&lt;/li&gt;
&lt;li&gt;next:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航。
    
    </summary>
    
    
      <category term="Vue" scheme="https://luckyle.top/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>一万快的火腿</title>
    <link href="https://luckyle.top/Django/%E4%B8%80%E4%B8%87%E5%BF%AB%E7%9A%84%E7%81%AB%E8%85%BF/"/>
    <id>https://luckyle.top/Django/%E4%B8%80%E4%B8%87%E5%BF%AB%E7%9A%84%E7%81%AB%E8%85%BF/</id>
    <published>2019-12-26T09:45:37.000Z</published>
    <updated>2020-01-03T02:04:23.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="订单支付页面-支付方式-结账，优惠劵"><a href="#订单支付页面-支付方式-结账，优惠劵" class="headerlink" title="订单支付页面  支付方式(结账，优惠劵)"></a>订单支付页面  支付方式(结账，优惠劵)</h1><p>前言：支付宝沙箱环境(Beta)是协助开发者进行接口功能开发及主要功能联调的辅助环境。沙箱环境模拟了开放平台部分产品的主要功能和主要逻辑。在开发者应用上线审核前，开发者可以根据自身需求，先在沙箱环境中了解、组合和调试各种开放接口，进行开发调通工作，从而帮助开发者在应用上线审核完成后，能更快速、更顺利的进行线上调试和验收工作。<br>一、开通支付宝沙箱环境<br>沙箱环境地址：<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=info" target="_blank" rel="noopener">https://openhome.alipay.com/platform/appDaily.htm?tab=info</a><br>访问上面url，支付宝扫码登录，实名认证，根据提示创建应用，生成相应的沙箱应用环境。生成并上传RSA2(SHA256)的应用公钥，详见生成RSA密钥； <a id="more"></a></p><h3 id="生成优惠码脚本"><a href="#生成优惠码脚本" class="headerlink" title="生成优惠码脚本"></a>生成优惠码脚本</h3><h6 id="生成一个随机的串，用户输入到输入框中，使用优惠卷，价格打折！与库里对比，打折"><a href="#生成一个随机的串，用户输入到输入框中，使用优惠卷，价格打折！与库里对比，打折" class="headerlink" title="生成一个随机的串，用户输入到输入框中，使用优惠卷，价格打折！与库里对比，打折"></a>生成一个随机的串，用户输入到输入框中，使用优惠卷，价格打折！与库里对比，打折</h6><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">code = string.ascii_letters + string.digits</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> Code():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.<span class="keyword">join</span>(random.sample(code, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(Code())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> Mycode(<span class="keyword">group</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'-'</span>.<span class="keyword">join</span>(Code() <span class="keyword">for</span> i in range(<span class="keyword">group</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mycode = Mycode(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span>(Mycode)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> pymsql</span><br><span class="line"></span><br><span class="line"><span class="comment">#连接数据库</span></span><br><span class="line">conn=pymysql.connet(host=<span class="string">''</span>,user=<span class="string">''</span>,password=<span class="string">''</span>,db=<span class="string">''</span>,charset=<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string.ascii_letters  <span class="comment">#字符串</span></span><br><span class="line">string.digits <span class="comment">#数字 0-9</span></span><br><span class="line"><span class="comment">#定义随机串元素</span></span><br><span class="line">code=string.ascii_letters + string.digits      <span class="comment">#(字母+数字)</span></span><br><span class="line"><span class="comment">#随机码不能太短，定义获取四位的随机码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getcode</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">''</span>.join(random.sample(code,<span class="number">4</span>))  <span class="comment">#定义字符  定义字符长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义4列4位码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key</span><span class="params">(group)</span>:</span></span><br><span class="line"><span class="keyword">return</span>  <span class="string">'-'</span>.join([getcode() <span class="keyword">for</span> i <span class="keyword">in</span> range(group)])</span><br><span class="line"></span><br><span class="line">print(key(<span class="number">4</span>))</span><br><span class="line">mycode=key(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建游标对象</span></span><br><span class="line">cursor=conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义sql语句</span></span><br><span class="line">sql=<span class="string">"insert into 表名 (code,discount) values ('%s',%s)"</span> % (mycode,<span class="string">'0.8'</span>)</span><br><span class="line">print(sql)  <span class="comment">#展示sql语言，看是否完整</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#入库操作 ，执行sql</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line"><span class="comment">#提交事务 </span></span><br><span class="line">conn.commit()</span><br><span class="line"><span class="comment">#关闭游标</span></span><br><span class="line">cursor.close()</span><br><span class="line"><span class="comment">#关闭数据库连接</span></span><br><span class="line">conn.close</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#优惠卷表</span><br><span class="line">class Codes(models.Model):</span><br><span class="line">#主键</span><br><span class="line">id=models.AutoField(primary_key=True)</span><br><span class="line">#随机码</span><br><span class="line">code=models.CharField(max_length=100)</span><br><span class="line">#折扣  每种随机码对应相应的折扣</span><br><span class="line">discount=models.FloatField()   #打折，浮点</span><br><span class="line">#是否过期</span><br><span class="line">status=models.IntegerFiels(default=1)  #默认为一，1为可以使用</span><br><span class="line"></span><br><span class="line">#表名</span><br><span class="line">class Meta:</span><br><span class="line">db_table=&apos;codes&apos;</span><br></pre></td></tr></table></figure><p>ok,你会发现我们的优惠卷已经入库了！</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#序列化器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodesSer</span><span class="params">(serializer.ModelSerializer)</span>:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">model=model.Code</span><br><span class="line">fields=<span class="string">'__all__'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#优惠卷使用接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCode</span><span class="params">(APIbiew)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line"><span class="comment">#获取前端用户输入的优惠码</span></span><br><span class="line">code=request.GET.get(<span class="string">'code'</span>)</span><br><span class="line"><span class="comment">#与表中数据进行匹配获取单商品详情</span></span><br><span class="line">codes=Codes.objects.filter(code=code).first()</span><br><span class="line"><span class="comment">#序列化</span></span><br><span class="line">codes_ser=CoderSer(codes)   <span class="comment">#一条数据，所以我们不用加many=True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断优惠劵使用状态</span></span><br><span class="line">如果为一可以使用，当为<span class="number">0</span>时则优惠劵已被使用过！</span><br><span class="line"><span class="keyword">if</span> 优惠劵未被使 用 ==<span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">优惠劵被使用过，无效 Code码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">codes.statiss=<span class="number">0</span> </span><br><span class="line">codes.save()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> HttpResponse(codes_ser.data)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#优惠价:myprice</span><br><span class="line">#原价:price</span><br><span class="line"></span><br><span class="line">#前端输入Code码</span><br><span class="line">优惠劵:&lt;input type=&apos;text&apos; v-model=&apos;discount&apos;/&gt;  </span><br><span class="line">&lt;button @click=&apos;usecode&apos;&gt;使用优惠劵&lt;/button&gt;  #绑定事件我们把数据传到后代</span><br><span class="line">#实际上订单页面并不会只显示优惠劵的价格，还有商品原价。这样可以给用户视觉上的一个冲击，看优惠了多少！  优惠价 以及原价  当用户没有使用优惠卷的时候我们把优惠价隐藏</span><br><span class="line">&lt;span  v-show=&apos;myprice&apos;&gt;优惠价:&#123;&#123;myprice&#125;&#125;&lt;span&gt;</span><br><span class="line"></span><br><span class="line">#使用优惠劵</span><br><span class="line">usecode()&#123;</span><br><span class="line">//调用接口，数据传给后台</span><br><span class="line">//设置优惠价</span><br><span class="line">var totalprice=this.totalprice;</span><br><span class="line">this.myprice= totalprice * 优惠折扣   #优惠价=商品原价*后台返回的折扣</span><br><span class="line"></span><br><span class="line">//这有一个判断，当用户在此输入用过的优惠码时，显示当前优惠码已被使用</span><br><span class="line">if 优惠码使用状态为0时&#123;</span><br><span class="line">显示该优惠劵已被使用过</span><br><span class="line">return    #返回，不做任何处理</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="所谓的重置按钮就是当你点击事件时把你当前输入的数据反空"><a href="#所谓的重置按钮就是当你点击事件时把你当前输入的数据反空" class="headerlink" title="所谓的重置按钮就是当你点击事件时把你当前输入的数据反空"></a>所谓的重置按钮就是当你点击事件时把你当前输入的数据反空</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&apos;rest&apos;&gt;重置&lt;button&gt;</span><br><span class="line"></span><br><span class="line">rest()&#123;</span><br><span class="line">this.username ==&apos;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="订单"><a href="#订单" class="headerlink" title="订单"></a>订单</h3><p>订单id  价格  订单用户 订单号</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#订单表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orders</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"><span class="comment">#主键</span></span><br><span class="line">id=models.AutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#订单id 一般来说订单id由时间戳(订单涉及钱财，如果用户订单出错，技术人员通过订单号来判断这是那个具体时间的订单)一般来说，大点的公司会进行分表这样存储， 方便(那张表，那个月份)</span></span><br><span class="line">orderid=models.CharField()</span><br><span class="line"><span class="comment">#用户id</span></span><br><span class="line">uid=models.IntegerField()</span><br><span class="line"><span class="comment">#价格</span></span><br><span class="line">price=models.IntegerField()</span><br><span class="line"><span class="comment">#支付状态</span></span><br><span class="line">status=models.IntegerField(default=<span class="number">0</span>)  <span class="comment">#0:待支付</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">db_table=<span class="string">'orders'</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="comment">#订单入库,当调用这个方法时，即使用时间戳并生成顶单id</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orders</span><span class="params">(APIview)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line"><span class="comment">#接收参数   用户id  价格</span></span><br><span class="line"><span class="comment">#后台验证签名，验签</span></span><br><span class="line">sign=request.GET.get(<span class="string">'sign'</span>,<span class="string">''</span>)</span><br><span class="line">md5=hashlib.md5()</span><br><span class="line"><span class="comment">#定义加密对象</span></span><br><span class="line">sign_str=<span class="string">''</span>  我们在前台生成的md5-js对象  <span class="comment">#要与前台加密对象一致</span></span><br><span class="line"><span class="comment">#转码</span></span><br><span class="line">sign_utf8=str(sign_str).encode(encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment">#加密</span></span><br><span class="line">md5.update(sign_utf<span class="number">-8</span>)</span><br><span class="line"><span class="comment">#生成密文</span></span><br><span class="line">md5_server=md5.hexdigest()</span><br><span class="line">print(md5_server)</span><br><span class="line"><span class="comment">#然后我们比对在前端加密和后端的md5加密，如果相同下一步，否则信息已被纂改</span></span><br><span class="line"><span class="comment">#比对签名</span></span><br><span class="line"><span class="keyword">if</span> 前端加密 ！= 后台加密:</span><br><span class="line">订单信息被纂改</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">数据一致，进行订单入库操作</span><br><span class="line"><span class="comment">#订单号是我们自己生成的</span></span><br><span class="line"><span class="comment">#根据时间戳生成订单号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进行入库逻辑</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">订单号的用处:</span><br><span class="line">1.方便我们好查</span><br><span class="line">2.防止订单号重复(使用时间戳)</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">#定义订单号</span><br><span class="line">def get_order_code():</span><br><span class="line">#注意 Y：year m:month  d:day  H:小时   M：分钟 S：秒</span><br><span class="line">order_no=time.strftime(&apos;%Y%m%d%H%M%S&apos;,time.localtime(time.time()))</span><br><span class="line"></span><br><span class="line">return order_no</span><br></pre></td></tr></table></figure><h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h3><p>初始化订单数据，展示我的订单详情页面、也就是说当我们在购物车中点击去支付的时候展示当前订单信息</p><h5 id="前端MD5加密——js-md5"><a href="#前端MD5加密——js-md5" class="headerlink" title="前端MD5加密——js-md5"></a>前端MD5加密——js-md5</h5><h6 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h6><p>是通过前台js加密的方式对密码等私密信息进行加密的工具</p><h6 id="2-js加密的好处"><a href="#2-js加密的好处" class="headerlink" title="2.js加密的好处"></a>2.js加密的好处</h6><p>（1）用js对私密信息加密可避免在网络中传输明文信息,被人截取数据包而造成数据泄露。<br>（2）避免缓存中自动缓存密码。比如在使用谷歌浏览器登陆时,输入的用户名和密码会自动缓存,下次登陆时无需输入密码就可以实现登陆,这样就给别人留下漏洞,当别人用你电脑登陆或把input的type改为test 那么你的密码就泄露了.使用js加密时,缓存的加密后的密文,用密文做密码登陆是不成功的,即使泄露也是泄露的密文,对密码不会造成威胁，缺点是每次登陆时都要手动输入密码，较麻烦。<br>（3）使用js加密,减少了服务器加密时的资源消耗,从理论上提高了服务器的性能。为了安全,很有必要再做服务器端的加密.无论从理论还是实际,两道门比一道门要安全些.至少给攻击者造成了一个障碍。</p><h6 id="3-安装使用"><a href="#3-安装使用" class="headerlink" title="3.安装使用"></a>3.安装使用</h6><p>（1）安装</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install js-md5</span><br></pre></td></tr></table></figure><p>（2）main.js中引入</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import <span class="built_in">md5</span> <span class="keyword">from</span> 'js-<span class="built_in">md5</span>';</span><br><span class="line">Vue.prototype.$<span class="built_in">md5</span> = <span class="built_in">md5</span>;</span><br></pre></td></tr></table></figure><p>（3）使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$md5(<span class="string">"加密内容"</span>)</span><br></pre></td></tr></table></figure><h5 id="支付签名"><a href="#支付签名" class="headerlink" title="支付签名"></a>支付签名</h5><h6 id="进行签名验证-价签-md5-js-不可逆，防止恶意纂改数据，进行入库操作"><a href="#进行签名验证-价签-md5-js-不可逆，防止恶意纂改数据，进行入库操作" class="headerlink" title="进行签名验证(价签) md5-js 不可逆，防止恶意纂改数据，进行入库操作"></a>进行签名验证(价签) md5-js 不可逆，防止恶意纂改数据，进行入库操作</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    //结账</span><br><span class="line">    checkout(totalprice)&#123;</span><br><span class="line">        //判断是否优惠劵</span><br><span class="line">        <span class="keyword">if</span>(this.myprice !=<span class="number">0</span>)&#123;</span><br><span class="line">            totalprice=this.myprice</span><br><span class="line">        &#125;</span><br><span class="line">        //进行签名验证(价签)</span><br><span class="line">        var sign =<span class="string">'mysign'</span> + <span class="string">'price='</span>+totalprice;</span><br><span class="line">        sign = md5(sign)</span><br><span class="line">        console.log(sign)</span><br><span class="line">        //使用箭头函数吧参数传过去</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="沙箱应用"><a href="#沙箱应用" class="headerlink" title="沙箱应用"></a>沙箱应用</h5><p>网页登陆支付宝—&gt;开发者中心—–&gt;沙箱环境—–&gt;沙箱应用—&gt;查看appid 应用公钥  私钥等配置信息。</p><p>我们用沙箱账号中的买家信息登陆 沙箱版钱包。</p><p> 支付宝加密RSA 所以我们也用RSA加密和支付宝的所匹配以防纂改信息</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> cryptography      <span class="comment">#这是一个库，加密搞的</span></span><br></pre></td></tr></table></figure><h5 id="支付宝支付接口：一万的火腿"><a href="#支付宝支付接口：一万的火腿" class="headerlink" title="支付宝支付接口：一万的火腿"></a>支付宝支付接口：一万的火腿</h5><h6 id="RSA签名验签工具-—-gt-非Java使用—-gt-生成public-key-和-private-key-俩个文件加头尾标识我们用工具生成的公钥与私钥。把商户应用公钥放到应用公钥，公钥上传成功后，会自动生成支付宝公钥，我们把支付宝公钥放到本地的public-key-公钥-，私钥不变。"><a href="#RSA签名验签工具-—-gt-非Java使用—-gt-生成public-key-和-private-key-俩个文件加头尾标识我们用工具生成的公钥与私钥。把商户应用公钥放到应用公钥，公钥上传成功后，会自动生成支付宝公钥，我们把支付宝公钥放到本地的public-key-公钥-，私钥不变。" class="headerlink" title="RSA签名验签工具 —&gt; 非Java使用—&gt;生成public_key   和 private_key. 俩个文件加头尾标识我们用工具生成的公钥与私钥。把商户应用公钥放到应用公钥，公钥上传成功后，会自动生成支付宝公钥，我们把支付宝公钥放到本地的public_key(公钥)，私钥不变。"></a>RSA签名验签工具 —&gt; 非Java使用—&gt;生成public_key   和 private_key. 俩个文件加头尾标识我们用工具生成的公钥与私钥。把商户应用公钥放到应用公钥，公钥上传成功后，会自动生成支付宝公钥，我们把支付宝公钥放到本地的public_key(公钥)，私钥不变。</h6><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#公钥</span><br><span class="line"></span><br><span class="line">-----<span class="keyword">BEGIN</span> <span class="keyword">PUBLIC</span> KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApF51QND1p2rOvjx90zERrkDyRyEvdAzijGyjzch1fHgmrYVWMU9DboyWHKACLutwjSV5etTK90cN6rqs64KzRtWzgarjcUpzXpdxTINpn2KsUXHJQYHaz6tvodNdEIf4OB1PKzmNkMWMlBh0Z+KK5RQlU0yGedXbcGvh1dJqCdqhakppRa+DumIdC6IIgagT/Dz3X6kSw9mdxcn73JyJ6XGCSkifUJUtfX94oXg01L1jmtXPV5HJH/wzLVXVJVuRRmRNug6TssmRwowbsFIAiq9rX/mH1tIWbnc/MEPzJMWeKb<span class="comment">//JlNPPXbocAJaH17taDGOF2cyOgTtWomMUxgouQIDAQAB</span></span><br><span class="line">-----<span class="keyword">END</span> <span class="keyword">PUBLIC</span> KEY-----</span><br></pre></td></tr></table></figure><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#私钥</span><br><span class="line">-----<span class="keyword">BEGIN</span> RSA <span class="keyword">PRIVATE</span> KEY-----</span><br><span class="line">MIIEowIBAAKCAQEAxckxbXy+we5P7xFoeEK7DmWPpC2vlpFHUhpS8ZA7omHAx4O0</span><br><span class="line">S6sW+ZijxLUcMKOhCNI78bQQwRkRwwXIEaVl9ob1j1ysCRDXxOmvvMntV6WFoWRe</span><br><span class="line">bJ2suGBwvmaeE+dgdSLdFdCvalVMHWhEJGOv/UbD6uuS3zL6fBPMpr2Tcm7gs/h5</span><br><span class="line">fPA8hBAekYRHP5yZk4+<span class="number">3</span>vh3LZxGVzWZU6AstOdCdXDEtYEx5bbKj035d6Yr9UEHy</span><br><span class="line">FWULy+Jp50a+HyDqNQcCAH3V0Ty+/wYk7H8/Oong4N4V+eZOgBcgYIeQaTkgsfMT</span><br><span class="line">UKOsGZgxJMCu7UT0yDJ0q9DakJqbGxZKdfXrAwIDAQABAoIBAE/hq2HiARVIT+Zp</span><br><span class="line">bH0tzmjJIhOYFBPGxzxkv10q+Lrjqj2qdtYc2qGiQXp<span class="comment">//0uxuqdaabV8GUwz+NWA</span></span><br><span class="line">b0aZO64u4dyt/BmJQOwZyc2A7Kf6hRci93P81rZ81OxBe9TkHTQSCaL27vIOUziJ</span><br><span class="line">VQQxcvHjc9tcm6wj5cDZKk2pwXR0l+tGkThuwb/fwycREZ7YB8lA8gKQ519KgC3T</span><br><span class="line">eTkWepiinl7S00D/plAANnjj6xbn16mQG1/Vx4yXG1CC/xemfpMiOh4BN9urrvqe</span><br><span class="line">etueSKr7we5rBy9IAyxqeXfCTg2FlS7w19/+Y7ToZhWEXuHc4CiaMrI9tu9os51C</span><br><span class="line">TDmer3ECgYEA4/JMKjO1MzEJmhKKA1ye8Qxaw7feVh1pa8rTcY175MWbe5Dt7NFA</span><br><span class="line">EVK37BQUgm3S872UbdkvuVASpiPTvnH3HPClROendIGalOA87qvzSaGYgBOx0gHH</span><br><span class="line">bZNH8fFakd0gIw+s5sfQHdUbFlE1JS79scc8tJVrgAjfrZb2N7zDLrkCgYEA3iCn</span><br><span class="line">cKdEyKJKKT7I0R0SntWZN5ODcOoLNRS7HLiF54/T6/n3JRfHMWpUnI9BHtG9VP0n</span><br><span class="line"><span class="number">2</span>rhS2J3jZi8SokLOxQpEOlfa3ARTDbE2AREJui6AdkLgts7SEkGVx/Dsd3RqSL+<span class="number">0</span></span><br><span class="line">btrW+<span class="number">38</span>qc1omueV4bDhJy2E4yOb/<span class="number">9</span>s+dGqU1KZsCgYBz81etC/p7XNFuj0mnJiEv</span><br><span class="line">qsIs1sYBdhqfG2BtXbQNDjvmIjX1BggaB8LJEvnP0v/AvsnXCuiM0l96JbVbJeu2</span><br><span class="line">y+<span class="number">6120</span>TCLf8tBdfY7Jzn8ox5cgs9MWx5n7a0KrqQgjQLwbiI+FE0K6gItSxcise/</span><br><span class="line">/AI0NeGmEl19ltIOTjXW+QKBgDbvPHnP5GL6P/<span class="number">0</span>TWfbdic1eZhYolUlHmJ34Eo53</span><br><span class="line"><span class="number">1</span>CYAnBiwKT8zMkA2W9acVy6YEIsEUOb2zwZjhemvmpwmiZyRfW4wbCAdsayhNwns</span><br><span class="line">fMte1MZqo8iSPcHmFnTsUI76a46yWp1P4fsw5/<span class="number">6</span>/PPScm7un8BgsYy7McmFH10LP</span><br><span class="line">uOYhAoGBAJQ8+XlmOxdrmrzWRPfA/FJoDu1OGr8alSKHdkHmKc/r7vmnUXmhDEBl</span><br><span class="line"><span class="number">4</span>IU64GqPCS0gFCoRz/vo0JwcDBvSdMnD0Gj9IgzTyYvzxLRL8G4cAH9EXbp1hjSC</span><br><span class="line">pJpenui4fA7HsFdNJDLRxkg2yONiXFnpK55ylFGyk4NHGqqXmAIU</span><br><span class="line">-----<span class="keyword">END</span> RSA <span class="keyword">PRIVATE</span> KEY-----</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5Clenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1577353504404.png" alt="1577353504404"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> alipay</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> alipay <span class="keyword">import</span> AliPay</span><br><span class="line"><span class="keyword">from</span> web.settings <span class="keyword">import</span> BASE_DIR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">appid=<span class="string">'2016092600603658'</span></span><br><span class="line"><span class="keyword">def</span> Alpay():</span><br><span class="line">    <span class="keyword">ali</span> = AliPay(</span><br><span class="line">        appid=<span class="string">'2016092600603658'</span>,</span><br><span class="line">        app_notify_url=<span class="keyword">None</span>,</span><br><span class="line">        alipay_public_key_path=os.path.join(BASE_DIR,<span class="string">'public_key.txt'</span>),</span><br><span class="line">        app_private_key_path=os.path.join(BASE_DIR,<span class="string">'private_key.txt'</span>),</span><br><span class="line">        debug=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">data</span> = &#123;</span><br><span class="line">        <span class="string">'subject'</span>: <span class="string">'大火腿'</span>,</span><br><span class="line">        <span class="string">'out_trade_no'</span>: <span class="keyword">str</span>(random.randint(<span class="number">10000000000</span>,<span class="number">99999999999</span>)),</span><br><span class="line">        <span class="string">'total_amount'</span>: <span class="keyword">str</span>(<span class="number">9999999.99</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    order_str = ali.api_alipay_trade_page_pay(**<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">    request_url = <span class="string">'https://openapi.alipaydev.com/gateway.do?'</span> + order_str</span><br><span class="line"></span><br><span class="line">    print(request_url)</span><br><span class="line"></span><br><span class="line">Alpay()</span><br></pre></td></tr></table></figure><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import render, redirect, HttpResponse</span><br><span class="line">from utils.pay import AliPay</span><br><span class="line">import time</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def ali():</span><br><span class="line">    # 沙箱环境地址：https:<span class="comment">//openhome.alipay.com/platform/appDaily.htm?tab=info</span></span><br><span class="line">    app_id = "2016092400583356"</span><br><span class="line">    # 支付宝收到用户的支付,会向商户（我）发两个请求,一个get请求,一个post请求 - 用于表示支付成功<span class="keyword">or</span>失败</span><br><span class="line">    # POST请求，用于最后的检测</span><br><span class="line">    notify_url = "http://42.56.89.12:80/page2/"</span><br><span class="line">    # GET请求，用于页面的跳转展示</span><br><span class="line">    return_url = "http://42.56.89.12:80/page2/"</span><br><span class="line">    # 私钥文件</span><br><span class="line">    merchant_private_key_path = "keys/app_private_2048.txt"</span><br><span class="line">    # 阿里公钥文件</span><br><span class="line">    alipay_public_key_path = "keys/alipay_public_2048.txt"</span><br><span class="line">    # 生成一个AliPay的对象</span><br><span class="line">    alipay = AliPay(</span><br><span class="line">        appid=app_id,</span><br><span class="line">        app_notify_url=notify_url,</span><br><span class="line">        return_url=return_url,</span><br><span class="line">        app_private_key_path=merchant_private_key_path,</span><br><span class="line">        alipay_public_key_path=alipay_public_key_path,  # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥</span><br><span class="line">        debug=True,  # 默认False,</span><br><span class="line">    )</span><br><span class="line">    return alipay</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def page1(request):</span><br><span class="line">    if request.method == "GET":</span><br><span class="line">        return render(request, <span class="string">'page1.html'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        money = float(request.POST.get(<span class="string">'money'</span>))</span><br><span class="line">        # 执行支付配置方法，生成一个对象</span><br><span class="line">        alipay = ali()</span><br><span class="line">        # 生成支付的url</span><br><span class="line">        # query_params:对象调用direct_pay</span><br><span class="line">        query_params = alipay.direct_pay(</span><br><span class="line">            subject="TEST商品",  # 商品简单描述</span><br><span class="line">            out_trade_no="x2" + str(time.time()),  # 商户订单号</span><br><span class="line">            total_amount=money,  # 交易金额(单位: 元 保留俩位小数)</span><br><span class="line">        )</span><br><span class="line">        # alipaydev,！！带着dev的都是沙箱环境！！</span><br><span class="line">        pay_url = "https://openapi.alipaydev.com/gateway.do?&#123;&#125;".format(query_params)</span><br><span class="line">        print(pay_url)</span><br><span class="line">        # 朝这个地址发get请求</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#定义批量删除逻辑</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group_Del</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment">#定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#接收参数</span></span><br><span class="line">        ids = request.POST.get(<span class="string">"ids"</span>)</span><br><span class="line">        <span class="comment">#使用eval方法来强转为list</span></span><br><span class="line">        ids = eval(<span class="string">"["</span>+ids+<span class="string">"]"</span>)</span><br><span class="line">        <span class="comment">#删除操作</span></span><br><span class="line">        Product.objects.filter(id__in=ids).delete()</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义批量操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoEditCart</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment">#定义post请求</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#获取参数</span></span><br><span class="line">        id = request.POST.get(<span class="string">"id"</span>)</span><br><span class="line">        count = request.POST.get(<span class="string">"count"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#读取库存</span></span><br><span class="line">        <span class="comment"># procount = Product.objects.filter(id=int(id)).values("count")</span></span><br><span class="line">        <span class="comment"># print(procount)</span></span><br><span class="line">        <span class="comment"># procount = procount[0]['count']</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#使用get方法</span></span><br><span class="line">        procount = Product.objects.get(id=int(id))</span><br><span class="line">        procount = procount.count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        print(procount)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#比对逻辑</span></span><br><span class="line">        <span class="keyword">if</span> int(count) &gt; procount:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">'库存不足'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#获取购物车</span></span><br><span class="line">        cartlist = request.session.get(<span class="string">"cartlist"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#清除购物车商品</span></span><br><span class="line">        cartlist_new = filter(<span class="keyword">lambda</span> n:n!=int(id),cartlist)</span><br><span class="line">        <span class="comment">#强转数据类型</span></span><br><span class="line">        cartlist_new = list(cartlist_new)</span><br><span class="line">        <span class="comment">#将购买数量添加到购物车</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(int(count)):</span><br><span class="line">            cartlist_new.append(int(id))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#将购物车重新赋值</span></span><br><span class="line">        request.session[<span class="string">'cartlist'</span>] = cartlist_new</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#原生sql定义用户详情页</span></span><br><span class="line"><span class="comment">#导入数据库连接方法</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment">#定义get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#获取用户名</span></span><br><span class="line">        username = request.COOKIES.get(<span class="string">'username'</span>)</span><br><span class="line">        <span class="comment">#定义游标</span></span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line">        <span class="comment">#execute执行sql语句</span></span><br><span class="line">        cursor.execute(<span class="string">" select c.name,c.id from user as a left join user2group as b on a.id = b.uid left join usergroup as c on b.gid = c.id where a.username =  '%s' "</span> % username )</span><br><span class="line">        <span class="comment">#调用fetchone fetchall</span></span><br><span class="line">        res = cursor.fetchall()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#查询普通用户的所有账号</span></span><br><span class="line">        cursor.execute(<span class="string">" select c.id,c.username from usergroup as a left join user2group as b on a.id = b.gid left join user as c on b.uid = c.id where a.name = '普通用户' "</span>)</span><br><span class="line">        <span class="comment">#调用fetchone fetchall</span></span><br><span class="line">        res_normal = cursor.fetchall()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">#将游标关闭</span></span><br><span class="line">        cursor.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'supermarket/userinfo.html'</span>,locals())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;订单支付页面-支付方式-结账，优惠劵&quot;&gt;&lt;a href=&quot;#订单支付页面-支付方式-结账，优惠劵&quot; class=&quot;headerlink&quot; title=&quot;订单支付页面  支付方式(结账，优惠劵)&quot;&gt;&lt;/a&gt;订单支付页面  支付方式(结账，优惠劵)&lt;/h1&gt;&lt;p&gt;前言：支付宝沙箱环境(Beta)是协助开发者进行接口功能开发及主要功能联调的辅助环境。沙箱环境模拟了开放平台部分产品的主要功能和主要逻辑。在开发者应用上线审核前，开发者可以根据自身需求，先在沙箱环境中了解、组合和调试各种开放接口，进行开发调通工作，从而帮助开发者在应用上线审核完成后，能更快速、更顺利的进行线上调试和验收工作。&lt;br&gt;一、开通支付宝沙箱环境&lt;br&gt;沙箱环境地址：&lt;a href=&quot;https://openhome.alipay.com/platform/appDaily.htm?tab=info&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://openhome.alipay.com/platform/appDaily.htm?tab=info&lt;/a&gt;&lt;br&gt;访问上面url，支付宝扫码登录，实名认证，根据提示创建应用，生成相应的沙箱应用环境。生成并上传RSA2(SHA256)的应用公钥，详见生成RSA密钥；
    
    </summary>
    
    
      <category term="Django" scheme="https://luckyle.top/categories/Django/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>cenos7下安装Python3.7</title>
    <link href="https://luckyle.top/Installs/cenos7%E4%B8%8B%E5%AE%89%E8%A3%85Python3-7/"/>
    <id>https://luckyle.top/Installs/cenos7%E4%B8%8B%E5%AE%89%E8%A3%85Python3-7/</id>
    <published>2019-12-22T11:51:59.000Z</published>
    <updated>2019-12-25T08:23:33.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>需要先sudo到root用户<a id="more"></a></p><h4 id="安装相关编译工具"><a href="#安装相关编译工具" class="headerlink" title="安装相关编译工具"></a>安装相关编译工具</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y groupinstall &quot;Development tools&quot;</span><br><span class="line">yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span><br><span class="line">yum install libffi-devel -y</span><br></pre></td></tr></table></figure><h4 id="下载并解压安装包"><a href="#下载并解压安装包" class="headerlink" title="下载并解压安装包"></a>下载并解压安装包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd 你自己的目录</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz</span><br><span class="line">tar -xvJf  Python-3.7.0.tar.xz</span><br></pre></td></tr></table></figure><h4 id="编译及安装"><a href="#编译及安装" class="headerlink" title="编译及安装"></a>编译及安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/python3 <span class="comment">#创建编译安装目录</span></span><br><span class="line"><span class="built_in">cd</span> Python-3.7.0</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/<span class="built_in">local</span>/bin/python3</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3 /usr/<span class="built_in">local</span>/bin/pip3</span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -V</span><br><span class="line">pip3 -V</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;&lt;p&gt;需要先sudo到root用户
    
    </summary>
    
    
      <category term="Installs" scheme="https://luckyle.top/categories/Installs/"/>
    
    
      <category term="Installs" scheme="https://luckyle.top/tags/Installs/"/>
    
  </entry>
  
  <entry>
    <title>Firewalld未运行</title>
    <link href="https://luckyle.top/Linux/Firewalld%E6%9C%AA%E8%BF%90%E8%A1%8C/"/>
    <id>https://luckyle.top/Linux/Firewalld%E6%9C%AA%E8%BF%90%E8%A1%8C/</id>
    <published>2019-12-22T11:44:03.000Z</published>
    <updated>2019-12-25T08:23:53.617Z</updated>
    
    <content type="html"><![CDATA[<p>最近在阿里云服务器centos上安装了mysql数据库，默认是不开启远端访问功能，需要设置一下防火墙，在开放默认端口号 3306时提示FirewallD is not running，经过排查发现是防火墙就没打开造成的，出于安装考虑还是把防火墙开上吧，以下步骤仅供参考啦。<a id="more"></a></p><h2 id="工具-原料"><a href="#工具-原料" class="headerlink" title="工具/原料"></a>工具/原料</h2><ul><li>阿里云服务器centos</li></ul><h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h2><ol><li><p>执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示FirewallD is not running</p></li></ol><ol start="2"><li><p>通过systemctl status firewalld查看firewalld状态，发现当前是dead状态，即防火墙未开启。</p></li></ol><ol start="3"><li><p>通过systemctl start firewalld开启防火墙，没有任何提示即开启成功。</p></li></ol><ol start="4"><li><p>再次通过systemctl status firewalld查看firewalld状态，显示running即已开启了。</p></li></ol><ol start="5"><li><p>如果要关闭防火墙设置，可能通过systemctl stop firewalld这条指令来关闭该功能。</p></li></ol><ol start="6"><li><p>再次执行执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示success，表示设置成功，这样就可以继续后面的设置了。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在阿里云服务器centos上安装了mysql数据库，默认是不开启远端访问功能，需要设置一下防火墙，在开放默认端口号 3306时提示FirewallD is not running，经过排查发现是防火墙就没打开造成的，出于安装考虑还是把防火墙开上吧，以下步骤仅供参考啦。
    
    </summary>
    
    
      <category term="Linux" scheme="https://luckyle.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://luckyle.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis简介</title>
    <link href="https://luckyle.top/Redis/Redis/"/>
    <id>https://luckyle.top/Redis/Redis/</id>
    <published>2019-12-21T11:03:16.000Z</published>
    <updated>2020-01-12T12:58:57.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reids的特点"><a href="#Reids的特点" class="headerlink" title="Reids的特点"></a>Reids的特点</h2><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p><p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。<a id="more"></a></p><p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。</p><p>比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。</p><p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h3 id="使用redis有哪些好处？"><a href="#使用redis有哪些好处？" class="headerlink" title="使用redis有哪些好处？"></a>使用redis有哪些好处？</h3><p>1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>2.支持丰富数据类型，支持string，list，set，sorted set，hash</p><p>3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p><p>4.丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h3 id="为什么redis需要把所有数据放到内存中"><a href="#为什么redis需要把所有数据放到内存中" class="headerlink" title="为什么redis需要把所有数据放到内存中?"></a>为什么redis需要把所有数据放到内存中?</h3><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p><p>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><h3 id="Redis是单进程单线程的"><a href="#Redis是单进程单线程的" class="headerlink" title="Redis是单进程单线程的"></a>Redis是单进程单线程的</h3><p>redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销</p><h3 id="单线程的redis为什么这么快"><a href="#单线程的redis为什么这么快" class="headerlink" title="单线程的redis为什么这么快"></a>单线程的redis为什么这么快</h3><p>回答:主要是以下三点</p><p>(一)纯内存操作</p><p>(二)单线程操作，避免了频繁的上下文切换</p><p>(三)采用了非阻塞I/O多路复用机制</p><h3 id="redis持久化的几种方式"><a href="#redis持久化的几种方式" class="headerlink" title="redis持久化的几种方式"></a>redis持久化的几种方式</h3><p>1、快照（snapshots）</p><p>缺省情况情况下，Redis把数据快照存放在磁盘上的二进制文件中，文件名为dump.rdb。你可以配置Redis的持久化策略，例如数据集中每N秒钟有超过M次更新，就将数据写入磁盘；或者你可以手工调用命令SAVE或BGSAVE。</p><p>工作原理</p><p>Redis forks.</p><p>子进程开始将数据写到临时RDB文件中。</p><p>当子进程完成写RDB文件，用新文件替换老文件。</p><p>这种方式可以使Redis使用copy-on-write技术。</p><p>2、AOF</p><p>快照模式并不十分健壮，当系统停止，或者无意中Redis被kill掉，最后写入Redis的数据就会丢失。</p><p>这对某些应用也许不是大问题，但对于要求高可靠性的应用来说，Redis就不是一个合适的选择。Append-only文件模式是另一种选择。你可以在配置文件中打开AOF模式</p><p>3、虚拟内存方式</p><p>当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大.</p><p>当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value.</p><p>vm-max-threads这个参数,可以设置访问swap文件的线程数,设置最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证.</p><p>自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库。</p><h3 id="使用过Redis分布式锁么，"><a href="#使用过Redis分布式锁么，" class="headerlink" title="使用过Redis分布式锁么，"></a>使用过Redis分布式锁么，</h3><p>它是什么回事？先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p><h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h3 id="使用过Redis做异步队列么，你是怎么用的？"><a href="#使用过Redis做异步队列么，你是怎么用的？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？"></a>使用过Redis做异步队列么，你是怎么用的？</h3><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。 如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p><h3 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h3><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h3 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h3><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h3 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h3><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h3 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h3><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p><h3 id="什么是Redis的并发竞争问题"><a href="#什么是Redis的并发竞争问题" class="headerlink" title="什么是Redis的并发竞争问题"></a>什么是Redis的并发竞争问题</h3><p>Redis的并发竞争问题，主要是发生在并发写竞争。</p><p>考虑到redis没有像db中的sql语句，update val = val + 10 where …，无法使用这种方式进行对数据的更新。</p><p>假如有某个key = “price”， value值为10，现在想把value值进行+10操作。正常逻辑下，就是先把数据key为price的值读回来，加上10，再把值给设置回去。如果只有一个连接的情况下，这种方式没有问题，可以工作得很好，但如果有两个连接时，两个连接同时想对还price进行+10操作，就可能会出现问题了。</p><p>例如：两个连接同时对price进行写操作，同时加10，最终结果我们知道，应该为30才是正确。</p><p>考虑到一种情况：</p><p>T1时刻，连接1将price读出，目标设置的数据为10+10 = 20。</p><p>T2时刻，连接2也将数据读出，也是为10，目标设置为20。</p><p>T3时刻，连接1将price设置为20。</p><p>T4时刻，连接2也将price设置为20，则最终结果是一个错误值20。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用乐观锁的方式进行解决（成本较低，非阻塞，性能较高）</p><p>如何用乐观锁方式进行解决？</p><p>本质上是假设不会进行冲突，使用redis的命令watch进行构造条件。伪代码如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">watch price</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">get</span> price <span class="variable">$price</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$price</span> = <span class="variable">$price</span> + 10</span><br><span class="line"></span><br><span class="line">multi</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> price <span class="variable">$price</span></span><br><span class="line"></span><br><span class="line">exec</span><br></pre></td></tr></table></figure><p>watch这里表示监控该key值，后面的事务是有条件的执行，如果从watch的exec语句执行时，watch的key对应的value值被修改了，则事务不会执行。</p><p>方案2 这个是针对客户端来的，在代码里要对redis操作的时候，针对同一key的资源，就先进行加锁（java里的synchronized或lock）。</p><p>方案3 利用redis的setnx实现内置的锁。</p><h3 id="redis和memcached的区别（总结）"><a href="#redis和memcached的区别（总结）" class="headerlink" title="redis和memcached的区别（总结）"></a>redis和memcached的区别（总结）</h3><p>1、Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；</p><p>2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；</p><p>3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；</p><p>4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10；</p><p>5、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从；</p><p>6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；</p><p>7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；</p><p>8、Redis支持数据的备份，即master-slave模式的数据备份；</p><p>应用场景</p><p>redis：数据量较小的更性能操作和运算上</p><p>memcache：用于在动态系统中减少数据库负载，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）</p><p>MongoDB:主要解决海量数据的访问效率问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Reids的特点&quot;&gt;&lt;a href=&quot;#Reids的特点&quot; class=&quot;headerlink&quot; title=&quot;Reids的特点&quot;&gt;&lt;/a&gt;Reids的特点&lt;/h2&gt;&lt;p&gt;Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。&lt;/p&gt;
&lt;p&gt;因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。
    
    </summary>
    
    
      <category term="Redis" scheme="https://luckyle.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://luckyle.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>八大查找</title>
    <link href="https://luckyle.top/Python/%E5%85%AB%E5%A4%A7%E6%9F%A5%E6%89%BE/"/>
    <id>https://luckyle.top/Python/%E5%85%AB%E5%A4%A7%E6%9F%A5%E6%89%BE/</id>
    <published>2019-12-21T11:01:14.000Z</published>
    <updated>2019-12-25T08:23:09.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>算法简介 顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。 基本思路 从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。 优缺点 缺点：是当n 很大时，平均查找长度较大，效率低； 优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。 算法实现 <a id="more"></a></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def sequential_search(lis, <span class="meta">key</span>):</span><br><span class="line">  <span class="meta">length</span> = l<span class="meta">en(</span>lis)</span><br><span class="line">  for i <span class="meta">in</span><span class="meta"> range(</span><span class="meta">length</span>):</span><br><span class="line">    <span class="meta">if</span> lis[i] == <span class="meta">key</span>:</span><br><span class="line">      <span class="meta">return</span> i</span><br><span class="line">    <span class="meta">else</span>:</span><br><span class="line">      <span class="meta">return</span> False</span><br></pre></td></tr></table></figure><h1 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h1><p>二分查找（Binary Search），是一种在有序数组中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。 这种查找算法每一次比较都使查找范围缩小一半。</p><p>算法描述 给予一个包含 个带值元素的数组A 1、 令 L为0 ， R为 n-1 2、 如果L&gt;R，则搜索以失败告终 3、 令 m (中间值元素)为 ⌊(L+R)/2⌋ 4、 如果 AmT，令 R为 m - 1 并回到步骤二 复杂度分析 时间复杂度：折半搜索每次把搜索区域减少一半，时间复杂度为 O(logn) 空间复杂度：O(1)</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def binary_search(lis, key):</span><br><span class="line">  low = <span class="number">0</span></span><br><span class="line">  high = <span class="built_in">len</span>(lis) - <span class="number">1</span></span><br><span class="line">  <span class="built_in">time</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> low &lt; high:</span><br><span class="line">    <span class="built_in">time</span> += <span class="number">1</span></span><br><span class="line">    <span class="keyword">mid</span> = int((low + high) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> key &lt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">    elif key &gt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 打印折半的次数</span></span><br><span class="line">      print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">      <span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">  print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">  <span class="literal">return</span> False</span><br></pre></td></tr></table></figure><h1 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h1><p>算法简介</p><p>插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。 时间复杂度o(logn)但对于表长较大而关键字分布比较均匀的查找表来说，效率较高。</p><p>算法思想 基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。 注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p><p>复杂度分析 时间复杂性：如果元素均匀分布，则O（log log n）），在最坏的情况下可能需要O（n）。 空间复杂度：O（1）。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def binary_search(lis, key):</span><br><span class="line">  low = <span class="number">0</span></span><br><span class="line">  high = <span class="built_in">len</span>(lis) - <span class="number">1</span></span><br><span class="line">  <span class="built_in">time</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> low &lt; high:</span><br><span class="line">    <span class="built_in">time</span> += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 计算mid值是插值算法的核心代码</span></span><br><span class="line">    <span class="keyword">mid</span> = low + int((high - low) * (key - lis[low])/(lis[high] - lis[low]))</span><br><span class="line">    print(<span class="string">"mid=%s, low=%s, high=%s"</span> % (<span class="keyword">mid</span>, low, high))</span><br><span class="line">    <span class="keyword">if</span> key &lt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">    elif key &gt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 打印查找的次数</span></span><br><span class="line">      print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">      <span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">  print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">  <span class="literal">return</span> False</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  LIST = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">  <span class="built_in">result</span> = binary_search(LIST, <span class="number">444</span>)</span><br><span class="line">  print(<span class="built_in">result</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;顺序查找&quot;&gt;&lt;a href=&quot;#顺序查找&quot; class=&quot;headerlink&quot; title=&quot;顺序查找&quot;&gt;&lt;/a&gt;顺序查找&lt;/h1&gt;&lt;p&gt;算法简介 顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。 基本思路 从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。 优缺点 缺点：是当n 很大时，平均查找长度较大，效率低； 优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。 算法实现
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝的区别</title>
    <link href="https://luckyle.top/Python/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://luckyle.top/Python/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2019-12-21T10:48:01.000Z</published>
    <updated>2019-12-25T08:24:06.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深拷贝和浅拷贝之间的区别是什么？"><a href="#深拷贝和浅拷贝之间的区别是什么？" class="headerlink" title="深拷贝和浅拷贝之间的区别是什么？"></a>深拷贝和浅拷贝之间的区别是什么？</h1><p>对象的赋值就是简单的引用,a = [1,2,3], b=a, 在上述情况下,a和b是一样的,他们指向同一片内存,b不过是a的别名,是引用,我们可以使用b is a 去判断,返回True,表名他们地址相同内容也相同,也可以使用id()函数来查看.看两个列表地址是否相同.<a id="more"></a></p><p>深拷贝就是将一个对象拷贝到另一个对象中，这意味着如果你对一个对象的拷贝做出改变时，不会影响原对象。在Python中，我们使用函数deepcopy()执行深拷贝</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">copy</span></span><br><span class="line">b=<span class="built_in">copy</span>.deepcopy(a)</span><br></pre></td></tr></table></figure><p><img src="https://v3u.cn/book/img/deepcopy.jpg" alt="avatar"></p><p>而浅拷贝则是将一个对象的引用拷贝到另一个对象上，所以如果我们在拷贝中改动，会影响到原对象。我们使用函数function()执行浅拷贝</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b=<span class="keyword">copy</span>.<span class="keyword">copy</span>(a)</span><br></pre></td></tr></table></figure><p><img src="https://v3u.cn/book/img/copy.jpg" alt="img"></p><p>切片操作是浅拷贝</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深拷贝和浅拷贝之间的区别是什么？&quot;&gt;&lt;a href=&quot;#深拷贝和浅拷贝之间的区别是什么？&quot; class=&quot;headerlink&quot; title=&quot;深拷贝和浅拷贝之间的区别是什么？&quot;&gt;&lt;/a&gt;深拷贝和浅拷贝之间的区别是什么？&lt;/h1&gt;&lt;p&gt;对象的赋值就是简单的引用,a = [1,2,3], b=a, 在上述情况下,a和b是一样的,他们指向同一片内存,b不过是a的别名,是引用,我们可以使用b is a 去判断,返回True,表名他们地址相同内容也相同,也可以使用id()函数来查看.看两个列表地址是否相同.
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CentOS下yum Mongodb安装</title>
    <link href="https://luckyle.top/Mongodb/Mongodb/"/>
    <id>https://luckyle.top/Mongodb/Mongodb/</id>
    <published>2019-12-21T01:20:39.000Z</published>
    <updated>2019-12-25T08:27:48.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS下yum-Mongodb安装？"><a href="#CentOS下yum-Mongodb安装？" class="headerlink" title="CentOS下yum Mongodb安装？"></a>CentOS下yum Mongodb安装？</h1><a id="more"></a><p>MongoDB的安装<br>CentOS 中使用yum安装：</p><p>touch /etc/yum.repos.d/mongodb-org-4.2.repo<br>vim /etc/yum.repos.d/mongodb-org-4.2.repo<br>添加如下内容：<br>[mongodb-org-4.2]<br>name=MongoDB Repository<br>baseurl=<a href="https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/" target="_blank" rel="noopener">https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/</a><br>gpgcheck=1<br>enabled=1<br>gpgkey=<a href="https://www.mongodb.org/static/pgp/server-4.2.asc" target="_blank" rel="noopener">https://www.mongodb.org/static/pgp/server-4.2.asc</a><br>使用yum安装：<br>yum install -y mongodb-org<br>启动时指定配置文件：</p><p>mongod -f /etc/mongo/mongod.conf</p><p>参考：</p><p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</a></p><p>MongoDB如何导入数据？<br>wget <a href="http://labfile.oss.aliyuncs.com/courses/1196/monkey_source_docs_json.dat" target="_blank" rel="noopener">http://labfile.oss.aliyuncs.com/courses/1196/monkey_source_docs_json.dat</a><br>mongoimport -d monkey -c source_docs monkey_source_docs_json.dat<br>MongoDB如何导出数据？<br>Mongodb中的mongoexport工具可以把一个collection导出成JSON格式或CSV格式的文件。可以通过参数指定导出的数据项，也可以根据指定的条件导出数据。<br>MongoDB如何备份数据？<br>mongodump -h dbhost -d dbname -o dbdirectory<br>-h：MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017<br>-d：需要备份的数据库实例，例如：test<br>-o：备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。<br>MongoDB如何恢复数据<br>mongorestore -h <hostname>&lt;:port&gt; -d dbname <path><br>–host &lt;:port&gt;, -h &lt;:port&gt;：<br>MongoDB所在服务器地址，默认为： localhost:27017<br>–db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2<br>–drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！<br><path>：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。你不能同时指定 <path> 和 –dir 选项，–dir也可以设置备份目录。<br>–dir：指定备份的目录,你不能同时指定 <path> 和 –dir 选项。<br>结巴分词<br>参考资料：</p><p><a href="https://www.cnblogs.com/clsn/p/8244206.html#auto_id_9" target="_blank" rel="noopener">https://www.cnblogs.com/clsn/p/8244206.html#auto_id_9</a></p><p><a href="https://motor.readthedocs.io/en/stable/tutorial-asyncio.html" target="_blank" rel="noopener">https://motor.readthedocs.io/en/stable/tutorial-asyncio.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CentOS下yum-Mongodb安装？&quot;&gt;&lt;a href=&quot;#CentOS下yum-Mongodb安装？&quot; class=&quot;headerlink&quot; title=&quot;CentOS下yum Mongodb安装？&quot;&gt;&lt;/a&gt;CentOS下yum Mongodb安装？&lt;/h1&gt;
    
    </summary>
    
    
      <category term="Mongodb" scheme="https://luckyle.top/categories/Mongodb/"/>
    
    
      <category term="Mongdb" scheme="https://luckyle.top/tags/Mongdb/"/>
    
  </entry>
  
  <entry>
    <title>随机验证码</title>
    <link href="https://luckyle.top/Python/%E9%9A%8F%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>https://luckyle.top/Python/%E9%9A%8F%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/</id>
    <published>2019-12-20T11:24:52.000Z</published>
    <updated>2019-12-25T08:24:23.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="验证码的书写"><a href="#验证码的书写" class="headerlink" title="验证码的书写"></a>验证码的书写</h1><p>​    验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分<a href="https://baike.baidu.com/item/计算机" target="_blank" rel="noopener">计算机</a>和人类的<a href="https://baike.baidu.com/item/图灵测试" target="_blank" rel="noopener">图灵测试</a>）的缩写，是一种区分用户是计算机还是人的公共全自动<a href="https://baike.baidu.com/item/程序/71525" target="_blank" rel="noopener">程序</a>。可以防止：恶意破解密码、<a href="https://baike.baidu.com/item/刷票/6540942" target="_blank" rel="noopener">刷票</a>、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Django</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> make_password,check_password</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> web.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入图片库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入绘画库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageDraw</span><br><span class="line"><span class="comment">#字体库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont</span><br><span class="line"><span class="comment">#随机库</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#图片库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="comment">#文件流</span></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取随机6位字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_str</span><span class="params">()</span>:</span></span><br><span class="line">    a_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>)])  <span class="comment">#小写字母</span></span><br><span class="line">    A_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>)])   <span class="comment">#大写字母</span></span><br><span class="line">    num_=[str(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>)]   <span class="comment">#数字 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(a_+A_+num_,<span class="number">4</span>))  <span class="comment">#返回随机4位字符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义验证码类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mycode</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment">#定义随机取色方法,混淆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_random_color</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#三原色</span></span><br><span class="line">        R=random.randrange(<span class="number">255</span>)</span><br><span class="line">        G=random.randrange(<span class="number">255</span>)</span><br><span class="line">        B=random.randrange(<span class="number">255</span>)</span><br><span class="line">        <span class="keyword">return</span> (R,G,B)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#定义画布</span></span><br><span class="line">        image_size=(<span class="number">120</span>,<span class="number">60</span>)</span><br><span class="line">        <span class="comment">#定义图像 颜色种类  画布  背景颜色</span></span><br><span class="line">        image=Image.new(<span class="string">'RGB'</span>,image_size,<span class="string">'white'</span>)</span><br><span class="line">        <span class="comment">#定义画笔</span></span><br><span class="line">        draw=ImageDraw.Draw(image,<span class="string">'RGB'</span>)</span><br><span class="line">        <span class="comment">#随机字符串的组成</span></span><br><span class="line">        source=get_random_str()</span><br><span class="line">        <span class="comment">#定义一个容器，接收</span></span><br><span class="line">        code_str=<span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="comment">#取色</span></span><br><span class="line">            text_color=self.get_random_color()</span><br><span class="line">            <span class="comment">#获取一个字符串</span></span><br><span class="line">            tmp_num=random.randrange(len(source))</span><br><span class="line">            <span class="comment">#获取字符集</span></span><br><span class="line">            random_str=source[tmp_num]</span><br><span class="line">            <span class="comment">#将随机生成的字符串放入定义好的容器</span></span><br><span class="line">            code_str+=random_str</span><br><span class="line">            <span class="comment">#将文字输入绘图</span></span><br><span class="line">            <span class="comment">#宽高，字符，颜色</span></span><br><span class="line">            draw.text((<span class="number">10</span>+<span class="number">30</span>*i,<span class="number">20</span>),random_str,text_color)</span><br><span class="line">        <span class="comment">#建立io文件流</span></span><br><span class="line">        buf=io.BytesIO()</span><br><span class="line">        <span class="comment">#将图片内容保存在内存中</span></span><br><span class="line">        image.save(buf,<span class="string">'png'</span>)</span><br><span class="line">        <span class="comment">#将验证码放入session</span></span><br><span class="line">        request.session[<span class="string">'code'</span>]=code_str</span><br><span class="line">        <span class="comment">#可以存入redis中   建立连接   存key  取key</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(buf.getvalue(),<span class="string">'image/png'</span>)   <span class="comment">#从内存中获取数据</span></span><br></pre></td></tr></table></figure><h4 id="点击图片且刷新"><a href="#点击图片且刷新" class="headerlink" title="点击图片且刷新"></a>点击图片且刷新</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">&lt;image <span class="string">":src=src"</span> <span class="meta">@click</span>=<span class="string">'changecode'</span>&gt;</span><br><span class="line">src=<span class="string">'http://127.0.0.1:8000/api/mycode/'</span></span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line"><span class="comment">//点击刷新验证码</span></span><br><span class="line"><span class="comment">//每次给它传一个随机字符,只要传了参数，就不会缓存，直接刷新</span></span><br><span class="line"><span class="comment">//在js中随机生成字符</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">10</span>);</span><br><span class="line"><span class="keyword">this</span>.src=<span class="keyword">this</span>.src+<span class="string">'?code='</span>+num;</span><br><span class="line"></span><br><span class="line">changecode()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;验证码的书写&quot;&gt;&lt;a href=&quot;#验证码的书写&quot; class=&quot;headerlink&quot; title=&quot;验证码的书写&quot;&gt;&lt;/a&gt;验证码的书写&lt;/h1&gt;&lt;p&gt;​    验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分&lt;a href=&quot;https://baike.baidu.com/item/计算机&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计算机&lt;/a&gt;和人类的&lt;a href=&quot;https://baike.baidu.com/item/图灵测试&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图灵测试&lt;/a&gt;）的缩写，是一种区分用户是计算机还是人的公共全自动&lt;a href=&quot;https://baike.baidu.com/item/程序/71525&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;程序&lt;/a&gt;。可以防止：恶意破解密码、&lt;a href=&quot;https://baike.baidu.com/item/刷票/6540942&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;刷票&lt;/a&gt;、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>&#39;hexo快速搭建博客&#39;</title>
    <link href="https://luckyle.top/Python/hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://luckyle.top/Python/hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-12-20T08:23:28.000Z</published>
    <updated>2019-12-25T08:25:11.122Z</updated>
    
    <content type="html"><![CDATA[<p>使用Hexo建立一个轻量、简易、高逼格的博客</p><pre><code>在之前的一篇文章中，介绍了如何使用Hugo在三分钟之内建立一个简单的个人博客系统，它是基于go lang的，其实，市面上还有一款类似的静态页生成器，就是Hexo 读音/hækso/ ，它是基于node.js的，和Hugo一样，Hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。</code></pre><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先安装Hexo，在此之前，请确保电脑里已经安装好新版的<span class="keyword">node</span>.<span class="title">js</span></span><br></pre></td></tr></table></figure><p>​    </p><p>npm install -g hexo-cli</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果感觉安装速度比较慢，可以为<span class="built_in">npm</span>指定国内的源</span><br></pre></td></tr></table></figure><p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装完成后，创建博客项目</span><br></pre></td></tr></table></figure><p>hexo init blog</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样，就建立起了一个<span class="keyword">blog文件夹，进入到blog目录下 </span>cd <span class="keyword">blog，建立第一篇文章</span></span><br></pre></td></tr></table></figure><p>hexo new myfirst</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后运行hexo服务</span><br></pre></td></tr></table></figure><p>hexo server</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">就可以在本地访问你的博客网站了，默认端口号是<span class="number">4000</span></span><br><span class="line"></span><br><span class="line">那么如何将博客网站打包呢？直接运行打包命令，这样就能使用 Hexo 引擎将 Markdown 格式的文件解析成可以使用浏览器查看的 HTML 文件，HTML 文件存储在 blog/<span class="keyword">public</span> 目录下</span><br></pre></td></tr></table></figure><p>hexo generate</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下面我们可以配置一下hexo主题，Hexo 提供了默认主题 landscape，主题的位置在 blog -&gt;themes 文件夹下。主题根据自己喜好可以在网上找到<span class="symbol">:https</span><span class="symbol">://hexo</span>.io/themes/</span><br><span class="line"></span><br><span class="line">主题都放在blog/themes文件夹下面，这我们下载一个新的主题</span><br></pre></td></tr></table></figure><p>mkdir themes/next<br>git clone –branch v5.1.2 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后在修改 <span class="regexp">/blog/</span>config.yml 文件，将其中的 theme 改成 <span class="keyword">next</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果没有自己的域名和服务器怎么办？没关系，可以申请 <span class="selector-tag">Github</span> 免费静态内容空间，在<span class="selector-tag">github</span><span class="selector-class">.com</span>注册一个账号，然后创建一个新的仓库</span><br></pre></td></tr></table></figure><p>​    </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">仓库名称一定要定义成 账号名<span class="selector-class">.github</span><span class="selector-class">.io</span>，这种形式，注意账号名一定要和你的<span class="selector-tag">github</span>当前登录的账号吻合</span><br></pre></td></tr></table></figure><p>​      </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这样你的静态内容空间就已经创建好了，在浏览器输入你的 <span class="string">https:</span><span class="comment">//你的账号.github.io/ 就可以访问了。</span></span><br><span class="line"></span><br><span class="line">将之前打包好的<span class="keyword">public</span>中的文件push到刚刚创建好的github仓库中去</span><br><span class="line"></span><br><span class="line">访问静态空间网址<span class="string">https:</span><span class="comment">//仓库名.github.io</span></span><br></pre></td></tr></table></figure><p>​    </p><p>没有问题，搞定收工</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Hexo建立一个轻量、简易、高逼格的博客&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在之前的一篇文章中，介绍了如何使用Hugo在三分钟之内建立一个简单的个人博客系统，它是基于go lang的，其实，市面上还有一款类似的静态页生成器，就是Hexo 读音/hækso/ ，它是基于nod
      
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>send_verify</title>
    <link href="https://luckyle.top/Python/send-verify/"/>
    <id>https://luckyle.top/Python/send-verify/</id>
    <published>2019-12-20T00:49:11.000Z</published>
    <updated>2019-12-25T08:25:56.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django-vue-验证码发送"><a href="#Django-vue-验证码发送" class="headerlink" title="Django +vue 验证码发送"></a>Django +vue 验证码发送</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> web.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL   <span class="comment">#settings里的一些配置</span></span><br><span class="line"><span class="keyword">import</span> random </span><br><span class="line"></span><br><span class="line"><span class="comment">#settings配置具体如下:</span></span><br><span class="line">EMAIL_USE_SSL = <span class="literal">True</span> <span class="comment"># Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议</span></span><br><span class="line">    EMAIL_HOST = <span class="string">'smtp.qq.com'</span>  <span class="comment"># 邮件服务器地址</span></span><br><span class="line">    EMAIL_PORT = <span class="number">465</span> <span class="comment"># 邮件服务器端口</span></span><br><span class="line"> </span><br><span class="line">    EMAIL_HOST_USER = <span class="string">'1315532054@qq.com'</span> <span class="comment"># 登陆邮件服务器的账号</span></span><br><span class="line">    EMAIL_HOST_PASSWORD = <span class="string">'ownkpkdkumubhdjg'</span>  <span class="comment"># 登陆邮件服务器的密码</span></span><br><span class="line">    DEFAULT_FROM_EMAIL = EMAIL_HOST_USER <span class="comment"># 邮件的发送者</span></span><br></pre></td></tr></table></figure><!-- < !--more--> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取随机6位字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_str</span><span class="params">()</span>:</span></span><br><span class="line">    a_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>)])</span><br><span class="line">    A_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>)])</span><br><span class="line">    num_=[str(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(a_+A_+num_,<span class="number">6</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#邮件发送</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">send_verify</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">           1. 先检查 对应邮件是否再memcache里已经存在了验证码</span></span><br><span class="line"><span class="string">           2. 发现没有存在,那么需要生成6位随机字符</span></span><br><span class="line"><span class="string">           3. 存储入到memcache里,并设置60s的过期时间</span></span><br><span class="line"><span class="string">               email: 6str :60s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           遇到了同步发送邮件的问题,应该怎么办</span></span><br><span class="line"><span class="string">       '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        email=request.data[<span class="string">'email'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># email=request.POST.get('email')</span></span><br><span class="line">        <span class="comment"># 1. 先检查 对应邮件是否再memcache里已经存在了验证码</span></span><br><span class="line">        token=men.get(email)</span><br><span class="line">        <span class="comment">#2.如果没有存在，那么需要生成随机字符</span></span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'code'</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="string">'message'</span>:<span class="string">'该邮箱已存在验证码'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#该邮箱没有，生成随机字符</span></span><br><span class="line">            token=get_random_str()  <span class="comment">#随机字符</span></span><br><span class="line">            subject=<span class="string">'实验楼。。。。。。。。。。。'</span></span><br><span class="line">            message=<span class="string">'你的验证码是:%s'</span>%token</span><br><span class="line">            men.set(email,token,<span class="number">100</span>)  <span class="comment">#存储到memcache</span></span><br><span class="line">            <span class="comment"># print(men.get(token))</span></span><br><span class="line">            send_mail(subject,message,DEFAULT_FROM_EMAIL,[email])</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'code'</span>:<span class="number">1</span>,</span><br><span class="line">                <span class="string">'message'</span>:<span class="string">'验证码已发送'</span></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">send_verify()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!this.email)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        let form_data=new FormData()</span><br><span class="line">        form_data.append(<span class="string">'email'</span>,this.email)</span><br><span class="line"></span><br><span class="line">        axios(&#123;</span><br><span class="line">            url:<span class="string">'http://127.0.0.1:8000/api/send_verify/'</span>,</span><br><span class="line">            method:<span class="string">'post'</span>,</span><br><span class="line">            data:form_data</span><br><span class="line">        &#125;).then(res=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.data.code==<span class="number">1</span>)&#123;</span><br><span class="line">                alert(res.data.message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Django-vue-验证码发送&quot;&gt;&lt;a href=&quot;#Django-vue-验证码发送&quot; class=&quot;headerlink&quot; title=&quot;Django +vue 验证码发送&quot;&gt;&lt;/a&gt;Django +vue 验证码发送&lt;/h1&gt;&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://luckyle.top/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://luckyle.top/Python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2019-09-02T06:05:01.000Z</published>
    <updated>2020-01-12T11:11:38.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于数据结构"><a href="#关于数据结构" class="headerlink" title="关于数据结构"></a>关于数据结构</h1><h5 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h5><p>简单地说，数据结构是以某种特定的布局方式存储数据的容器。这种“布局方式”决定了数据结构对于某些操作是高效的，而对于其他操作则是低效的。首先我们需要理解各种数据结构，才能在处理实际问题时选取最合适的数据结构。<a id="more"></a></p><h5 id="为什么我们需要数据结构？"><a href="#为什么我们需要数据结构？" class="headerlink" title="为什么我们需要数据结构？"></a>为什么我们需要数据结构？</h5><p>数据是计算机科学当中最关键的实体，而数据结构则可以将数据以某种组织形式存储，因此，数据结构的价值不言而喻。</p><p>无论你以何种方式解决何种问题，你都需要处理数据——无论是涉及员工薪水、股票价格、购物清单，还是只是简单的电话簿问题。</p><p>数据需要根据不同的场景，按照特定的格式进行存储。有很多数据结构能够满足以不同格式存储数据的需求。</p><h5 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h5><p>首先列出一些最常见的数据结构，我们将逐一说明：</p><p>数组 栈 队列 链表 树 字典树（这是一种高效的树形结构，但值得单独说明） 散列表（哈希表）</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均由数组演变而来。下图是一个包含元素（1，2，3和4）的简单数组，数组长度为4。</p><p>每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。</p><p>以下是数组的两种类型：</p><p>一维数组（如上所示） 多维数组（数组的数组）</p><p>数组的基本操作</p><p>Insert——在指定索引位置插入一个元素 Get——返回指定索引位置的元素 Delete——删除指定索引位置的元素 Size——得到数组所有元素的数量</p><p>面试中关于数组的常见问题</p><p>寻找数组中第二小的元素 找到数组中第一个不重复出现的整数 合并两个有序数组 重新排列数组中的正值和负值</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>著名的撤销操作几乎遍布任意一个应用。但你有没有思考过它是如何工作的呢？这个问题的解决思路是按照将最后的状态排列在先的顺序，在内存中存储历史工作状态（当然，它会受限于一定的数量）。这没办法用数组实现。但有了栈，这就变得非常方便了。</p><p>可以把栈想象成一列垂直堆放的书。为了拿到中间的书，你需要移除放置在这上面的所有书。这就是LIFO（后进先出）的工作原理。</p><p>下图是包含三个数据元素（1，2和3）的栈，其中顶部的3将被最先移除：</p><h5 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h5><p>Push——在顶部插入一个元素 Pop——返回并移除栈顶元素 isEmpty——如果栈为空，则返回true Top——返回顶部元素，但并不移除它</p><h5 id="面试中关于栈的常见问题"><a href="#面试中关于栈的常见问题" class="headerlink" title="面试中关于栈的常见问题"></a>面试中关于栈的常见问题</h5><p>使用栈计算后缀表达式 对栈的元素进行排序 判断表达式是否括号平衡</p><p>应用场景：逆序输出，语法检查，进制转换</p><p>在我们日常编程中，括号都是成对出现的，比如“()”“[]”“{}”“&lt;&gt;”这些成对出现的符号</p><p>那么具体处理的方法就是:凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p><p>将十进制的数转换为2-9的任意进制的数</p><p>我们都知道，通过求余法，可以将十进制数转换为其他进制，比如要转为八进制，将十进制数除以8，记录余数，然后继续将商除以8，一直到商等于0为止，最后将余数倒着写数来就可以了。</p><p>比如100的八进制，100首先除以8商12余4,4首先进栈，然后12除以8商1余4，第二个余数4进栈，接着1除以8，商0余1，第三个余数1进栈，最后将三个余数出栈，就得到了100的八进制数144,</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>与栈相似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO，即先进先出。</p><p>一个完美的队列现实例子：售票亭排队队伍。如果有新人加入，他需要到队尾去排队，而非队首——排在前面的人会先拿到票，然后离开队伍。</p><p>下图是包含四个元素（1，2，3和4）的队列，其中在顶部的1将被最先移除：</p><p>移除先入队的元素、插入新元素</p><h5 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h5><p>Enqueue()——在队列尾部插入元素 Dequeue()——移除队列头部的元素 isEmpty()——如果队列为空，则返回true Top()——返回队列的第一个元素</p><p>面试中关于队列的常见问题</p><p>使用队列表示栈 对队列的前k个元素倒序 使用队列生成从1到n的二进制数</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是另一个重要的线性数据结构，乍一看可能有点像数组，但在内存分配、内部结构以及数据插入和删除的基本操作方面均有所不同。</p><p>链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。 链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。</p><p>链表一般用于实现文件系统、哈希表和邻接表。</p><p>这是链表内部结构的展示：</p><p>链表包括以下类型：</p><p>单链表（单向） 双向链表（双向）</p><h5 id="链表的基本操作："><a href="#链表的基本操作：" class="headerlink" title="链表的基本操作："></a>链表的基本操作：</h5><p>InsertAtEnd - 在链表的末尾插入指定元素 InsertAtHead - 在链接列表的开头/头部插入指定元素 Delete - 从链接列表中删除指定元素 DeleteAtHead - 删除链接列表的第一个元素 Search - 从链表中返回指定元素 isEmpty - 如果链表为空，则返回true</p><p>面试中关于链表的常见问题</p><p>反转链表 检测链表中的循环 返回链表倒数第N个节点 删除链表中的重复项</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树形结构是一种层级式的数据结构，由顶点（节点）和连接它们的边组成。 树类似于图，但区分树和图的重要特征是树中不存在环路。</p><p>树形结构被广泛应用于人工智能和复杂算法，它可以提供解决问题的有效存储机制。</p><p>这是一个简单树的示意图，以及树数据结构中使用的基本术语：</p><p>Root - 根节点</p><p>Parent - 父节点</p><p>Child - 子节点</p><p>Leaf - 叶子节点</p><p>Sibling - 兄弟节点</p><p>以下是树形结构的主要类型：</p><p>N元树 平衡树 二叉树 二叉搜索树 AVL树 红黑树 2-3树</p><p>其中，二叉树和二叉搜索树是最常用的树。</p><h5 id="面试中关于树结构的常见问题："><a href="#面试中关于树结构的常见问题：" class="headerlink" title="面试中关于树结构的常见问题："></a>面试中关于树结构的常见问题：</h5><p>求二叉树的高度 在二叉搜索树中查找第k个最大值 查找与根节点距离k的节点 在二叉树中查找给定节点的祖先节点</p><p>字典树（Trie）</p><p>字典树，也称为“前缀树”，是一种特殊的树状数据结构，对于解决字符串相关问题非常有效。它能够提供快速检索，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于IP的路由。</p><p>这些单词以顶部到底部的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“theirs”的底部。</p><p>面试中关于字典树的常见问题</p><p>计算字典树中的总单词数 打印存储在字典树中的所有单词 使用字典树对数组的元素进行排序 使用字典树从字典中形成单词 构建T9字典（字典树+ DFS ）</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键（key）”）中的过程。因此，对象以键值对的形式存储，这些键值对的集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。</p><p>哈希表通常使用数组实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于数据结构&quot;&gt;&lt;a href=&quot;#关于数据结构&quot; class=&quot;headerlink&quot; title=&quot;关于数据结构&quot;&gt;&lt;/a&gt;关于数据结构&lt;/h1&gt;&lt;h5 id=&quot;什么是数据结构？&quot;&gt;&lt;a href=&quot;#什么是数据结构？&quot; class=&quot;headerlink&quot; title=&quot;什么是数据结构？&quot;&gt;&lt;/a&gt;什么是数据结构？&lt;/h5&gt;&lt;p&gt;简单地说，数据结构是以某种特定的布局方式存储数据的容器。这种“布局方式”决定了数据结构对于某些操作是高效的，而对于其他操作则是低效的。首先我们需要理解各种数据结构，才能在处理实际问题时选取最合适的数据结构。
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Mysql事务</title>
    <link href="https://luckyle.top/Mysql/Mysql%E4%BA%8B%E5%8A%A1/"/>
    <id>https://luckyle.top/Mysql/Mysql%E4%BA%8B%E5%8A%A1/</id>
    <published>2019-06-09T07:26:52.000Z</published>
    <updated>2020-01-06T07:00:56.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h1><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！<a id="more"></a></p><ul><li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li><li>事务处理维护数据库的完整性，保updte,adelete 语句</li></ul><p>一般来说，事务是必须满足4个条证成批的 SQL 语句要么全部执行，要么全部不执行。</p><ul><li><p>事务用来可以用来管理 insert,件（ACID）：：原子性（<strong>A</strong>tomicity，或称不可分割性）、一致性（<strong>C</strong>onsistency）、隔离性（<strong>I</strong>solation，又称独立性）、持久性（<strong>D</strong>urability）。</p></li><li><p><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p></li><li><p><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p></li><li><p><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p></li></ul><hr><p>‘- 显示数据库：show databases;</p><h5 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h5><p>​    sql server（微软）windows 专有数据<br>​    mysql    默认端口:3306<br>​    oracle（重点）甲骨文<br>​    access<br>​    sqlite<br>​    ibm db2<br>​    关系型数据库管理系统</p><p>-查看 mysql 版本： select version();<br>primary key 主键   auto_increment 自动递增   not null ,要求该约束所修饰的字段，不能为null或空    unsigned 约束的字段，会去掉负值，添加到正值，范围 x 2 + 1</p><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>命令格式：select * from 表名 order by 字段名 asc(升序)|desc（降序）;<br>多字段排序<br>select * from department order by groups desc,kpi desc;<br>多字段排序时，先按第一字段排序，第一段相同的，再按第二字段排序。</p><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ul><li>创建数据库命令格式： <code>create database 数据库名字 charset=字符集</code></li><li>创建表命令格式: <code>create table 表名( 字段 属性 );</code></li></ul><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul><li>删除表<br>命令格式：drop table 表名;</li><li>删库<br>格式: <code>drop database 库名;</code><br>删除主键<br>alter table 表名 drop 主键字段名;<br>删除数据<br>命令格式<br>delete from 表名 where 【条件】</li></ul><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>-修改已创建的表名<br>命令格式：alter table 原表名 rename to  新表名;</p><p>旧改法：<br>      alter user ‘root’@’localhost’ identified by ‘mysql’;</p><p>-10.1.38-MariaDB 修改密码：<br>    update mysql.user set Password = password(‘1999’) where             user=’(root）’;<br>    flush privileges;<br>    exit;</p><p>远程链接:<br>    GRANT ALL PRIVILEGES ON * .* TO ‘root’@’%’ IDENTIFIED BY ‘root’ WITH GRANT OPTION;</p><p>mysql 配置文件：<br>     windows -&gt; mysql/bin/my.ini<br>     linux -&gt; mysq/my.cnf</p><h5 id="修改创建好的表字"><a href="#修改创建好的表字" class="headerlink" title="修改创建好的表字"></a>修改创建好的表字</h5><p>段命令格式: alter table 表名 change 原字段名 新字段名 字段类型 字段属性（约束）;<br>添加新的字段<br>命令格式: alter table 表名 add 字段名 字段类型 字段属性（约束）;<br>修改表名<br>命令格式：alter table 旧表名 rename to 新表名;<br>创建表后修改主键<br>alter table 表名 change 原字段名（要设为主键的字段） 新字段名 int primary key auto_incremnt not null;<br>修改数据<br>update 表名 set 字段名1=要修改值1,字段名2=要修改值2 where [条件]</p><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>基本查询<br>命令格式：select [要查询的字段，如果是所有字段，就是*;如果单个，写字段名] from 【表名】 where 【条件】<br>范围查询<br>命令格式： select [字段] from 表名 where 字段名 between 开始 and 结束<br>in ( ) 在 … 里 not in<br>模糊查询<br>命令格式： select [字段] from 表名 where 字段 like …%…<br>内联接查询<br>命令格式:select [字段] from 表名1 inner join 表名2 on 表名1.连接字段=表名2.连接字段<br>右链接<br>select * from student s right join class c on s.cls_id=c.id<br>左连接<br>select *  from class c left join student s on s.cls_id=c.id;<br>全联接<br> select * from class c left join student s on c.id=s.cls_id<br> union<br> select * from class c right join student s on c.id=s.cls_id;<br>自联接（自查询)<br>表和自身的连接，使用 inner join 来完成</p><h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><p>命令格式:<br>insert into 表名（字段名1,字段名2,字段名3…..）values(值1,值2,值3…);<br>另外一种形式<br>insert into 表名 values(字段1的值，字段2的值，字段3的值。。。。);</p><p>-分组<br>group by 分组<br>分组  group_concat()+group by </p><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="-聚合函数"></a>-聚合函数</h5><p>统计函数 count（）<br>命令格式： select count(要统计的字段) from 表名 where [条件]<br>求最大值<br>命令格式：select max(求最大值的字段) from 表名;<br>求最小值<br>命令格式：select min(要计算最小值的字段) from 表名;<br>求和<br>命令格式:<br>select sum(要求和/总数的字段) from 表名;<br>求平均值<br>select avg(要求平均值字段) from 表名;</p><p>having<br>having 和 where 都 可以对记录进行筛选；但是having跟在group by 后面，group by 跟在 where 后面；having 后面条件必须在 select 字段中出现，没有，就会报错；where 是必须是表中字段<br>where … group by … having</p><h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p>命令格式：<br>create view 视图名字 as select语句;<br>查看视图<br>命令格式：show tables;<br>删除视图<br>drop view 视图名字<br>修改视图<br>create or replace view 视图名字 as select语句;</p><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>查看索引<br>命令格式：<br>show index from 表名；<br>创建索引的命令<br>格式：<br>create index idx_索引名  on 表名（字段名（索引长度））<br>删除索引<br>命令格式:<br>drop index 索引名称 on 表名;</p><h5 id="三范式："><a href="#三范式：" class="headerlink" title="三范式："></a>三范式：</h5><p>1：确保每列保持原子性<br>2：确保表中每列都和主键直接相关<br>3：确保每列都和主键列直接相关，而不是间接相关</p><h5 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h5><p>​    是一个操作序列，这些操作要么都执行，要么都不执行，它是一个完整的，不可分割的工作单位。<br>事务具有的特性：原子性 ，一致，隔离，持久<br>开启事务：start transaction   / begin<br>提交         commit</p><p>当前时间加1天<br>select date_add(now(),interyal 1day)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL-事务&quot;&gt;&lt;a href=&quot;#MySQL-事务&quot; class=&quot;headerlink&quot; title=&quot;MySQL 事务&quot;&gt;&lt;/a&gt;MySQL 事务&lt;/h1&gt;&lt;p&gt;MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！
    
    </summary>
    
    
      <category term="Mysql" scheme="https://luckyle.top/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://luckyle.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>装饰器</title>
    <link href="https://luckyle.top/uncategorized/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://luckyle.top/uncategorized/%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2018-12-29T12:46:15.000Z</published>
    <updated>2020-01-02T02:35:28.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器本质上是一个Python函数，它可以让其它哈桑农户在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。比如：插入日志，性能测试，事务处理，缓存，权限校验等。有了装饰器我们就可以抽离处大量的与函数功能无关的雷同代码进行重用。装饰器其实就是一个闭包，把一个函数当做参数返回一个替代版函数。 <a id="more"></a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrr</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">'111'</span>)</span><br><span class="line">func()</span><br><span class="line"><span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@wrr</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">'222'</span>)</span><br><span class="line">my()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算函数执行时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">strat=time.time()</span><br><span class="line">print(<span class="string">'信任'</span>)</span><br><span class="line">func()</span><br><span class="line">last=time.time()</span><br><span class="line">print(last-strat)</span><br><span class="line"><span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@out</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ll</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">'理解'</span>)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">ll()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#带参装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_code</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> func(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wraper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_code()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sing</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'%s是歌手'</span> % name)</span><br><span class="line">sing(<span class="string">'张三'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#定义反扒装饰器,定义形参，一秒允许请求一次</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">limit</span><span class="params">(seconds=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment">#定义内部方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rate_limit</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func_limit</span><span class="params">(request)</span>:</span></span><br><span class="line">            <span class="comment">#获取当前时间</span></span><br><span class="line">            now = time.time()</span><br><span class="line">            <span class="comment">#获取首次来访时间</span></span><br><span class="line">            request_time = request.session.get(<span class="string">'req_time'</span>,<span class="number">0</span>)</span><br><span class="line">            <span class="comment">#做减法</span></span><br><span class="line">            in_time = int(now) - request_time</span><br><span class="line">            <span class="comment">#判断访问者在一秒内来了不止一次</span></span><br><span class="line">            <span class="keyword">if</span> in_time &lt; seconds:</span><br><span class="line">                <span class="comment">#抛出异常 ,使用第二个参数来指定异常</span></span><br><span class="line">                <span class="keyword">return</span> HttpResponse(<span class="string">'你是爬虫，不要来了'</span>,status=<span class="number">403</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#来的时间点存储</span></span><br><span class="line">                request.session[<span class="string">'req_time'</span>] = time.time()</span><br><span class="line">                <span class="comment">#让访问者继续访问</span></span><br><span class="line">                ret = func(request)</span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> func_limit</span><br><span class="line">    <span class="keyword">return</span> rate_limit</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个验证登录的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_login</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warpper</span><span class="params">(request,*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="comment">#is_login = request.session.get("username",False)</span></span><br><span class="line">        is_login = request.COOKIES.get(<span class="string">"username"</span>,<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> is_login:</span><br><span class="line">            ret = func(request,*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(<span class="string">"/supermarket"</span>)</span><br><span class="line">    <span class="keyword">return</span> warpper</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;装饰器&quot;&gt;&lt;a href=&quot;#装饰器&quot; class=&quot;headerlink&quot; title=&quot;装饰器&quot;&gt;&lt;/a&gt;装饰器&lt;/h2&gt;&lt;p&gt;装饰器本质上是一个Python函数，它可以让其它哈桑农户在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。比如：插入日志，性能测试，事务处理，缓存，权限校验等。有了装饰器我们就可以抽离处大量的与函数功能无关的雷同代码进行重用。装饰器其实就是一个闭包，把一个函数当做参数返回一个替代版函数。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>八大排序</title>
    <link href="https://luckyle.top/Python/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
    <id>https://luckyle.top/Python/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</id>
    <published>2018-12-11T07:53:09.000Z</published>
    <updated>2019-12-25T08:24:01.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序；首先将第一个作为已经排好序的，然后每次从后的取出插入到前面并排序；<a id="more"></a></p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def insert_sort(<span class="keyword">ilist</span>):</span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="keyword">ilist</span>)):</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">ilist</span>[i] &lt; <span class="keyword">ilist</span>[<span class="keyword">j</span>]:</span><br><span class="line">                <span class="keyword">ilist</span>.<span class="keyword">insert</span>(<span class="keyword">j</span>, <span class="keyword">ilist</span>.<span class="keyword">pop</span>(i))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">ilist</span></span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="keyword">bubble_sort(blist):</span></span><br><span class="line"><span class="keyword"> </span>   <span class="built_in">count</span> = len(<span class="keyword">blist)</span></span><br><span class="line"><span class="keyword"> </span>   for i in range(<span class="number">0</span>, <span class="built_in">count</span>):</span><br><span class="line">        for <span class="keyword">j </span>in range(i + <span class="number">1</span>, <span class="built_in">count</span>):</span><br><span class="line">            if <span class="keyword">blist[i] </span>&gt; <span class="keyword">blist[j]:</span></span><br><span class="line"><span class="keyword"> </span>               <span class="keyword">blist[i], </span><span class="keyword">blist[j] </span>= <span class="keyword">blist[j], </span><span class="keyword">blist[i]</span></span><br><span class="line"><span class="keyword"> </span>   return <span class="keyword">blist</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">blist </span>= <span class="keyword">bubble_sort([4,5,6,7,3,2,6,9,8])</span></span><br><span class="line"><span class="keyword">print(blist)</span></span><br></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p><p>时间复杂度：O(nlog₂n)</p><p>空间复杂度：O(nlog₂n)</p><p>稳定性：不稳定</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def quick<span class="constructor">_sort(<span class="params">qlist</span>)</span>:</span><br><span class="line">    <span class="keyword">if</span> qlist<span class="operator"> == </span><span class="literal">[]</span>:</span><br><span class="line">        return <span class="literal">[]</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        qfirst = qlist<span class="literal">[<span class="number">0</span>]</span></span><br><span class="line">        qless = quick<span class="constructor">_sort([<span class="params">l</span> <span class="params">for</span> <span class="params">l</span> <span class="params">in</span> <span class="params">qlist</span>[1:] <span class="params">if</span> <span class="params">l</span> &lt; <span class="params">qfirst</span>])</span></span><br><span class="line">        qmore = quick<span class="constructor">_sort([<span class="params">m</span> <span class="params">for</span> <span class="params">m</span> <span class="params">in</span> <span class="params">qlist</span>[1:] <span class="params">if</span> <span class="params">m</span> &gt;= <span class="params">qfirst</span>])</span></span><br><span class="line">        return qless + <span class="literal">[<span class="identifier">qfirst</span>]</span> + qmore</span><br><span class="line"></span><br><span class="line">qlist = quick<span class="constructor">_sort([4,5,6,7,3,2,6,9,8])</span></span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p>稳定性：不稳定</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def select_sort(slist):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(slist)):</span><br><span class="line">        x = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(slist)):</span><br><span class="line">            <span class="keyword">if</span> slist[j] &lt; slist[x]:</span><br><span class="line">                x = j</span><br><span class="line">        slist[i], slist[x] = slist[x], slist[i]</span><br><span class="line">    <span class="keyword">return</span> slist</span><br><span class="line"></span><br><span class="line">slist = select_sort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序：采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并</p><p>时间复杂度：O(nlog₂n)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def merge_sort(array):</span><br><span class="line">    def merge_arr(arr_l, arr_r):</span><br><span class="line">       <span class="built_in"> array </span>= []</span><br><span class="line">        while len(arr_l)<span class="built_in"> and </span>len(arr_r):</span><br><span class="line">           <span class="built_in"> if </span>arr_l[0] &lt;= arr_r[0]:</span><br><span class="line">                array.append(arr_l.pop(0))</span><br><span class="line">            elif arr_l[0] &gt; arr_r[0]:</span><br><span class="line">                array.append(arr_r.pop(0))</span><br><span class="line">       <span class="built_in"> if </span>len(arr_l) != 0:</span><br><span class="line">           <span class="built_in"> array </span>+= arr_l</span><br><span class="line">        elif len(arr_r) != 0:</span><br><span class="line">           <span class="built_in"> array </span>+= arr_r</span><br><span class="line">       <span class="built_in"> return </span>array</span><br><span class="line"></span><br><span class="line">    def recursive(array):</span><br><span class="line">       <span class="built_in"> if </span>len(array) == 1:</span><br><span class="line">           <span class="built_in"> return </span>array</span><br><span class="line">        mid = len(array) // 2</span><br><span class="line">        arr_l = recursive(array[:mid])</span><br><span class="line">        arr_r = recursive(array[mid:])</span><br><span class="line">       <span class="built_in"> return </span>merge_arr(arr_l, arr_r)</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> return </span>recursive(array)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;p&gt;插入排序：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序；首先将第一个作为已经排好序的，然后每次从后的取出插入到前面并排序；
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>虚拟环境</title>
    <link href="https://luckyle.top/Linux/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>https://luckyle.top/Linux/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</id>
    <published>2018-11-24T07:41:57.000Z</published>
    <updated>2019-12-25T08:21:45.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建爬虫系统"><a href="#构建爬虫系统" class="headerlink" title="构建爬虫系统"></a>构建爬虫系统</h1><h2 id="一、实现目的"><a href="#一、实现目的" class="headerlink" title="一、实现目的"></a>一、实现目的</h2><p>爬虫是文档的重要来源，所以这一节也比较重要，我会从爬虫的基础讲起，爬虫的构成如何编写爬虫等等，希望大家能跟着文档一步步动手做下去。<a id="more"></a></p><h4 id="1-1-实验知识点"><a href="#1-1-实验知识点" class="headerlink" title="1.1 实验知识点"></a>1.1 实验知识点</h4><ul><li>爬虫的基本概念</li><li>异步爬虫框架ruia的使用介绍</li><li>基于ruia构造异步爬虫系统</li></ul><h4 id="1-2-实验环境"><a href="#1-2-实验环境" class="headerlink" title="1.2 实验环境"></a>1.2 实验环境</h4><ul><li>Python 3.6+</li><li>MongoDB</li></ul><h2 id="二、开发准备"><a href="#二、开发准备" class="headerlink" title="二、开发准备"></a>二、开发准备</h2><h5 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建项目代码目录</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">-p ~/Code/monkey</span></span><br><span class="line"><span class="comment"># 进入项目根目录</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">~/Code/monkey</span></span><br><span class="line"><span class="comment"># 创建一个名叫env的虚拟环境(注：Python3自带pyenv)</span></span><br><span class="line"><span class="attr">python3</span> <span class="string">-m venv env  </span></span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line"><span class="attr">source</span> <span class="string">env/bin/activate</span></span><br><span class="line"><span class="comment"># 安装项目依赖的包</span></span><br><span class="line"><span class="attr">pip</span> <span class="string">install -r requirements.txt</span></span><br></pre></td></tr></table></figure><h2 id="三、小试牛刀"><a href="#三、小试牛刀" class="headerlink" title="三、小试牛刀"></a>三、小试牛刀</h2><h3 id="3-1-使用requests-lxml爬取网页"><a href="#3-1-使用requests-lxml爬取网页" class="headerlink" title="3.1 使用requests + lxml爬取网页"></a>3.1 使用requests + lxml爬取网页</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注：以下代码未经过运行测试，只是手写思路</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://movie.douban.com/subject/1292052/'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>:<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Safari/605.1.15"</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(url,headers=headers)</span><br><span class="line">tree = etree.HTML(r.text)</span><br><span class="line">el = tree.xpath(<span class="string">'//*[@id="content"]/h1/span[1]/text()'</span>)</span><br><span class="line">print(el)</span><br></pre></td></tr></table></figure><h3 id="3-2-使用ruia框架爬取网页"><a href="#3-2-使用ruia框架爬取网页" class="headerlink" title="3.2 使用ruia框架爬取网页"></a>3.2 使用ruia框架爬取网页</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ruia <span class="keyword">import</span> Item, TextField</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanItem</span><span class="params">(Item)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    定义爬虫的目标字段</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    title = TextField(css_select=<span class="string">'#content &gt; h1 &gt; span:nth-child(1)'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async_func = DoubanItem.get_item(url=<span class="string">"https://movie.douban.com/subject/1292052/"</span>)</span><br><span class="line">item = asyncio.get_event_loop().run_until_complete(async_func)</span><br><span class="line">print(item.title)</span><br></pre></td></tr></table></figure><h2 id="上午主要内容总结"><a href="#上午主要内容总结" class="headerlink" title="上午主要内容总结"></a>上午主要内容总结</h2><ul><li><p>掌握快速学习的能力，任何框架都是那么容易</p></li><li><p>做项目时，一定要用虚拟环境，学会使用pip freeze &gt;&gt; requirements.txt命令，学会使用pip install -r requirements.txt</p><p>我们通常会把项目依赖的环境命名为“requirements.txt”</p></li><li><p>学会借力：例如，借助浏览器的copy xpath功能快速定位元素位置</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;构建爬虫系统&quot;&gt;&lt;a href=&quot;#构建爬虫系统&quot; class=&quot;headerlink&quot; title=&quot;构建爬虫系统&quot;&gt;&lt;/a&gt;构建爬虫系统&lt;/h1&gt;&lt;h2 id=&quot;一、实现目的&quot;&gt;&lt;a href=&quot;#一、实现目的&quot; class=&quot;headerlink&quot; title=&quot;一、实现目的&quot;&gt;&lt;/a&gt;一、实现目的&lt;/h2&gt;&lt;p&gt;爬虫是文档的重要来源，所以这一节也比较重要，我会从爬虫的基础讲起，爬虫的构成如何编写爬虫等等，希望大家能跟着文档一步步动手做下去。
    
    </summary>
    
    
      <category term="Linux" scheme="https://luckyle.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://luckyle.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>四十岁的吃鸡玩家</title>
    <link href="https://luckyle.top/Live/%E5%9B%9B%E5%8D%81%E5%B2%81%E7%9A%84%E5%90%83%E9%B8%A1%E7%8E%A9%E5%AE%B6/"/>
    <id>https://luckyle.top/Live/%E5%9B%9B%E5%8D%81%E5%B2%81%E7%9A%84%E5%90%83%E9%B8%A1%E7%8E%A9%E5%AE%B6/</id>
    <published>2018-09-21T05:29:49.000Z</published>
    <updated>2019-12-31T08:46:04.538Z</updated>
    
    <content type="html"><![CDATA[<p>四十岁的吃鸡玩家<br>我从家里出来，在马路边四处张望，寻找我叫的那辆滴滴快车。<br>司机已经来过电话，我拜托他多等一会儿，但现在已经过去了十多分钟，不知道他会不会已经取消订单。<br>情况并没有那么糟，我最终找到了那辆车。我上车之后才发现，司机居然在玩“刺激战场”。我看了一眼，三级包三级头，还挺肥。<br> <a id="more"></a><br>司机没有埋怨我的姗姗来迟，反而问我急不急着赶路。我连忙摆手，说道：“不急不急，你好好玩吧，这把有望吃鸡啊。”<br>司机一听，兴奋的说：“你也玩这个啊？”<br>“我就没事儿瞎玩玩。”<br>“你们年轻人玩这个应该挺厉害，我连前十都没进过几次。”<br>“哪有，你这把就很稳啊，这不马上就进前十了嘛。”<br>“哈哈，这把运气好…”<br>他话还没说完，就听见了一声枪响。他立刻集中精神，趴在草里，转动视角观察周围。<br>我也不再说话，静静的看他冲进决赛圈。</p><p>这时我才注意到，这位吃鸡玩家已经长了不少白发，脸上也有了皱纹。没想到这个年纪的大叔，也会热衷于吃鸡。</p><p>最后他止步于第二名，被一个穿着吉利服的“伏地魔”给淘汰了，只差一步就能吃鸡。我还觉得有些遗憾，他却十分满足。我忽然很好奇，他是因为什么开始玩这个游戏，他笑容一滞，随后说道：“因为我儿子喜欢玩这个，我就想着，要是我也玩的话，就能和他多说上几句话。”</p><p>我一时语塞，愣了片刻才缓缓开口：“你儿子真幸运，有你这样贴心的父亲。”<br>司机笑了笑：“嗐，天下哪个父母不是为了儿女操碎了心。”<br>“也是。你儿子多大了啊？”<br>“刚中考完，马上就高一了。”<br>他顿了顿，继续说道：“小时候还挺爱说话，上初中之后就不怎么和我聊天了。”<br>我安慰着：“叛逆期嘛，过了这段时间就好了。平时多陪陪他吧，比如一起吃鸡什么的。”<br>“现在每天晚上我都拉着他一起玩游戏，”他有些无奈，“但他嫌我技术差，不爱和我玩。每次都是我去睡的时候，他才能真正的和他的朋友玩。”</p><p>我忽然知道他为什么不会因为第二名而遗憾了，因为他在乎的从来都不是名次。第二名，意味着他的技术有了进步，意味着他能和儿子玩得更久。</p><p>我不知该如何接话。就在我沉默的时候，他又说道：“嘿嘿，我还打算下个‘王者荣耀’，我儿子也喜欢玩这个。”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;四十岁的吃鸡玩家&lt;br&gt;我从家里出来，在马路边四处张望，寻找我叫的那辆滴滴快车。&lt;br&gt;司机已经来过电话，我拜托他多等一会儿，但现在已经过去了十多分钟，不知道他会不会已经取消订单。&lt;br&gt;情况并没有那么糟，我最终找到了那辆车。我上车之后才发现，司机居然在玩“刺激战场”。我看了一眼，三级包三级头，还挺肥。&lt;br&gt;
    
    </summary>
    
    
      <category term="Live" scheme="https://luckyle.top/categories/Live/"/>
    
    
      <category term="Live" scheme="https://luckyle.top/tags/Live/"/>
    
  </entry>
  
</feed>
