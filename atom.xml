<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扼</title>
  
  <subtitle>下雨天，没有伞的孩子只能努力奔跑。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luckyle.top/"/>
  <updated>2019-12-22T11:53:41.942Z</updated>
  <id>https://luckyle.top/</id>
  
  <author>
    <name>杜家乐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cenos7下安装Python3.7</title>
    <link href="https://luckyle.top/2019/12/22/cenos7%E4%B8%8B%E5%AE%89%E8%A3%85Python3-7/"/>
    <id>https://luckyle.top/2019/12/22/cenos7%E4%B8%8B%E5%AE%89%E8%A3%85Python3-7/</id>
    <published>2019-12-22T11:51:59.000Z</published>
    <updated>2019-12-22T11:53:41.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>需要先sudo到root用户</p><h4 id="安装相关编译工具"><a href="#安装相关编译工具" class="headerlink" title="安装相关编译工具"></a>安装相关编译工具</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y groupinstall &quot;Development tools&quot;</span><br><span class="line">yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span><br><span class="line">yum install libffi-devel -y</span><br></pre></td></tr></table></figure><h4 id="下载并解压安装包"><a href="#下载并解压安装包" class="headerlink" title="下载并解压安装包"></a>下载并解压安装包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd 你自己的目录</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz</span><br><span class="line">tar -xvJf  Python-3.7.0.tar.xz</span><br></pre></td></tr></table></figure><h4 id="编译及安装"><a href="#编译及安装" class="headerlink" title="编译及安装"></a>编译及安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/python3 <span class="comment">#创建编译安装目录</span></span><br><span class="line"><span class="built_in">cd</span> Python-3.7.0</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/<span class="built_in">local</span>/bin/python3</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3 /usr/<span class="built_in">local</span>/bin/pip3</span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -V</span><br><span class="line">pip3 -V</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;&lt;p&gt;需要先sudo到root用户&lt;/p&gt;
&lt;h4 id=&quot;安装相关编译工具&quot;&gt;&lt;a href=&quot;#安装相关编译工具&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Installs" scheme="https://luckyle.top/categories/Installs/"/>
    
    
      <category term="Installs" scheme="https://luckyle.top/tags/Installs/"/>
    
  </entry>
  
  <entry>
    <title>Firewalld未运行</title>
    <link href="https://luckyle.top/2019/12/22/Firewalld%E6%9C%AA%E8%BF%90%E8%A1%8C/"/>
    <id>https://luckyle.top/2019/12/22/Firewalld%E6%9C%AA%E8%BF%90%E8%A1%8C/</id>
    <published>2019-12-22T11:44:03.000Z</published>
    <updated>2019-12-22T11:45:43.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="centos出现“FirewallD-is-not-running”怎么办"><a href="#centos出现“FirewallD-is-not-running”怎么办" class="headerlink" title="centos出现“FirewallD is not running”怎么办"></a><a href="https://www.cnblogs.com/rxbook/p/8110143.html" target="_blank" rel="noopener">centos出现“FirewallD is not running”怎么办</a></h1><p>最近在阿里云服务器centos上安装了mysql数据库，默认是不开启远端访问功能，需要设置一下防火墙，在开放默认端口号 3306时提示FirewallD is not running，经过排查发现是防火墙就没打开造成的，出于安装考虑还是把防火墙开上吧，以下步骤仅供参考啦。</p><h2 id="工具-原料"><a href="#工具-原料" class="headerlink" title="工具/原料"></a>工具/原料</h2><ul><li>阿里云服务器centos</li></ul><h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h2><ol><li><p>执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示FirewallD is not running，如下图所示。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=1" target="_blank" rel="noopener"><img src="https://imgsa.baidu.com/exp/w=500/sign=3783b5472134349b74066e85f9eb1521/7dd98d1001e939013391d96372ec54e737d196df.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>通过systemctl status firewalld查看firewalld状态，发现当前是dead状态，即防火墙未开启。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=2" target="_blank" rel="noopener"><img src="https://imgsa.baidu.com/exp/w=500/sign=0c6057bedc39b6004dce0fb7d9513526/55e736d12f2eb93882fe2eafdc628535e4dd6fdf.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>通过systemctl start firewalld开启防火墙，没有任何提示即开启成功。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=3" target="_blank" rel="noopener"><img src="https://imgsa.baidu.com/exp/w=500/sign=32b9322ef2f2b211e42e854efa816511/e61190ef76c6a7efec9afc7bf4faaf51f3de662a.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>再次通过systemctl status firewalld查看firewalld状态，显示running即已开启了。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=4" target="_blank" rel="noopener"><img src="https://imgsa.baidu.com/exp/w=500/sign=79a4d13cf11986184147ef847aec2e69/503d269759ee3d6d9f44d3964a166d224e4adee9.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>5</p><p>如果要关闭防火墙设置，可能通过systemctl stop firewalld这条指令来关闭该功能。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=5" target="_blank" rel="noopener"><img src="https://imgsa.baidu.com/exp/w=500/sign=ce97d76d33f33a879e6d001af65d1018/2e2eb9389b504fc2cecce458ecdde71191ef6ddf.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p></li><li><p>6</p><p>再次执行执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示success，表示设置成功，这样就可以继续后面的设置了。</p><p><a href="http://jingyan.baidu.com/album/5552ef47f509bd518ffbc933.html?picindex=6" target="_blank" rel="noopener"><img src="https://imgsa.baidu.com/exp/w=500/sign=9a524f1e82d4b31cf03c94bbb7d7276f/42166d224f4a20a4969c689a99529822730ed0e9.jpg" alt="centos出现“FirewallD is not running”怎么办"></a></p><p>END</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;centos出现“FirewallD-is-not-running”怎么办&quot;&gt;&lt;a href=&quot;#centos出现“FirewallD-is-not-running”怎么办&quot; class=&quot;headerlink&quot; title=&quot;centos出现“FirewallD
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://luckyle.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://luckyle.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis简介</title>
    <link href="https://luckyle.top/2019/12/21/Redis/"/>
    <id>https://luckyle.top/2019/12/21/Redis/</id>
    <published>2019-12-21T11:03:16.000Z</published>
    <updated>2019-12-21T11:07:06.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reids的特点"><a href="#Reids的特点" class="headerlink" title="Reids的特点"></a>Reids的特点</h2><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p><p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</p><p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。</p><p>比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。</p><p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h3 id="使用redis有哪些好处？"><a href="#使用redis有哪些好处？" class="headerlink" title="使用redis有哪些好处？"></a>使用redis有哪些好处？</h3><p>1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>2.支持丰富数据类型，支持string，list，set，sorted set，hash</p><p>3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p><p>4.丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h3 id="为什么redis需要把所有数据放到内存中"><a href="#为什么redis需要把所有数据放到内存中" class="headerlink" title="为什么redis需要把所有数据放到内存中?"></a>为什么redis需要把所有数据放到内存中?</h3><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p><p>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><h3 id="Redis是单进程单线程的"><a href="#Redis是单进程单线程的" class="headerlink" title="Redis是单进程单线程的"></a>Redis是单进程单线程的</h3><p>redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销</p><h3 id="单线程的redis为什么这么快"><a href="#单线程的redis为什么这么快" class="headerlink" title="单线程的redis为什么这么快"></a>单线程的redis为什么这么快</h3><p>回答:主要是以下三点</p><p>(一)纯内存操作</p><p>(二)单线程操作，避免了频繁的上下文切换</p><p>(三)采用了非阻塞I/O多路复用机制</p><h3 id="redis持久化的几种方式"><a href="#redis持久化的几种方式" class="headerlink" title="redis持久化的几种方式"></a>redis持久化的几种方式</h3><p>1、快照（snapshots）</p><p>缺省情况情况下，Redis把数据快照存放在磁盘上的二进制文件中，文件名为dump.rdb。你可以配置Redis的持久化策略，例如数据集中每N秒钟有超过M次更新，就将数据写入磁盘；或者你可以手工调用命令SAVE或BGSAVE。</p><p>工作原理</p><p>Redis forks.</p><p>子进程开始将数据写到临时RDB文件中。</p><p>当子进程完成写RDB文件，用新文件替换老文件。</p><p>这种方式可以使Redis使用copy-on-write技术。</p><p>2、AOF</p><p>快照模式并不十分健壮，当系统停止，或者无意中Redis被kill掉，最后写入Redis的数据就会丢失。</p><p>这对某些应用也许不是大问题，但对于要求高可靠性的应用来说，Redis就不是一个合适的选择。Append-only文件模式是另一种选择。你可以在配置文件中打开AOF模式</p><p>3、虚拟内存方式</p><p>当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大.</p><p>当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value.</p><p>vm-max-threads这个参数,可以设置访问swap文件的线程数,设置最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证.</p><p>自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库。</p><h3 id="使用过Redis分布式锁么，"><a href="#使用过Redis分布式锁么，" class="headerlink" title="使用过Redis分布式锁么，"></a>使用过Redis分布式锁么，</h3><p>它是什么回事？先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p><h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h3 id="使用过Redis做异步队列么，你是怎么用的？"><a href="#使用过Redis做异步队列么，你是怎么用的？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？"></a>使用过Redis做异步队列么，你是怎么用的？</h3><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。 如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p><h3 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h3><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h3 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h3><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h3 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h3><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h3 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h3><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p><h3 id="什么是Redis的并发竞争问题"><a href="#什么是Redis的并发竞争问题" class="headerlink" title="什么是Redis的并发竞争问题"></a>什么是Redis的并发竞争问题</h3><p>Redis的并发竞争问题，主要是发生在并发写竞争。</p><p>考虑到redis没有像db中的sql语句，update val = val + 10 where …，无法使用这种方式进行对数据的更新。</p><p>假如有某个key = “price”， value值为10，现在想把value值进行+10操作。正常逻辑下，就是先把数据key为price的值读回来，加上10，再把值给设置回去。如果只有一个连接的情况下，这种方式没有问题，可以工作得很好，但如果有两个连接时，两个连接同时想对还price进行+10操作，就可能会出现问题了。</p><p>例如：两个连接同时对price进行写操作，同时加10，最终结果我们知道，应该为30才是正确。</p><p>考虑到一种情况：</p><p>T1时刻，连接1将price读出，目标设置的数据为10+10 = 20。</p><p>T2时刻，连接2也将数据读出，也是为10，目标设置为20。</p><p>T3时刻，连接1将price设置为20。</p><p>T4时刻，连接2也将price设置为20，则最终结果是一个错误值20。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用乐观锁的方式进行解决（成本较低，非阻塞，性能较高）</p><p>如何用乐观锁方式进行解决？</p><p>本质上是假设不会进行冲突，使用redis的命令watch进行构造条件。伪代码如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">watch price</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">get</span> price <span class="variable">$price</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$price</span> = <span class="variable">$price</span> + 10</span><br><span class="line"></span><br><span class="line">multi</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> price <span class="variable">$price</span></span><br><span class="line"></span><br><span class="line">exec</span><br></pre></td></tr></table></figure><p>watch这里表示监控该key值，后面的事务是有条件的执行，如果从watch的exec语句执行时，watch的key对应的value值被修改了，则事务不会执行。</p><p>方案2 这个是针对客户端来的，在代码里要对redis操作的时候，针对同一key的资源，就先进行加锁（java里的synchronized或lock）。</p><p>方案3 利用redis的setnx实现内置的锁。</p><h3 id="redis和memcached的区别（总结）"><a href="#redis和memcached的区别（总结）" class="headerlink" title="redis和memcached的区别（总结）"></a>redis和memcached的区别（总结）</h3><p>1、Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；</p><p>2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；</p><p>3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；</p><p>4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10；</p><p>5、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从；</p><p>6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；</p><p>7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；</p><p>8、Redis支持数据的备份，即master-slave模式的数据备份；</p><p>应用场景</p><p>redis：数据量较小的更性能操作和运算上</p><p>memcache：用于在动态系统中减少数据库负载，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）</p><p>MongoDB:主要解决海量数据的访问效率问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Reids的特点&quot;&gt;&lt;a href=&quot;#Reids的特点&quot; class=&quot;headerlink&quot; title=&quot;Reids的特点&quot;&gt;&lt;/a&gt;Reids的特点&lt;/h2&gt;&lt;p&gt;Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://luckyle.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://luckyle.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>八大查找</title>
    <link href="https://luckyle.top/2019/12/21/%E5%85%AB%E5%A4%A7%E6%9F%A5%E6%89%BE/"/>
    <id>https://luckyle.top/2019/12/21/%E5%85%AB%E5%A4%A7%E6%9F%A5%E6%89%BE/</id>
    <published>2019-12-21T11:01:14.000Z</published>
    <updated>2019-12-21T11:02:21.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>算法简介 顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。 基本思路 从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。 优缺点 缺点：是当n 很大时，平均查找长度较大，效率低； 优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。 算法实现</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def sequential_search(lis, <span class="meta">key</span>):</span><br><span class="line">  <span class="meta">length</span> = l<span class="meta">en(</span>lis)</span><br><span class="line">  for i <span class="meta">in</span><span class="meta"> range(</span><span class="meta">length</span>):</span><br><span class="line">    <span class="meta">if</span> lis[i] == <span class="meta">key</span>:</span><br><span class="line">      <span class="meta">return</span> i</span><br><span class="line">    <span class="meta">else</span>:</span><br><span class="line">      <span class="meta">return</span> False</span><br></pre></td></tr></table></figure><h1 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h1><p>二分查找（Binary Search），是一种在有序数组中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。 这种查找算法每一次比较都使查找范围缩小一半。</p><p>算法描述 给予一个包含 个带值元素的数组A 1、 令 L为0 ， R为 n-1 2、 如果L&gt;R，则搜索以失败告终 3、 令 m (中间值元素)为 ⌊(L+R)/2⌋ 4、 如果 AmT，令 R为 m - 1 并回到步骤二 复杂度分析 时间复杂度：折半搜索每次把搜索区域减少一半，时间复杂度为 O(logn) 空间复杂度：O(1)</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def binary_search(lis, key):</span><br><span class="line">  low = <span class="number">0</span></span><br><span class="line">  high = <span class="built_in">len</span>(lis) - <span class="number">1</span></span><br><span class="line">  <span class="built_in">time</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> low &lt; high:</span><br><span class="line">    <span class="built_in">time</span> += <span class="number">1</span></span><br><span class="line">    <span class="keyword">mid</span> = int((low + high) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> key &lt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">    elif key &gt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 打印折半的次数</span></span><br><span class="line">      print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">      <span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">  print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">  <span class="literal">return</span> False</span><br></pre></td></tr></table></figure><h1 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h1><p>算法简介</p><p>插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。 时间复杂度o(logn)但对于表长较大而关键字分布比较均匀的查找表来说，效率较高。</p><p>算法思想 基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。 注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p><p>复杂度分析 时间复杂性：如果元素均匀分布，则O（log log n）），在最坏的情况下可能需要O（n）。 空间复杂度：O（1）。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def binary_search(lis, key):</span><br><span class="line">  low = <span class="number">0</span></span><br><span class="line">  high = <span class="built_in">len</span>(lis) - <span class="number">1</span></span><br><span class="line">  <span class="built_in">time</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> low &lt; high:</span><br><span class="line">    <span class="built_in">time</span> += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 计算mid值是插值算法的核心代码</span></span><br><span class="line">    <span class="keyword">mid</span> = low + int((high - low) * (key - lis[low])/(lis[high] - lis[low]))</span><br><span class="line">    print(<span class="string">"mid=%s, low=%s, high=%s"</span> % (<span class="keyword">mid</span>, low, high))</span><br><span class="line">    <span class="keyword">if</span> key &lt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">    elif key &gt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 打印查找的次数</span></span><br><span class="line">      print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">      <span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">  print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">  <span class="literal">return</span> False</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  LIST = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">  <span class="built_in">result</span> = binary_search(LIST, <span class="number">444</span>)</span><br><span class="line">  print(<span class="built_in">result</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;顺序查找&quot;&gt;&lt;a href=&quot;#顺序查找&quot; class=&quot;headerlink&quot; title=&quot;顺序查找&quot;&gt;&lt;/a&gt;顺序查找&lt;/h1&gt;&lt;p&gt;算法简介 顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(
      
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝的区别</title>
    <link href="https://luckyle.top/2019/12/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://luckyle.top/2019/12/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2019-12-21T10:48:01.000Z</published>
    <updated>2019-12-21T10:49:46.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深拷贝和浅拷贝之间的区别是什么？"><a href="#深拷贝和浅拷贝之间的区别是什么？" class="headerlink" title="深拷贝和浅拷贝之间的区别是什么？"></a>深拷贝和浅拷贝之间的区别是什么？</h1><p>对象的赋值就是简单的引用,a = [1,2,3], b=a, 在上述情况下,a和b是一样的,他们指向同一片内存,b不过是a的别名,是引用,我们可以使用b is a 去判断,返回True,表名他们地址相同内容也相同,也可以使用id()函数来查看.看两个列表地址是否相同.</p><p>深拷贝就是将一个对象拷贝到另一个对象中，这意味着如果你对一个对象的拷贝做出改变时，不会影响原对象。在Python中，我们使用函数deepcopy()执行深拷贝</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">copy</span></span><br><span class="line">b=<span class="built_in">copy</span>.deepcopy(a)</span><br></pre></td></tr></table></figure><p><img src="https://v3u.cn/book/img/deepcopy.jpg" alt="avatar"></p><p>而浅拷贝则是将一个对象的引用拷贝到另一个对象上，所以如果我们在拷贝中改动，会影响到原对象。我们使用函数function()执行浅拷贝</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b=<span class="keyword">copy</span>.<span class="keyword">copy</span>(a)</span><br></pre></td></tr></table></figure><p><img src="https://v3u.cn/book/img/copy.jpg" alt="img"></p><p>切片操作是浅拷贝</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深拷贝和浅拷贝之间的区别是什么？&quot;&gt;&lt;a href=&quot;#深拷贝和浅拷贝之间的区别是什么？&quot; class=&quot;headerlink&quot; title=&quot;深拷贝和浅拷贝之间的区别是什么？&quot;&gt;&lt;/a&gt;深拷贝和浅拷贝之间的区别是什么？&lt;/h1&gt;&lt;p&gt;对象的赋值就是简单的引用,a
      
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CentOS下yum Mongodb安装</title>
    <link href="https://luckyle.top/2019/12/21/Mongodb/"/>
    <id>https://luckyle.top/2019/12/21/Mongodb/</id>
    <published>2019-12-21T01:20:39.000Z</published>
    <updated>2019-12-21T01:22:48.311Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB的安装<br>CentOS 中使用yum安装：</p><p>touch /etc/yum.repos.d/mongodb-org-4.2.repo<br>vim /etc/yum.repos.d/mongodb-org-4.2.repo<br>添加如下内容：<br>[mongodb-org-4.2]<br>name=MongoDB Repository<br>baseurl=<a href="https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/" target="_blank" rel="noopener">https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/</a><br>gpgcheck=1<br>enabled=1<br>gpgkey=<a href="https://www.mongodb.org/static/pgp/server-4.2.asc" target="_blank" rel="noopener">https://www.mongodb.org/static/pgp/server-4.2.asc</a><br>使用yum安装：<br>yum install -y mongodb-org<br>启动时指定配置文件：</p><p>mongod -f /etc/mongo/mongod.conf</p><p>参考：</p><p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</a></p><p>MongoDB如何导入数据？<br>wget <a href="http://labfile.oss.aliyuncs.com/courses/1196/monkey_source_docs_json.dat" target="_blank" rel="noopener">http://labfile.oss.aliyuncs.com/courses/1196/monkey_source_docs_json.dat</a><br>mongoimport -d monkey -c source_docs monkey_source_docs_json.dat<br>MongoDB如何导出数据？<br>Mongodb中的mongoexport工具可以把一个collection导出成JSON格式或CSV格式的文件。可以通过参数指定导出的数据项，也可以根据指定的条件导出数据。<br>MongoDB如何备份数据？<br>mongodump -h dbhost -d dbname -o dbdirectory<br>-h：MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017<br>-d：需要备份的数据库实例，例如：test<br>-o：备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。<br>MongoDB如何恢复数据<br>mongorestore -h <hostname>&lt;:port&gt; -d dbname <path><br>–host &lt;:port&gt;, -h &lt;:port&gt;：<br>MongoDB所在服务器地址，默认为： localhost:27017<br>–db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2<br>–drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！<br><path>：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。你不能同时指定 <path> 和 –dir 选项，–dir也可以设置备份目录。<br>–dir：指定备份的目录,你不能同时指定 <path> 和 –dir 选项。<br>结巴分词<br>参考资料：</p><p><a href="https://www.cnblogs.com/clsn/p/8244206.html#auto_id_9" target="_blank" rel="noopener">https://www.cnblogs.com/clsn/p/8244206.html#auto_id_9</a></p><p><a href="https://motor.readthedocs.io/en/stable/tutorial-asyncio.html" target="_blank" rel="noopener">https://motor.readthedocs.io/en/stable/tutorial-asyncio.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MongoDB的安装&lt;br&gt;CentOS 中使用yum安装：&lt;/p&gt;
&lt;p&gt;touch /etc/yum.repos.d/mongodb-org-4.2.repo&lt;br&gt;vim /etc/yum.repos.d/mongodb-org-4.2.repo&lt;br&gt;添加如下内容：
      
    
    </summary>
    
    
      <category term="Mongodb" scheme="https://luckyle.top/categories/Mongodb/"/>
    
    
      <category term="Mongdb" scheme="https://luckyle.top/tags/Mongdb/"/>
    
  </entry>
  
  <entry>
    <title>随机验证码</title>
    <link href="https://luckyle.top/2019/12/20/%E9%9A%8F%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>https://luckyle.top/2019/12/20/%E9%9A%8F%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/</id>
    <published>2019-12-20T11:24:52.000Z</published>
    <updated>2019-12-20T11:25:51.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="验证码的书写"><a href="#验证码的书写" class="headerlink" title="验证码的书写"></a>验证码的书写</h1><p>​    验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分<a href="https://baike.baidu.com/item/计算机" target="_blank" rel="noopener">计算机</a>和人类的<a href="https://baike.baidu.com/item/图灵测试" target="_blank" rel="noopener">图灵测试</a>）的缩写，是一种区分用户是计算机还是人的公共全自动<a href="https://baike.baidu.com/item/程序/71525" target="_blank" rel="noopener">程序</a>。可以防止：恶意破解密码、<a href="https://baike.baidu.com/item/刷票/6540942" target="_blank" rel="noopener">刷票</a>、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Django</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> make_password,check_password</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> web.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入图片库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入绘画库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageDraw</span><br><span class="line"><span class="comment">#字体库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont</span><br><span class="line"><span class="comment">#随机库</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#图片库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="comment">#文件流</span></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取随机6位字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_str</span><span class="params">()</span>:</span></span><br><span class="line">    a_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>)])  <span class="comment">#小写字母</span></span><br><span class="line">    A_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>)])   <span class="comment">#大写字母</span></span><br><span class="line">    num_=[str(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>)]   <span class="comment">#数字 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(a_+A_+num_,<span class="number">4</span>))  <span class="comment">#返回随机4位字符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义验证码类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mycode</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment">#定义随机取色方法,混淆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_random_color</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#三原色</span></span><br><span class="line">        R=random.randrange(<span class="number">255</span>)</span><br><span class="line">        G=random.randrange(<span class="number">255</span>)</span><br><span class="line">        B=random.randrange(<span class="number">255</span>)</span><br><span class="line">        <span class="keyword">return</span> (R,G,B)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#定义画布</span></span><br><span class="line">        image_size=(<span class="number">120</span>,<span class="number">60</span>)</span><br><span class="line">        <span class="comment">#定义图像 颜色种类  画布  背景颜色</span></span><br><span class="line">        image=Image.new(<span class="string">'RGB'</span>,image_size,<span class="string">'white'</span>)</span><br><span class="line">        <span class="comment">#定义画笔</span></span><br><span class="line">        draw=ImageDraw.Draw(image,<span class="string">'RGB'</span>)</span><br><span class="line">        <span class="comment">#随机字符串的组成</span></span><br><span class="line">        source=get_random_str()</span><br><span class="line">        <span class="comment">#定义一个容器，接收</span></span><br><span class="line">        code_str=<span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="comment">#取色</span></span><br><span class="line">            text_color=self.get_random_color()</span><br><span class="line">            <span class="comment">#获取一个字符串</span></span><br><span class="line">            tmp_num=random.randrange(len(source))</span><br><span class="line">            <span class="comment">#获取字符集</span></span><br><span class="line">            random_str=source[tmp_num]</span><br><span class="line">            <span class="comment">#将随机生成的字符串放入定义好的容器</span></span><br><span class="line">            code_str+=random_str</span><br><span class="line">            <span class="comment">#将文字输入绘图</span></span><br><span class="line">            <span class="comment">#宽高，字符，颜色</span></span><br><span class="line">            draw.text((<span class="number">10</span>+<span class="number">30</span>*i,<span class="number">20</span>),random_str,text_color)</span><br><span class="line">        <span class="comment">#建立io文件流</span></span><br><span class="line">        buf=io.BytesIO()</span><br><span class="line">        <span class="comment">#将图片内容保存在内存中</span></span><br><span class="line">        image.save(buf,<span class="string">'png'</span>)</span><br><span class="line">        <span class="comment">#将验证码放入session</span></span><br><span class="line">        request.session[<span class="string">'code'</span>]=code_str</span><br><span class="line">        <span class="comment">#可以存入redis中   建立连接   存key  取key</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(buf.getvalue(),<span class="string">'image/png'</span>)   <span class="comment">#从内存中获取数据</span></span><br></pre></td></tr></table></figure><h4 id="点击图片且刷新"><a href="#点击图片且刷新" class="headerlink" title="点击图片且刷新"></a>点击图片且刷新</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">&lt;image <span class="string">":src=src"</span> <span class="meta">@click</span>=<span class="string">'changecode'</span>&gt;</span><br><span class="line">src=<span class="string">'http://127.0.0.1:8000/api/mycode/'</span></span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line"><span class="comment">//点击刷新验证码</span></span><br><span class="line"><span class="comment">//每次给它传一个随机字符,只要传了参数，就不会缓存，直接刷新</span></span><br><span class="line"><span class="comment">//在js中随机生成字符</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">10</span>);</span><br><span class="line"><span class="keyword">this</span>.src=<span class="keyword">this</span>.src+<span class="string">'?code='</span>+num;</span><br><span class="line"></span><br><span class="line">changecode()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;验证码的书写&quot;&gt;&lt;a href=&quot;#验证码的书写&quot; class=&quot;headerlink&quot; title=&quot;验证码的书写&quot;&gt;&lt;/a&gt;验证码的书写&lt;/h1&gt;&lt;p&gt;​    验证码（CAPTCHA）是“Completely Automated Public Turing 
      
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>&#39;hexo快速搭建博客&#39;</title>
    <link href="https://luckyle.top/2019/12/20/hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://luckyle.top/2019/12/20/hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-12-20T08:23:28.000Z</published>
    <updated>2019-12-20T08:24:29.693Z</updated>
    
    <content type="html"><![CDATA[<p>使用Hexo建立一个轻量、简易、高逼格的博客</p><pre><code>在之前的一篇文章中，介绍了如何使用Hugo在三分钟之内建立一个简单的个人博客系统，它是基于go lang的，其实，市面上还有一款类似的静态页生成器，就是Hexo 读音/hækso/ ，它是基于node.js的，和Hugo一样，Hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。</code></pre><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先安装Hexo，在此之前，请确保电脑里已经安装好新版的<span class="keyword">node</span>.<span class="title">js</span></span><br></pre></td></tr></table></figure><p>​    </p><p>npm install -g hexo-cli</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果感觉安装速度比较慢，可以为<span class="built_in">npm</span>指定国内的源</span><br></pre></td></tr></table></figure><p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装完成后，创建博客项目</span><br></pre></td></tr></table></figure><p>hexo init blog</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样，就建立起了一个<span class="keyword">blog文件夹，进入到blog目录下 </span>cd <span class="keyword">blog，建立第一篇文章</span></span><br></pre></td></tr></table></figure><p>hexo new myfirst</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后运行hexo服务</span><br></pre></td></tr></table></figure><p>hexo server</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">就可以在本地访问你的博客网站了，默认端口号是<span class="number">4000</span></span><br><span class="line"></span><br><span class="line">那么如何将博客网站打包呢？直接运行打包命令，这样就能使用 Hexo 引擎将 Markdown 格式的文件解析成可以使用浏览器查看的 HTML 文件，HTML 文件存储在 blog/<span class="keyword">public</span> 目录下</span><br></pre></td></tr></table></figure><p>hexo generate</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下面我们可以配置一下hexo主题，Hexo 提供了默认主题 landscape，主题的位置在 blog -&gt;themes 文件夹下。主题根据自己喜好可以在网上找到<span class="symbol">:https</span><span class="symbol">://hexo</span>.io/themes/</span><br><span class="line"></span><br><span class="line">主题都放在blog/themes文件夹下面，这我们下载一个新的主题</span><br></pre></td></tr></table></figure><p>mkdir themes/next<br>git clone –branch v5.1.2 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后在修改 <span class="regexp">/blog/</span>config.yml 文件，将其中的 theme 改成 <span class="keyword">next</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果没有自己的域名和服务器怎么办？没关系，可以申请 <span class="selector-tag">Github</span> 免费静态内容空间，在<span class="selector-tag">github</span><span class="selector-class">.com</span>注册一个账号，然后创建一个新的仓库</span><br></pre></td></tr></table></figure><p>​    </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">仓库名称一定要定义成 账号名<span class="selector-class">.github</span><span class="selector-class">.io</span>，这种形式，注意账号名一定要和你的<span class="selector-tag">github</span>当前登录的账号吻合</span><br></pre></td></tr></table></figure><p>​      </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这样你的静态内容空间就已经创建好了，在浏览器输入你的 <span class="string">https:</span><span class="comment">//你的账号.github.io/ 就可以访问了。</span></span><br><span class="line"></span><br><span class="line">将之前打包好的<span class="keyword">public</span>中的文件push到刚刚创建好的github仓库中去</span><br><span class="line"></span><br><span class="line">访问静态空间网址<span class="string">https:</span><span class="comment">//仓库名.github.io</span></span><br></pre></td></tr></table></figure><p>​    </p><p>没有问题，搞定收工</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Hexo建立一个轻量、简易、高逼格的博客&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在之前的一篇文章中，介绍了如何使用Hugo在三分钟之内建立一个简单的个人博客系统，它是基于go lang的，其实，市面上还有一款类似的静态页生成器，就是Hexo 读音/hækso/ ，它是基于nod
      
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>send_verify</title>
    <link href="https://luckyle.top/2019/12/20/send-verify/"/>
    <id>https://luckyle.top/2019/12/20/send-verify/</id>
    <published>2019-12-20T00:49:11.000Z</published>
    <updated>2019-12-20T06:10:42.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django-vue-验证码发送"><a href="#Django-vue-验证码发送" class="headerlink" title="Django +vue 验证码发送"></a>Django +vue 验证码发送</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> web.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL   <span class="comment">#settings里的一些配置</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">#settings配置具体如下:</span></span><br><span class="line">EMAIL_USE_SSL = <span class="literal">True</span> <span class="comment"># Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议</span></span><br><span class="line">    EMAIL_HOST = <span class="string">'smtp.qq.com'</span>  <span class="comment"># 邮件服务器地址</span></span><br><span class="line">    EMAIL_PORT = <span class="number">465</span> <span class="comment"># 邮件服务器端口</span></span><br><span class="line"> </span><br><span class="line">    EMAIL_HOST_USER = <span class="string">'1315532054@qq.com'</span> <span class="comment"># 登陆邮件服务器的账号</span></span><br><span class="line">    EMAIL_HOST_PASSWORD = <span class="string">'ownkpkdkumubhdjg'</span>  <span class="comment"># 登陆邮件服务器的密码</span></span><br><span class="line">    DEFAULT_FROM_EMAIL = EMAIL_HOST_USER <span class="comment"># 邮件的发送者</span></span><br></pre></td></tr></table></figure><!-- < !--more--> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取随机6位字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_str</span><span class="params">()</span>:</span></span><br><span class="line">    a_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>)])</span><br><span class="line">    A_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>)])</span><br><span class="line">    num_=[str(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(a_+A_+num_,<span class="number">6</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#邮件发送</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">send_verify</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">           1. 先检查 对应邮件是否再memcache里已经存在了验证码</span></span><br><span class="line"><span class="string">           2. 发现没有存在,那么需要生成6位随机字符</span></span><br><span class="line"><span class="string">           3. 存储入到memcache里,并设置60s的过期时间</span></span><br><span class="line"><span class="string">               email: 6str :60s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           遇到了同步发送邮件的问题,应该怎么办</span></span><br><span class="line"><span class="string">       '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        email=request.data[<span class="string">'email'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># email=request.POST.get('email')</span></span><br><span class="line">        <span class="comment"># 1. 先检查 对应邮件是否再memcache里已经存在了验证码</span></span><br><span class="line">        token=men.get(email)</span><br><span class="line">        <span class="comment">#2.如果没有存在，那么需要生成随机字符</span></span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'code'</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="string">'message'</span>:<span class="string">'该邮箱已存在验证码'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#该邮箱没有，生成随机字符</span></span><br><span class="line">            token=get_random_str()  <span class="comment">#随机字符</span></span><br><span class="line">            subject=<span class="string">'实验楼。。。。。。。。。。。'</span></span><br><span class="line">            message=<span class="string">'你的验证码是:%s'</span>%token</span><br><span class="line">            men.set(email,token,<span class="number">100</span>)  <span class="comment">#存储到memcache</span></span><br><span class="line">            <span class="comment"># print(men.get(token))</span></span><br><span class="line">            send_mail(subject,message,DEFAULT_FROM_EMAIL,[email])</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'code'</span>:<span class="number">1</span>,</span><br><span class="line">                <span class="string">'message'</span>:<span class="string">'验证码已发送'</span></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">send_verify()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!this.email)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        let form_data=new FormData()</span><br><span class="line">        form_data.append(<span class="string">'email'</span>,this.email)</span><br><span class="line"></span><br><span class="line">        axios(&#123;</span><br><span class="line">            url:<span class="string">'http://127.0.0.1:8000/api/send_verify/'</span>,</span><br><span class="line">            method:<span class="string">'post'</span>,</span><br><span class="line">            data:form_data</span><br><span class="line">        &#125;).then(res=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.data.code==<span class="number">1</span>)&#123;</span><br><span class="line">                alert(res.data.message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Django-vue-验证码发送&quot;&gt;&lt;a href=&quot;#Django-vue-验证码发送&quot; class=&quot;headerlink&quot; title=&quot;Django +vue 验证码发送&quot;&gt;&lt;/a&gt;Django +vue 验证码发送&lt;/h1&gt;&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python基础</title>
    <link href="https://luckyle.top/2019/08/11/python%E5%9F%BA%E7%A1%80/"/>
    <id>https://luckyle.top/2019/08/11/python%E5%9F%BA%E7%A1%80/</id>
    <published>2019-08-11T02:18:24.000Z</published>
    <updated>2019-12-21T10:46:36.276Z</updated>
    
    <content type="html"><![CDATA[<h5 id="解释一下Python中的三元运算"><a href="#解释一下Python中的三元运算" class="headerlink" title="解释一下Python中的三元运算"></a>解释一下Python中的三元运算</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">on</span> <span class="literal">true</span>] <span class="keyword">if</span> [expression] <span class="keyword">else</span> [<span class="keyword">on</span> <span class="literal">false</span>]</span><br></pre></td></tr></table></figure><p>如果表达式为True，就执行[on true]中的语句。否则，就执行[on false]中的语句</p><p>a,b=2,3</p><p>min=a if a&lt;b else b</p><p>min</p><h5 id="GIl全局解释器锁"><a href="#GIl全局解释器锁" class="headerlink" title="GIl全局解释器锁"></a>GIl全局解释器锁</h5><p>GIL: 全局解释器锁（英语：Global Interpreter Lock，缩写GIL），是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。[1]即便在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程。</p><p>解释一下Python中的继承</p><p>当一个类继承自另一个类，它就被称为一个子类/派生类，继承自父类/基类/超类。它会继承/获取所有类成员（属性和方法）。</p><p>继承能让我们重新使用代码，也能更容易的创建和维护应用。Python支持如下种类的继承：</p><h5 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h5><p>一个类继承自单个基类 多继承：一个类继承自多个基类 多级继承：一个类继承自单个基类，后者则继承自另一个基类 分层继承：多个类继承自单个基类 混合继承：两种或多种类型继承的混合</p><h5 id="解释Python中的help-和dir-函数"><a href="#解释Python中的help-和dir-函数" class="headerlink" title="解释Python中的help()和dir()函数"></a>解释Python中的help()和dir()函数</h5><p>Help()函数是一个内置函数，用于查看函数或模块用途的详细说明：</p><p>import copy</p><p>help(copy.copy)</p><p>Dir()函数也是Python内置函数，dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。</p><p>dir(copy.copy)</p><h5 id="什么是猴子补丁？"><a href="#什么是猴子补丁？" class="headerlink" title="什么是猴子补丁？"></a>什么是猴子补丁？</h5><p>在运行期间动态修改一个类或模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line"></span><br><span class="line">   def func(self):</span><br><span class="line"></span><br><span class="line">     print(&quot;Hi&quot;)</span><br><span class="line"></span><br><span class="line">def monkey(self):</span><br><span class="line"></span><br><span class="line">    print(&quot;Hi, monkey&quot;)</span><br><span class="line"></span><br><span class="line">m.A.func = monkey</span><br><span class="line"></span><br><span class="line">a = m.A()</span><br><span class="line"></span><br><span class="line">a.func()</span><br></pre></td></tr></table></figure><h5 id="请解释使用args和-kwargs的含义"><a href="#请解释使用args和-kwargs的含义" class="headerlink" title="请解释使用args和*kwargs的含义"></a>请解释使用args和*kwargs的含义</h5><p>当我们不知道向函数传递多少参数时，比如我们向传递一个列表或元组，我们就使用*args。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def func<span class="comment">(*args):</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    for i in args:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        print(i)  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">func(3,2,1,4,7)</span></span><br></pre></td></tr></table></figure><p>在我们不知道该传递多少关键字参数时，使用**kwargs来收集关键字参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def func(**kwargs):</span><br><span class="line"></span><br><span class="line">    for i in kwargs:</span><br><span class="line"></span><br><span class="line">        print(i,kwargs[i])</span><br><span class="line"> func(a=1,b=2,c=7)</span><br></pre></td></tr></table></figure><h5 id="什么是负索引？"><a href="#什么是负索引？" class="headerlink" title="什么是负索引？"></a>什么是负索引？</h5><p>负索引和正索引不同，它是从右边开始检索。</p><p>它也能用于列表中的切片：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mylist=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">mylist[-<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">mylist[-<span class="number">6</span>:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h5 id="解释Python中的join-和split-函数"><a href="#解释Python中的join-和split-函数" class="headerlink" title="解释Python中的join()和split()函数"></a>解释Python中的join()和split()函数</h5><p>Join()能让我们将指定字符添加至字符串中。</p><p>Split()能让我们用指定字符分割字符串。</p><h5 id="怎么移除一个字符串中的前导空格？"><a href="#怎么移除一个字符串中的前导空格？" class="headerlink" title="怎么移除一个字符串中的前导空格？"></a>怎么移除一个字符串中的前导空格？</h5><p>字符串中的前导空格就是出现在字符串中第一个非空格字符前的空格。我们使用方法Istrip()可以将它从字符串中移除。</p><p>‘   Ayushi ‘.lstrip()</p><p>可以看到，该字符串既有前导字符，也有后缀字符，调用Istrip()去除了前导空格。如果我们想去除后缀空格，就用rstrip()方法。</p><p>‘   Ayushi ‘.rstrip()</p><h5 id="Python中的pass语句是什么？"><a href="#Python中的pass语句是什么？" class="headerlink" title="Python中的pass语句是什么？"></a>Python中的pass语句是什么？</h5><p>在用Python写代码时，有时可能还没想好函数怎么写，只写了函数声明，但为了保证语法正确，必须输入一些东西，在这种情况下，我们会使用pass语句。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def func<span class="comment">(*args):</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pass</span></span><br></pre></td></tr></table></figure><p>同样，break语句能让我们跳出循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(7):</span><br><span class="line"></span><br><span class="line">    if i==3: </span><br><span class="line">break</span><br></pre></td></tr></table></figure><p>最后，continue语句能让我们跳到下个循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(7):</span><br><span class="line"></span><br><span class="line">   if i==3: </span><br><span class="line">   continue</span><br></pre></td></tr></table></figure><h5 id="Python中的闭包是什么？"><a href="#Python中的闭包是什么？" class="headerlink" title="Python中的闭包是什么？"></a>Python中的闭包是什么？</h5><p>当一个嵌套函数在其外部区域引用了一个值时，该嵌套函数就是一个闭包。其意义就是会记录这个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def A(x):</span><br><span class="line"></span><br><span class="line">    def B():</span><br><span class="line"></span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line">    return B</span><br></pre></td></tr></table></figure><h5 id="谈一谈Python的装饰器（decorator）"><a href="#谈一谈Python的装饰器（decorator）" class="headerlink" title="谈一谈Python的装饰器（decorator）"></a>谈一谈Python的装饰器（decorator）</h5><p>装饰器本质上是一个Python函数，它可以让其它函数在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。比如：插入日志、性能测试、事务处理、缓存、权限校验等。有了装饰器我们就可以抽离出大量的与函数功能无关的雷同代码进行重用。</p><p>装饰器其实就是一个闭包，把一个函数当做参数然后返回一个替代版函数</p><h5 id="解释一下Python中的逻辑运算符"><a href="#解释一下Python中的逻辑运算符" class="headerlink" title="解释一下Python中的逻辑运算符"></a>解释一下Python中的逻辑运算符</h5><p>Python中有3个逻辑运算符：and，or，not</p><h5 id="Python支持什么数据类型？"><a href="#Python支持什么数据类型？" class="headerlink" title="Python支持什么数据类型？"></a>Python支持什么数据类型？</h5><p>Numbers（数字）——用于保存数值</p><p>Strings（字符串）——字符串是一个字符序列。我们用单引号或双引号来声明字符串。</p><p>Lists（列表）——列表就是一些值的有序集合，我们用方括号声明列表。</p><p>Tuples（元组）——元组和列表一样，也是一些值的有序集合，区别是元组是不可变的，意味着我们无法改变元组内的值。</p><p>Dictionary（字典）——字典是一种数据结构，含有键值对。我们用大括号声明字典</p><h5 id="什么是切片？"><a href="#什么是切片？" class="headerlink" title="什么是切片？"></a>什么是切片？</h5><p>切片是Python中的一种方法，能让我们只检索列表、元素或字符串的一部分。在切片时，我们使用切片操作符[]。</p><p>(1,2,3,4,5)[2:4]</p><p>Python中的不可变集合（frozenset）是什么？</p><p>首先，我们讨论一下什么是集合。集合就是一系列数据项的合集，不存在任何副本。另外，集合是无序的。</p><p>这就意味着我们无法索引它。</p><p>不过，集合是可变的。而不可变集合却不可变，这意味着我们无法改变它的值，从而也使其无法作为字典的键值。</p><p>myset=frozenset([1,3,2,2])</p><p>myset</p><h5 id="解释lambda表达式，什么时候会用到它？"><a href="#解释lambda表达式，什么时候会用到它？" class="headerlink" title="解释lambda表达式，什么时候会用到它？"></a>解释lambda表达式，什么时候会用到它？</h5><p>如果我们需要一个只有单一表达式的函数，我们可以匿名定义它。拉姆达表达式通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。</p><p>(lambda a,b:a if a&gt;b else b)(3,3.5)</p><h5 id="实现斐波那契数列"><a href="#实现斐波那契数列" class="headerlink" title="实现斐波那契数列"></a>实现斐波那契数列</h5><p>fib = lambda n : n if n &lt;= 2 else fib(n-1)+fib(n-2)</p><h5 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h5><p>在调用一个函数的过程中，直接或间接地调用了函数本身这个就叫递归。但为了避免出现死循环，必须要有一个结束条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def facto(n):</span><br><span class="line"></span><br><span class="line">    if n==1: </span><br><span class="line">    return 1</span><br><span class="line"></span><br><span class="line">    return n*facto(n-1)</span><br><span class="line"></span><br><span class="line">facto(4)</span><br></pre></td></tr></table></figure><h5 id="什么是生成器？"><a href="#什么是生成器？" class="headerlink" title="什么是生成器？"></a>什么是生成器？</h5><p>生成器会生成一系列的值用于迭代，这样看它又是一种可迭代对象。它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。</p><h5 id="什么是迭代器？"><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h5><p>迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。我们使用inter()函数创建迭代器。</p><h5 id="请说说生成器和迭代器之间的区别"><a href="#请说说生成器和迭代器之间的区别" class="headerlink" title="请说说生成器和迭代器之间的区别?"></a>请说说生成器和迭代器之间的区别?</h5><p>在使用生成器时，我们创建一个函数；在使用迭代器时，我们使用内置函数iter()和next()。 在生成器中，我们使用关键字‘yield’来每次生成/返回一个对象。 生成器中有多少‘yield’语句，你可以自定义。 每次‘yield’暂停循环时，生成器会保存本地变量的状态。而迭代器并不会使用局部变量，它只需要一个可迭代对象进行迭代。 使用类可以实现你自己的迭代器，但无法实现生成器。 生成器运行速度快，语法简洁，更简单。 迭代器更能节约内存。</p><h5 id="Python中的yield用法"><a href="#Python中的yield用法" class="headerlink" title="Python中的yield用法"></a>Python中的yield用法</h5><p>yield简单说来就是一个生成器，这样函数它记住上次返 回时在函数体中的位置。对生成器第 二次(或n 次)调用跳转至该函 次)调用跳转至该函数。</p><h5 id="解释Python的参数传递机制"><a href="#解释Python的参数传递机制" class="headerlink" title="解释Python的参数传递机制"></a>解释Python的参数传递机制</h5><p>Python使用按引用传递（pass-by-reference）将参数传递到函数中。如果你改变一个函数内的参数，会影响到函数的调用。这是Python的默认操作。不过，如果我们传递字面参数，比如字符串、数字或元组，它们是按值传递，这是因为它们是不可变的。</p><p>python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值’来传递对象。</p><h5 id="如何在Python中创建自己的包？"><a href="#如何在Python中创建自己的包？" class="headerlink" title="如何在Python中创建自己的包？"></a>如何在Python中创建自己的包？</h5><p>Python中创建包是比较方便的，只需要在当前目录建立一个文件夹，文件夹中包含一个init.py文件和若干个模块文件，其中init.py可以是一个空文件，但还是建议将包中所有需要导出的变量放到all中，这样可以确保包的接口清晰明了，易于使用。</p><h5 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h5><p>元类是类的类对象，换言之类是元类的实例，Python中默认的元类为type，可以通过自定义元类的方式实现对类创建的控制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;解释一下Python中的三元运算&quot;&gt;&lt;a href=&quot;#解释一下Python中的三元运算&quot; class=&quot;headerlink&quot; title=&quot;解释一下Python中的三元运算&quot;&gt;&lt;/a&gt;解释一下Python中的三元运算&lt;/h5&gt;&lt;figure class=&quot;hi
      
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Mysql事务</title>
    <link href="https://luckyle.top/2019/06/09/Mysql%E4%BA%8B%E5%8A%A1/"/>
    <id>https://luckyle.top/2019/06/09/Mysql%E4%BA%8B%E5%8A%A1/</id>
    <published>2019-06-09T07:26:52.000Z</published>
    <updated>2019-12-21T08:50:56.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h1><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><ul><li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li><li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li><li>事务用来管理 insert,update,delete 语句</li></ul><p>一般来说，事务是必须满足4个条件（ACID）：：原子性（<strong>A</strong>tomicity，或称不可分割性）、一致性（<strong>C</strong>onsistency）、隔离性（<strong>I</strong>solation，又称独立性）、持久性（<strong>D</strong>urability）。</p><ul><li><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><hr><p>‘- 显示数据库：show databases;</p><h5 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h5><p>​    sql server（微软）windows 专有数据<br>​    mysql    默认端口:3306<br>​    oracle（重点）甲骨文<br>​    access<br>​    sqlite<br>​    ibm db2<br>​    关系型数据库管理系统</p><p>-查看 mysql 版本： select version();<br>primary key 主键   auto_increment 自动递增   not null ,要求该约束所修饰的字段，不能为null或空    unsigned 约束的字段，会去掉负值，添加到正值，范围 x 2 + 1</p><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>命令格式：select * from 表名 order by 字段名 asc(升序)|desc（降序）;<br>多字段排序<br>select * from department order by groups desc,kpi desc;<br>多字段排序时，先按第一字段排序，第一段相同的，再按第二字段排序。</p><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ul><li>创建数据库命令格式： <code>create database 数据库名字 charset=字符集</code></li><li>创建表命令格式: <code>create table 表名( 字段 属性 );</code></li></ul><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul><li>删除表<br>命令格式：drop table 表名;</li><li>删库<br>格式: <code>drop database 库名;</code><br>删除主键<br>alter table 表名 drop 主键字段名;<br>删除数据<br>命令格式<br>delete from 表名 where 【条件】</li></ul><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>-修改已创建的表名<br>命令格式：alter table 原表名 rename to  新表名;</p><p>旧改法：<br>      alter user ‘root’@’localhost’ identified by ‘mysql’;</p><p>-10.1.38-MariaDB 修改密码：<br>    update mysql.user set Password = password(‘1999’) where             user=’(root）’;<br>    flush privileges;<br>    exit;</p><p>远程链接:<br>    GRANT ALL PRIVILEGES ON * .* TO ‘root’@’%’ IDENTIFIED BY ‘root’ WITH GRANT OPTION;</p><p>mysql 配置文件：<br>     windows -&gt; mysql/bin/my.ini<br>     linux -&gt; mysq/my.cnf</p><h5 id="修改创建好的表字"><a href="#修改创建好的表字" class="headerlink" title="修改创建好的表字"></a>修改创建好的表字</h5><p>段命令格式: alter table 表名 change 原字段名 新字段名 字段类型 字段属性（约束）;<br>添加新的字段<br>命令格式: alter table 表名 add 字段名 字段类型 字段属性（约束）;<br>修改表名<br>命令格式：alter table 旧表名 rename to 新表名;<br>创建表后修改主键<br>alter table 表名 change 原字段名（要设为主键的字段） 新字段名 int primary key auto_incremnt not null;<br>修改数据<br>update 表名 set 字段名1=要修改值1,字段名2=要修改值2 where [条件]</p><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>基本查询<br>命令格式：select [要查询的字段，如果是所有字段，就是*;如果单个，写字段名] from 【表名】 where 【条件】<br>范围查询<br>命令格式： select [字段] from 表名 where 字段名 between 开始 and 结束<br>in ( ) 在 … 里 not in<br>模糊查询<br>命令格式： select [字段] from 表名 where 字段 like …%…<br>内联接查询<br>命令格式:select [字段] from 表名1 inner join 表名2 on 表名1.连接字段=表名2.连接字段<br>右链接<br>select * from student s right join class c on s.cls_id=c.id<br>左连接<br>select *  from class c left join student s on s.cls_id=c.id;<br>全联接<br> select * from class c left join student s on c.id=s.cls_id<br> union<br> select * from class c right join student s on c.id=s.cls_id;<br>自联接（自查询)<br>表和自身的连接，使用 inner join 来完成</p><h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><p>命令格式:<br>insert into 表名（字段名1,字段名2,字段名3…..）values(值1,值2,值3…);<br>另外一种形式<br>insert into 表名 values(字段1的值，字段2的值，字段3的值。。。。);</p><p>-分组<br>group by 分组<br>分组  group_concat()+group by </p><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="-聚合函数"></a>-聚合函数</h5><p>统计函数 count（）<br>命令格式： select count(要统计的字段) from 表名 where [条件]<br>求最大值<br>命令格式：select max(求最大值的字段) from 表名;<br>求最小值<br>命令格式：select min(要计算最小值的字段) from 表名;<br>求和<br>命令格式:<br>select sum(要求和/总数的字段) from 表名;<br>求平均值<br>select avg(要求平均值字段) from 表名;</p><p>having<br>having 和 where 都 可以对记录进行筛选；但是having跟在group by 后面，group by 跟在 where 后面；having 后面条件必须在 select 字段中出现，没有，就会报错；where 是必须是表中字段<br>where … group by … having</p><h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p>命令格式：<br>create view 视图名字 as select语句;<br>查看视图<br>命令格式：show tables;<br>删除视图<br>drop view 视图名字<br>修改视图<br>create or replace view 视图名字 as select语句;</p><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>查看索引<br>命令格式：<br>show index from 表名；<br>创建索引的命令<br>格式：<br>create index idx_索引名  on 表名（字段名（索引长度））<br>删除索引<br>命令格式:<br>drop index 索引名称 on 表名;</p><h5 id="三范式："><a href="#三范式：" class="headerlink" title="三范式："></a>三范式：</h5><p>1：确保每列保持原子性<br>2：确保表中每列都和主键直接相关<br>3：确保每列都和主键列直接相关，而不是间接相关</p><h5 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h5><p>​    是一个操作序列，这些操作要么都执行，要么都不执行，它是一个完整的，不可分割的工作单位。<br>事务具有的特性：原子性 ，一致，隔离，持久<br>开启事务：start transaction   / begin<br>提交         commit</p><p>当前时间加1天<br>select date_add(now(),interyal 1day)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-事务&quot;&gt;&lt;a href=&quot;#MySQL-事务&quot; class=&quot;headerlink&quot; title=&quot;MySQL 事务&quot;&gt;&lt;/a&gt;MySQL 事务&lt;/h1&gt;&lt;p&gt;MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人
      
    
    </summary>
    
    
      <category term="Mysql" scheme="https://luckyle.top/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://luckyle.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>八大排序</title>
    <link href="https://luckyle.top/2018/12/11/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
    <id>https://luckyle.top/2018/12/11/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</id>
    <published>2018-12-11T07:53:09.000Z</published>
    <updated>2019-12-21T10:54:43.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序；首先将第一个作为已经排好序的，然后每次从后的取出插入到前面并排序；</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def insert_sort(<span class="keyword">ilist</span>):</span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="keyword">ilist</span>)):</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">ilist</span>[i] &lt; <span class="keyword">ilist</span>[<span class="keyword">j</span>]:</span><br><span class="line">                <span class="keyword">ilist</span>.<span class="keyword">insert</span>(<span class="keyword">j</span>, <span class="keyword">ilist</span>.<span class="keyword">pop</span>(i))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">ilist</span></span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="keyword">bubble_sort(blist):</span></span><br><span class="line"><span class="keyword"> </span>   <span class="built_in">count</span> = len(<span class="keyword">blist)</span></span><br><span class="line"><span class="keyword"> </span>   for i in range(<span class="number">0</span>, <span class="built_in">count</span>):</span><br><span class="line">        for <span class="keyword">j </span>in range(i + <span class="number">1</span>, <span class="built_in">count</span>):</span><br><span class="line">            if <span class="keyword">blist[i] </span>&gt; <span class="keyword">blist[j]:</span></span><br><span class="line"><span class="keyword"> </span>               <span class="keyword">blist[i], </span><span class="keyword">blist[j] </span>= <span class="keyword">blist[j], </span><span class="keyword">blist[i]</span></span><br><span class="line"><span class="keyword"> </span>   return <span class="keyword">blist</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">blist </span>= <span class="keyword">bubble_sort([4,5,6,7,3,2,6,9,8])</span></span><br><span class="line"><span class="keyword">print(blist)</span></span><br></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p><p>时间复杂度：O(nlog₂n)</p><p>空间复杂度：O(nlog₂n)</p><p>稳定性：不稳定</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def quick<span class="constructor">_sort(<span class="params">qlist</span>)</span>:</span><br><span class="line">    <span class="keyword">if</span> qlist<span class="operator"> == </span><span class="literal">[]</span>:</span><br><span class="line">        return <span class="literal">[]</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        qfirst = qlist<span class="literal">[<span class="number">0</span>]</span></span><br><span class="line">        qless = quick<span class="constructor">_sort([<span class="params">l</span> <span class="params">for</span> <span class="params">l</span> <span class="params">in</span> <span class="params">qlist</span>[1:] <span class="params">if</span> <span class="params">l</span> &lt; <span class="params">qfirst</span>])</span></span><br><span class="line">        qmore = quick<span class="constructor">_sort([<span class="params">m</span> <span class="params">for</span> <span class="params">m</span> <span class="params">in</span> <span class="params">qlist</span>[1:] <span class="params">if</span> <span class="params">m</span> &gt;= <span class="params">qfirst</span>])</span></span><br><span class="line">        return qless + <span class="literal">[<span class="identifier">qfirst</span>]</span> + qmore</span><br><span class="line"></span><br><span class="line">qlist = quick<span class="constructor">_sort([4,5,6,7,3,2,6,9,8])</span></span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p>稳定性：不稳定</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def select_sort(slist):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(slist)):</span><br><span class="line">        x = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(slist)):</span><br><span class="line">            <span class="keyword">if</span> slist[j] &lt; slist[x]:</span><br><span class="line">                x = j</span><br><span class="line">        slist[i], slist[x] = slist[x], slist[i]</span><br><span class="line">    <span class="keyword">return</span> slist</span><br><span class="line"></span><br><span class="line">slist = select_sort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序：采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并</p><p>时间复杂度：O(nlog₂n)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def merge_sort(array):</span><br><span class="line">    def merge_arr(arr_l, arr_r):</span><br><span class="line">       <span class="built_in"> array </span>= []</span><br><span class="line">        while len(arr_l)<span class="built_in"> and </span>len(arr_r):</span><br><span class="line">           <span class="built_in"> if </span>arr_l[0] &lt;= arr_r[0]:</span><br><span class="line">                array.append(arr_l.pop(0))</span><br><span class="line">            elif arr_l[0] &gt; arr_r[0]:</span><br><span class="line">                array.append(arr_r.pop(0))</span><br><span class="line">       <span class="built_in"> if </span>len(arr_l) != 0:</span><br><span class="line">           <span class="built_in"> array </span>+= arr_l</span><br><span class="line">        elif len(arr_r) != 0:</span><br><span class="line">           <span class="built_in"> array </span>+= arr_r</span><br><span class="line">       <span class="built_in"> return </span>array</span><br><span class="line"></span><br><span class="line">    def recursive(array):</span><br><span class="line">       <span class="built_in"> if </span>len(array) == 1:</span><br><span class="line">           <span class="built_in"> return </span>array</span><br><span class="line">        mid = len(array) // 2</span><br><span class="line">        arr_l = recursive(array[:mid])</span><br><span class="line">        arr_r = recursive(array[mid:])</span><br><span class="line">       <span class="built_in"> return </span>merge_arr(arr_l, arr_r)</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> return </span>recursive(array)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;p&gt;插入排序：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量
      
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>四十岁的吃鸡玩家</title>
    <link href="https://luckyle.top/2018/09/21/%E5%9B%9B%E5%8D%81%E5%B2%81%E7%9A%84%E5%90%83%E9%B8%A1%E7%8E%A9%E5%AE%B6/"/>
    <id>https://luckyle.top/2018/09/21/%E5%9B%9B%E5%8D%81%E5%B2%81%E7%9A%84%E5%90%83%E9%B8%A1%E7%8E%A9%E5%AE%B6/</id>
    <published>2018-09-21T05:29:49.000Z</published>
    <updated>2019-12-21T07:29:44.106Z</updated>
    
    <content type="html"><![CDATA[<p>四十岁的吃鸡玩家<br>我从家里出来，在马路边四处张望，寻找我叫的那辆滴滴快车。<br>司机已经来过电话，我拜托他多等一会儿，但现在已经过去了十多分钟，不知道他会不会已经取消订单。<br>情况并没有那么糟，我最终找到了那辆车。我上车之后才发现，司机居然在玩“刺激战场”。我看了一眼，三级包三级头，还挺肥。</p><p>司机没有埋怨我的姗姗来迟，反而问我急不急着赶路。我连忙摆手，说道：“不急不急，你好好玩吧，这把有望吃鸡啊。”<br>司机一听，兴奋的说：“你也玩这个啊？”<br>“我就没事儿瞎玩玩。”<br>“你们年轻人玩这个应该挺厉害，我连前十都没进过几次。”<br>“哪有，你这把就很稳啊，这不马上就进前十了嘛。”<br>“哈哈，这把运气好…”<br>他话还没说完，就听见了一声枪响。他立刻集中精神，趴在草里，转动视角观察周围。<br>我也不再说话，静静的看他冲进决赛圈。</p><p>这时我才注意到，这位吃鸡玩家已经长了不少白发，脸上也有了皱纹。没想到这个年纪的大叔，也会热衷于吃鸡。</p><p>最后他止步于第二名，被一个穿着吉利服的“伏地魔”给淘汰了，只差一步就能吃鸡。我还觉得有些遗憾，他却十分满足。我忽然很好奇，他是因为什么开始玩这个游戏，他笑容一滞，随后说道：“因为我儿子喜欢玩这个，我就想着，要是我也玩的话，就能和他多说上几句话。”</p><p>我一时语塞，愣了片刻才缓缓开口：“你儿子真幸运，有你这样贴心的父亲。”<br>司机笑了笑：“嗐，天下哪个父母不是为了儿女操碎了心。”<br>“也是。你儿子多大了啊？”<br>“刚中考完，马上就高一了。”<br>他顿了顿，继续说道：“小时候还挺爱说话，上初中之后就不怎么和我聊天了。”<br>我安慰着：“叛逆期嘛，过了这段时间就好了。平时多陪陪他吧，比如一起吃鸡什么的。”<br>“现在每天晚上我都拉着他一起玩游戏，”他有些无奈，“但他嫌我技术差，不爱和我玩。每次都是我去睡的时候，他才能真正的和他的朋友玩。”</p><p>我忽然知道他为什么不会因为第二名而遗憾了，因为他在乎的从来都不是名次。第二名，意味着他的技术有了进步，意味着他能和儿子玩得更久。</p><p>我不知该如何接话。就在我沉默的时候，他又说道：“嘿嘿，我还打算下个‘王者荣耀’，我儿子也喜欢玩这个。”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;四十岁的吃鸡玩家&lt;br&gt;我从家里出来，在马路边四处张望，寻找我叫的那辆滴滴快车。&lt;br&gt;司机已经来过电话，我拜托他多等一会儿，但现在已经过去了十多分钟，不知道他会不会已经取消订单。&lt;br&gt;情况并没有那么糟，我最终找到了那辆车。我上车之后才发现，司机居然在玩“刺激战场”。我看
      
    
    </summary>
    
    
      <category term="Live" scheme="https://luckyle.top/categories/Live/"/>
    
    
      <category term="Live" scheme="https://luckyle.top/tags/Live/"/>
    
  </entry>
  
  <entry>
    <title>&#39;Jwt的应用&#39;</title>
    <link href="https://luckyle.top/2018/02/20/Jwt/"/>
    <id>https://luckyle.top/2018/02/20/Jwt/</id>
    <published>2018-02-20T08:23:28.000Z</published>
    <updated>2019-12-20T11:33:33.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><p>​     Json web token（JWT）是为了网络应用环境间传递声明而执行的一种基于JSON的开发标准（RFC 7519），该token被设计为紧凑且安全的，特别适用于分布式站点的单点登陆（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>   说起JWT，我们应该来谈一谈基于token的认证和传统的Session认证的区别。</p><h2 id="传统的session认证"><a href="#传统的session认证" class="headerlink" title="传统的session认证"></a>传统的session认证</h2><p>​    我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发送的请求，所以为了让我们的应用能识别是哪个用户发出的，我们只能在服务器存储一份用户登陆的信息，这份登陆信息会在响应时传递给服务器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的英哟个就能识别请求来自哪个用户了，这就是传统的基于sessino认证</p><p>​       但是这种基于session的认证使应用本身很难得扩展，随着不用客户端的增加，独立的服务器已无法承载更多的用户，而这个时候基于session认证应用的问题就会暴露出来</p><h2 id="基于session认证所显露的问题"><a href="#基于session认证所显露的问题" class="headerlink" title="基于session认证所显露的问题"></a>基于session认证所显露的问题</h2><p>​       Session：每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大</p><p>​        扩展性：用户认证之后，服务端做认证记录，如果认证的记录被保存在内存的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，响应的限制了负载均衡器的能力，也意味着限制了应用的扩展性</p><p>​        CSRF：因为是基于cookie来进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p><h2 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h2><p>​    基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或会话信息。这也就意味着机遇tokent认证机制的应用不需要去考虑用户在哪一台服务器登陆了，这就为应用的扩展提供了便利</p><p>​     流程是这样的</p><ul><li>用户使用用户名密码请求服务器</li><li>服务器进行验证用户信息</li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附加这个token值</li><li>服务器验证token，并返回数据</li></ul><p>​      这个token必须要在每次请求时发送给服务器，它应该保存在请求头中，另外，服务器要支持CORS（跨来源资源共享）策略，一般我们在服务端这么做就可以了 Access-Control-Allow-Origin：*</p><h2 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h2><p>​      JWT是由三部分构成，将这三段信息文本用链接构成了JWT字符串。就像这样</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ<span class="number">0</span>eXAiOiJKV<span class="number">1</span>QiLCJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiJ9</span>.eyJ<span class="attr">Vc2</span>VySWQiOjEyMywiVX<span class="symbol">Nlck5</span>hbWUiOiJhZ<span class="name">G1</span>pbiJ<span class="number">9.</span>Qjw<span class="number">1</span>epD<span class="number">5</span>P<span class="number">6</span>p<span class="number">4</span>Yy<span class="number">2</span>yju<span class="number">3</span>-fkq<span class="number">28</span>Pddz<span class="symbol">nqRj3</span>ESfALQy_U</span><br></pre></td></tr></table></figure><p>​    第一部分我们称它为头部（header）第二部分我们称其为载荷（payload，类似于飞机上承载的物品），第三部分是签证（signature）</p><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>​      JWT的头部承载的两部分信息：</p><ul><li><p>声明类型，这里是jwt</p></li><li><p>声明加密的算法，通常直接使用HMAC SHA256</p><p> 完整的头部就像下面这样的JSON</p></li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     'typ':'JWT',</span><br><span class="line">     'alg':'HS256'  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    然后将头部进行base64加密（该加密是可以对称解密的），构成了第一部分</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ<span class="number">0</span>eXAiOiJKV<span class="number">1</span>QiLCJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiJ9</span></span><br></pre></td></tr></table></figure><h2 id="plyload"><a href="#plyload" class="headerlink" title="plyload"></a>plyload</h2><p>​      载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p><ul><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明 </li></ul><p>​     标注中注册的声明（建议不强制使用）</p><ul><li>iss：jwt签发者</li><li>sub：jwt所面向的用户</li><li>aud：接收jwt的一方</li><li>exp：jwt的过期时间，这个过期时间必须大于签发时间</li><li>nbf：定义在什么时间之前，该jwt都是不可用的</li><li>iat：jwt的签发时间</li><li>jti：jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击 </li></ul><p>​    <strong>公共的声明：</strong></p><p>​       公共的声明可以添加任何的信息，一般添加用户的相关信息或其它业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密；</p><p>​     <strong>私有的声明</strong></p><p>​         私有的声明是提供者和消费者功能定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为名文信息。</p><p>​     定义一个payload</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    然后将其base64加密，得到jwt的一部分</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJzdWIiOiIxMj<span class="name">M0</span><span class="symbol">NTY3</span>ODkwIiwibmFtZSI<span class="number">6</span>Ikpva<span class="name">G4</span>gR<span class="name">G9</span>lIiwiYWRtaW<span class="number">4</span>iO<span class="symbol">nRydWV9</span></span><br></pre></td></tr></table></figure><p>Signature</p><p>​    jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ul><li>header(base64后的)</li><li>payload(base64后的)</li><li>secred     </li></ul><p>​       这个部分需要base64加密后的header和base64加密后的payload使用“.”连接组成的字符串，然后通过header中声明的加密方式进行加secret组合加密，然后就构成了jwt的第三部分</p><p>​      </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var encodedString = base64<span class="constructor">UrlEncode(<span class="params">header</span>)</span> + <span class="character">'.'</span> + base64<span class="constructor">UrlEncode(<span class="params">payload</span>)</span>;</span><br><span class="line">var signature = <span class="constructor">HMACSHA256(<span class="params">encodedString</span>, '<span class="params">secret</span>')</span>; <span class="comment">// TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure><p>​    将这三部分用“.”连接成一个完整的字符串，构成了最终的jwt：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiIsInR5</span>cCI<span class="number">6</span>IkpX<span class="attr">VCJ9</span>.eyJzdWIiOiIxMj<span class="name">M0</span><span class="symbol">NTY3</span>ODkwIiwibmFtZSI<span class="number">6</span>Ikpva<span class="name">G4</span>gR<span class="name">G9</span>lIiwiYWRtaW<span class="number">4</span>iO<span class="symbol">nRydWV9</span>.TJVA<span class="number">95</span><span class="keyword">Or</span><span class="name">M7</span>E<span class="number">2</span>cBab<span class="number">30</span>RMHrHDcEfxjoYZgeFO<span class="symbol">NFh7</span>HgQ</span><br></pre></td></tr></table></figure><p>​     注意：secret是保存在服务器端的，jwt的签发也是在服务端的，secret就是用来进行jwt的签发和jwt的验证，所以它就是你服务端的私钥，在任何场景都不应该流露出去，一旦客户端得知这个secret，那就意味着客户端可以自我签发jwt了</p><p> 应用 </p><p>​      一般是在请求头里加入Authorization，并加上Bearer标注：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">fetch</span>(<span class="string">'api/user/1'</span>, &#123;</span><br><span class="line">  <span class="attribute">headers</span>: &#123;</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">'Bearer '</span> + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​       服务端会验证token，如果验证通过就会返回相应的资源，整个流程就是这样</p><p><img src="https://images2017.cnblogs.com/blog/1147658/201711/1147658-20171118202151718-1630139158.png" alt="img"></p><p>   总结</p><p>​      优点：</p><ul><li>因为json的通用性，所以JWT是可以跨语言支持的，像C#，JavaScript，NodeJS，PHP等许多语言都可以使用</li><li>因为由了payload部分，所以JWT可以在自身存储一些其它业务逻辑所必要的非敏感信息</li><li>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的</li><li>它不需要在服务端保存会话信息，所以它易于应用的扩展</li></ul><p>​       安全相关</p><ul><li>不应该在jwt的payload部分存储敏感信息，因为该部分是客户端可解密的部分</li><li>保护好secret私钥。该私钥非常重要</li><li>如果可以，请使用https协议</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="comment">#加密</span></span><br><span class="line"><span class="comment">#第一个参数 用户敏感信息  第二个参数 密钥  第三个参数 加密算法 hs256</span></span><br><span class="line">encode_jwt=jwt.encode(&#123;<span class="string">'uid'</span>:<span class="string">'1'</span>&#125;,<span class="string">'123'</span>,algorithm=<span class="string">'HS256'</span>)</span><br><span class="line"><span class="comment">#返回一个字节码  加密后两个点分割，分成三部分。第一部分token头部，声明它是token  第二部分 载荷 存用户敏感信息  第三部分 算法</span></span><br><span class="line"><span class="comment">#转码  字符串  进行解密</span></span><br><span class="line">encode_str=str(encode_jwt,<span class="string">'utf-8'</span>)  <span class="comment">#强转， 声明编码python3 utf-8</span></span><br><span class="line"><span class="comment">#变成可用字符串</span></span><br><span class="line">print(encode_str)</span><br><span class="line"><span class="comment">#解码</span></span><br><span class="line">de_Code=jwt.decode(<span class="string">'加密后的字符串'</span>,<span class="string">'密钥'</span>，<span class="string">'声明算法'</span>)   (<span class="string">'12dcs'</span>,<span class="string">'123'</span>,algorithms=[<span class="string">'HS256'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#声明载荷</span></span><br><span class="line">improt datetime</span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line">过期时间  时间戳  敏感信息</span><br><span class="line">playlod=&#123;</span><br><span class="line">    <span class="string">'exp'</span>:int((datetime.datetime.now()) +datetime.timedelta(seconds=<span class="number">20</span>).timestap()),<span class="string">'data'</span>:&#123;<span class="string">'uid'</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#加密token</span></span><br><span class="line">encode_jwt=jwt.encode(playload,<span class="string">'123'</span>,algorithm=<span class="string">'HS256'</span>)</span><br><span class="line"><span class="comment">#解码</span></span><br><span class="line">algorithms=[<span class="string">'HS256'</span>]</span><br><span class="line"><span class="comment">#判断token过期</span></span><br><span class="line">datetime.datetime.now()</span><br><span class="line">如果当前时间大于过期时间则token过期</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#装饰器就是一个封装的闭包</span></span><br><span class="line"><span class="comment">#自定义装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_de</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decortor</span><span class="params">(view_func)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_wrapped_view</span><span class="params">(request,*args,**kwargs)</span>:</span></span><br><span class="line"><span class="comment">#此处写判断逻辑</span></span><br><span class="line">print(<span class="string">'请求开始'</span>)</span><br><span class="line"><span class="keyword">return</span> view_func(request,*args,**kwargs)</span><br><span class="line"><span class="keyword">return</span> _wrapped_viw</span><br><span class="line"><span class="keyword">return</span> decoror</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_de()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">haha</span><span class="params">(name)</span>:</span></span><br><span class="line">print(<span class="string">'谁是 %s'</span> name)</span><br><span class="line">haha(<span class="string">'张三'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是JWT&quot;&gt;&lt;a href=&quot;#什么是JWT&quot; class=&quot;headerlink&quot; title=&quot;什么是JWT&quot;&gt;&lt;/a&gt;什么是JWT&lt;/h2&gt;&lt;p&gt;​     Json web token（JWT）是为了网络应用环境间传递声明而执行的一种基于JSON的开发
      
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Django" scheme="https://luckyle.top/tags/Django/"/>
    
  </entry>
  
</feed>
