<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>扼</title>
  
  <subtitle>下雨天，没有伞的孩子只能努力奔跑。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luckyle.top/"/>
  <updated>2019-12-25T08:23:33.046Z</updated>
  <id>https://luckyle.top/</id>
  
  <author>
    <name>杜家乐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cenos7下安装Python3.7</title>
    <link href="https://luckyle.top/2019/12/22/cenos7%E4%B8%8B%E5%AE%89%E8%A3%85Python3-7/"/>
    <id>https://luckyle.top/2019/12/22/cenos7%E4%B8%8B%E5%AE%89%E8%A3%85Python3-7/</id>
    <published>2019-12-22T11:51:59.000Z</published>
    <updated>2019-12-25T08:23:33.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>需要先sudo到root用户<a id="more"></a></p><h4 id="安装相关编译工具"><a href="#安装相关编译工具" class="headerlink" title="安装相关编译工具"></a>安装相关编译工具</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y groupinstall &quot;Development tools&quot;</span><br><span class="line">yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span><br><span class="line">yum install libffi-devel -y</span><br></pre></td></tr></table></figure><h4 id="下载并解压安装包"><a href="#下载并解压安装包" class="headerlink" title="下载并解压安装包"></a>下载并解压安装包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd 你自己的目录</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz</span><br><span class="line">tar -xvJf  Python-3.7.0.tar.xz</span><br></pre></td></tr></table></figure><h4 id="编译及安装"><a href="#编译及安装" class="headerlink" title="编译及安装"></a>编译及安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/python3 <span class="comment">#创建编译安装目录</span></span><br><span class="line"><span class="built_in">cd</span> Python-3.7.0</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/<span class="built_in">local</span>/bin/python3</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3 /usr/<span class="built_in">local</span>/bin/pip3</span><br></pre></td></tr></table></figure><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -V</span><br><span class="line">pip3 -V</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;&lt;p&gt;需要先sudo到root用户
    
    </summary>
    
    
      <category term="Installs" scheme="https://luckyle.top/categories/Installs/"/>
    
    
      <category term="Installs" scheme="https://luckyle.top/tags/Installs/"/>
    
  </entry>
  
  <entry>
    <title>Firewalld未运行</title>
    <link href="https://luckyle.top/2019/12/22/Firewalld%E6%9C%AA%E8%BF%90%E8%A1%8C/"/>
    <id>https://luckyle.top/2019/12/22/Firewalld%E6%9C%AA%E8%BF%90%E8%A1%8C/</id>
    <published>2019-12-22T11:44:03.000Z</published>
    <updated>2019-12-25T08:23:53.617Z</updated>
    
    <content type="html"><![CDATA[<p>最近在阿里云服务器centos上安装了mysql数据库，默认是不开启远端访问功能，需要设置一下防火墙，在开放默认端口号 3306时提示FirewallD is not running，经过排查发现是防火墙就没打开造成的，出于安装考虑还是把防火墙开上吧，以下步骤仅供参考啦。<a id="more"></a></p><h2 id="工具-原料"><a href="#工具-原料" class="headerlink" title="工具/原料"></a>工具/原料</h2><ul><li>阿里云服务器centos</li></ul><h2 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h2><ol><li><p>执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示FirewallD is not running</p></li></ol><ol start="2"><li><p>通过systemctl status firewalld查看firewalld状态，发现当前是dead状态，即防火墙未开启。</p></li></ol><ol start="3"><li><p>通过systemctl start firewalld开启防火墙，没有任何提示即开启成功。</p></li></ol><ol start="4"><li><p>再次通过systemctl status firewalld查看firewalld状态，显示running即已开启了。</p></li></ol><ol start="5"><li><p>如果要关闭防火墙设置，可能通过systemctl stop firewalld这条指令来关闭该功能。</p></li></ol><ol start="6"><li><p>再次执行执行firewall-cmd –permanent –zone=public –add-port=3306/tcp，提示success，表示设置成功，这样就可以继续后面的设置了。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在阿里云服务器centos上安装了mysql数据库，默认是不开启远端访问功能，需要设置一下防火墙，在开放默认端口号 3306时提示FirewallD is not running，经过排查发现是防火墙就没打开造成的，出于安装考虑还是把防火墙开上吧，以下步骤仅供参考啦。
    
    </summary>
    
    
      <category term="Linux" scheme="https://luckyle.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://luckyle.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis简介</title>
    <link href="https://luckyle.top/2019/12/21/Redis/"/>
    <id>https://luckyle.top/2019/12/21/Redis/</id>
    <published>2019-12-21T11:03:16.000Z</published>
    <updated>2019-12-24T12:57:12.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reids的特点"><a href="#Reids的特点" class="headerlink" title="Reids的特点"></a>Reids的特点</h2><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p><p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。<a id="more"></a></p><p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。</p><p>比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。</p><p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h3 id="使用redis有哪些好处？"><a href="#使用redis有哪些好处？" class="headerlink" title="使用redis有哪些好处？"></a>使用redis有哪些好处？</h3><p>1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>2.支持丰富数据类型，支持string，list，set，sorted set，hash</p><p>3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</p><p>4.丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h3 id="为什么redis需要把所有数据放到内存中"><a href="#为什么redis需要把所有数据放到内存中" class="headerlink" title="为什么redis需要把所有数据放到内存中?"></a>为什么redis需要把所有数据放到内存中?</h3><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p><p>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p><h3 id="Redis是单进程单线程的"><a href="#Redis是单进程单线程的" class="headerlink" title="Redis是单进程单线程的"></a>Redis是单进程单线程的</h3><p>redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销</p><h3 id="单线程的redis为什么这么快"><a href="#单线程的redis为什么这么快" class="headerlink" title="单线程的redis为什么这么快"></a>单线程的redis为什么这么快</h3><p>回答:主要是以下三点</p><p>(一)纯内存操作</p><p>(二)单线程操作，避免了频繁的上下文切换</p><p>(三)采用了非阻塞I/O多路复用机制</p><h3 id="redis持久化的几种方式"><a href="#redis持久化的几种方式" class="headerlink" title="redis持久化的几种方式"></a>redis持久化的几种方式</h3><p>1、快照（snapshots）</p><p>缺省情况情况下，Redis把数据快照存放在磁盘上的二进制文件中，文件名为dump.rdb。你可以配置Redis的持久化策略，例如数据集中每N秒钟有超过M次更新，就将数据写入磁盘；或者你可以手工调用命令SAVE或BGSAVE。</p><p>工作原理</p><p>Redis forks.</p><p>子进程开始将数据写到临时RDB文件中。</p><p>当子进程完成写RDB文件，用新文件替换老文件。</p><p>这种方式可以使Redis使用copy-on-write技术。</p><p>2、AOF</p><p>快照模式并不十分健壮，当系统停止，或者无意中Redis被kill掉，最后写入Redis的数据就会丢失。</p><p>这对某些应用也许不是大问题，但对于要求高可靠性的应用来说，Redis就不是一个合适的选择。Append-only文件模式是另一种选择。你可以在配置文件中打开AOF模式</p><p>3、虚拟内存方式</p><p>当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大.</p><p>当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value.</p><p>vm-max-threads这个参数,可以设置访问swap文件的线程数,设置最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证.</p><p>自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库。</p><h3 id="使用过Redis分布式锁么，"><a href="#使用过Redis分布式锁么，" class="headerlink" title="使用过Redis分布式锁么，"></a>使用过Redis分布式锁么，</h3><p>它是什么回事？先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p><h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><p>使用keys指令可以扫出指定模式的key列表。对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h3 id="使用过Redis做异步队列么，你是怎么用的？"><a href="#使用过Redis做异步队列么，你是怎么用的？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？"></a>使用过Redis做异步队列么，你是怎么用的？</h3><p>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。 如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p><h3 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h3><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h3 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h3><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h3 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h3><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p><h3 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h3><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p><h3 id="什么是Redis的并发竞争问题"><a href="#什么是Redis的并发竞争问题" class="headerlink" title="什么是Redis的并发竞争问题"></a>什么是Redis的并发竞争问题</h3><p>Redis的并发竞争问题，主要是发生在并发写竞争。</p><p>考虑到redis没有像db中的sql语句，update val = val + 10 where …，无法使用这种方式进行对数据的更新。</p><p>假如有某个key = “price”， value值为10，现在想把value值进行+10操作。正常逻辑下，就是先把数据key为price的值读回来，加上10，再把值给设置回去。如果只有一个连接的情况下，这种方式没有问题，可以工作得很好，但如果有两个连接时，两个连接同时想对还price进行+10操作，就可能会出现问题了。</p><p>例如：两个连接同时对price进行写操作，同时加10，最终结果我们知道，应该为30才是正确。</p><p>考虑到一种情况：</p><p>T1时刻，连接1将price读出，目标设置的数据为10+10 = 20。</p><p>T2时刻，连接2也将数据读出，也是为10，目标设置为20。</p><p>T3时刻，连接1将price设置为20。</p><p>T4时刻，连接2也将price设置为20，则最终结果是一个错误值20。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用乐观锁的方式进行解决（成本较低，非阻塞，性能较高）</p><p>如何用乐观锁方式进行解决？</p><p>本质上是假设不会进行冲突，使用redis的命令watch进行构造条件。伪代码如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">watch price</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">get</span> price <span class="variable">$price</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$price</span> = <span class="variable">$price</span> + 10</span><br><span class="line"></span><br><span class="line">multi</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span> price <span class="variable">$price</span></span><br><span class="line"></span><br><span class="line">exec</span><br></pre></td></tr></table></figure><p>watch这里表示监控该key值，后面的事务是有条件的执行，如果从watch的exec语句执行时，watch的key对应的value值被修改了，则事务不会执行。</p><p>方案2 这个是针对客户端来的，在代码里要对redis操作的时候，针对同一key的资源，就先进行加锁（java里的synchronized或lock）。</p><p>方案3 利用redis的setnx实现内置的锁。</p><h3 id="redis和memcached的区别（总结）"><a href="#redis和memcached的区别（总结）" class="headerlink" title="redis和memcached的区别（总结）"></a>redis和memcached的区别（总结）</h3><p>1、Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；</p><p>2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；</p><p>3、虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；</p><p>4、过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10；</p><p>5、分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从；</p><p>6、存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；</p><p>7、灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；</p><p>8、Redis支持数据的备份，即master-slave模式的数据备份；</p><p>应用场景</p><p>redis：数据量较小的更性能操作和运算上</p><p>memcache：用于在动态系统中减少数据库负载，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）</p><p>MongoDB:主要解决海量数据的访问效率问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Reids的特点&quot;&gt;&lt;a href=&quot;#Reids的特点&quot; class=&quot;headerlink&quot; title=&quot;Reids的特点&quot;&gt;&lt;/a&gt;Reids的特点&lt;/h2&gt;&lt;p&gt;Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。&lt;/p&gt;
&lt;p&gt;因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。
    
    </summary>
    
    
      <category term="Redis" scheme="https://luckyle.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://luckyle.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>八大查找</title>
    <link href="https://luckyle.top/2019/12/21/%E5%85%AB%E5%A4%A7%E6%9F%A5%E6%89%BE/"/>
    <id>https://luckyle.top/2019/12/21/%E5%85%AB%E5%A4%A7%E6%9F%A5%E6%89%BE/</id>
    <published>2019-12-21T11:01:14.000Z</published>
    <updated>2019-12-25T08:23:09.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>算法简介 顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。 基本思路 从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。 优缺点 缺点：是当n 很大时，平均查找长度较大，效率低； 优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。 算法实现 <a id="more"></a></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def sequential_search(lis, <span class="meta">key</span>):</span><br><span class="line">  <span class="meta">length</span> = l<span class="meta">en(</span>lis)</span><br><span class="line">  for i <span class="meta">in</span><span class="meta"> range(</span><span class="meta">length</span>):</span><br><span class="line">    <span class="meta">if</span> lis[i] == <span class="meta">key</span>:</span><br><span class="line">      <span class="meta">return</span> i</span><br><span class="line">    <span class="meta">else</span>:</span><br><span class="line">      <span class="meta">return</span> False</span><br></pre></td></tr></table></figure><h1 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h1><p>二分查找（Binary Search），是一种在有序数组中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。 这种查找算法每一次比较都使查找范围缩小一半。</p><p>算法描述 给予一个包含 个带值元素的数组A 1、 令 L为0 ， R为 n-1 2、 如果L&gt;R，则搜索以失败告终 3、 令 m (中间值元素)为 ⌊(L+R)/2⌋ 4、 如果 AmT，令 R为 m - 1 并回到步骤二 复杂度分析 时间复杂度：折半搜索每次把搜索区域减少一半，时间复杂度为 O(logn) 空间复杂度：O(1)</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def binary_search(lis, key):</span><br><span class="line">  low = <span class="number">0</span></span><br><span class="line">  high = <span class="built_in">len</span>(lis) - <span class="number">1</span></span><br><span class="line">  <span class="built_in">time</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> low &lt; high:</span><br><span class="line">    <span class="built_in">time</span> += <span class="number">1</span></span><br><span class="line">    <span class="keyword">mid</span> = int((low + high) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> key &lt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">    elif key &gt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 打印折半的次数</span></span><br><span class="line">      print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">      <span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">  print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">  <span class="literal">return</span> False</span><br></pre></td></tr></table></figure><h1 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h1><p>算法简介</p><p>插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。 时间复杂度o(logn)但对于表长较大而关键字分布比较均匀的查找表来说，效率较高。</p><p>算法思想 基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。 注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p><p>复杂度分析 时间复杂性：如果元素均匀分布，则O（log log n）），在最坏的情况下可能需要O（n）。 空间复杂度：O（1）。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def binary_search(lis, key):</span><br><span class="line">  low = <span class="number">0</span></span><br><span class="line">  high = <span class="built_in">len</span>(lis) - <span class="number">1</span></span><br><span class="line">  <span class="built_in">time</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> low &lt; high:</span><br><span class="line">    <span class="built_in">time</span> += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 计算mid值是插值算法的核心代码</span></span><br><span class="line">    <span class="keyword">mid</span> = low + int((high - low) * (key - lis[low])/(lis[high] - lis[low]))</span><br><span class="line">    print(<span class="string">"mid=%s, low=%s, high=%s"</span> % (<span class="keyword">mid</span>, low, high))</span><br><span class="line">    <span class="keyword">if</span> key &lt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      high = <span class="keyword">mid</span> - <span class="number">1</span></span><br><span class="line">    elif key &gt; lis[<span class="keyword">mid</span>]:</span><br><span class="line">      low = <span class="keyword">mid</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 打印查找的次数</span></span><br><span class="line">      print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">      <span class="literal">return</span> <span class="keyword">mid</span></span><br><span class="line">  print(<span class="string">"times: %s"</span> % <span class="built_in">time</span>)</span><br><span class="line">  <span class="literal">return</span> False</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  LIST = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">22</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">200</span>, <span class="number">222</span>, <span class="number">444</span>]</span><br><span class="line">  <span class="built_in">result</span> = binary_search(LIST, <span class="number">444</span>)</span><br><span class="line">  print(<span class="built_in">result</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;顺序查找&quot;&gt;&lt;a href=&quot;#顺序查找&quot; class=&quot;headerlink&quot; title=&quot;顺序查找&quot;&gt;&lt;/a&gt;顺序查找&lt;/h1&gt;&lt;p&gt;算法简介 顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。 基本思路 从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。 优缺点 缺点：是当n 很大时，平均查找长度较大，效率低； 优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。 算法实现
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝的区别</title>
    <link href="https://luckyle.top/2019/12/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://luckyle.top/2019/12/21/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2019-12-21T10:48:01.000Z</published>
    <updated>2019-12-25T08:24:06.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深拷贝和浅拷贝之间的区别是什么？"><a href="#深拷贝和浅拷贝之间的区别是什么？" class="headerlink" title="深拷贝和浅拷贝之间的区别是什么？"></a>深拷贝和浅拷贝之间的区别是什么？</h1><p>对象的赋值就是简单的引用,a = [1,2,3], b=a, 在上述情况下,a和b是一样的,他们指向同一片内存,b不过是a的别名,是引用,我们可以使用b is a 去判断,返回True,表名他们地址相同内容也相同,也可以使用id()函数来查看.看两个列表地址是否相同.<a id="more"></a></p><p>深拷贝就是将一个对象拷贝到另一个对象中，这意味着如果你对一个对象的拷贝做出改变时，不会影响原对象。在Python中，我们使用函数deepcopy()执行深拷贝</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">copy</span></span><br><span class="line">b=<span class="built_in">copy</span>.deepcopy(a)</span><br></pre></td></tr></table></figure><p><img src="https://v3u.cn/book/img/deepcopy.jpg" alt="avatar"></p><p>而浅拷贝则是将一个对象的引用拷贝到另一个对象上，所以如果我们在拷贝中改动，会影响到原对象。我们使用函数function()执行浅拷贝</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b=<span class="keyword">copy</span>.<span class="keyword">copy</span>(a)</span><br></pre></td></tr></table></figure><p><img src="https://v3u.cn/book/img/copy.jpg" alt="img"></p><p>切片操作是浅拷贝</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深拷贝和浅拷贝之间的区别是什么？&quot;&gt;&lt;a href=&quot;#深拷贝和浅拷贝之间的区别是什么？&quot; class=&quot;headerlink&quot; title=&quot;深拷贝和浅拷贝之间的区别是什么？&quot;&gt;&lt;/a&gt;深拷贝和浅拷贝之间的区别是什么？&lt;/h1&gt;&lt;p&gt;对象的赋值就是简单的引用,a = [1,2,3], b=a, 在上述情况下,a和b是一样的,他们指向同一片内存,b不过是a的别名,是引用,我们可以使用b is a 去判断,返回True,表名他们地址相同内容也相同,也可以使用id()函数来查看.看两个列表地址是否相同.
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CentOS下yum Mongodb安装</title>
    <link href="https://luckyle.top/2019/12/21/Mongodb/"/>
    <id>https://luckyle.top/2019/12/21/Mongodb/</id>
    <published>2019-12-21T01:20:39.000Z</published>
    <updated>2019-12-25T08:27:48.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOS下yum-Mongodb安装？"><a href="#CentOS下yum-Mongodb安装？" class="headerlink" title="CentOS下yum Mongodb安装？"></a>CentOS下yum Mongodb安装？</h1><a id="more"></a><p>MongoDB的安装<br>CentOS 中使用yum安装：</p><p>touch /etc/yum.repos.d/mongodb-org-4.2.repo<br>vim /etc/yum.repos.d/mongodb-org-4.2.repo<br>添加如下内容：<br>[mongodb-org-4.2]<br>name=MongoDB Repository<br>baseurl=<a href="https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/" target="_blank" rel="noopener">https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/</a><br>gpgcheck=1<br>enabled=1<br>gpgkey=<a href="https://www.mongodb.org/static/pgp/server-4.2.asc" target="_blank" rel="noopener">https://www.mongodb.org/static/pgp/server-4.2.asc</a><br>使用yum安装：<br>yum install -y mongodb-org<br>启动时指定配置文件：</p><p>mongod -f /etc/mongo/mongod.conf</p><p>参考：</p><p><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/</a></p><p>MongoDB如何导入数据？<br>wget <a href="http://labfile.oss.aliyuncs.com/courses/1196/monkey_source_docs_json.dat" target="_blank" rel="noopener">http://labfile.oss.aliyuncs.com/courses/1196/monkey_source_docs_json.dat</a><br>mongoimport -d monkey -c source_docs monkey_source_docs_json.dat<br>MongoDB如何导出数据？<br>Mongodb中的mongoexport工具可以把一个collection导出成JSON格式或CSV格式的文件。可以通过参数指定导出的数据项，也可以根据指定的条件导出数据。<br>MongoDB如何备份数据？<br>mongodump -h dbhost -d dbname -o dbdirectory<br>-h：MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017<br>-d：需要备份的数据库实例，例如：test<br>-o：备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。<br>MongoDB如何恢复数据<br>mongorestore -h <hostname>&lt;:port&gt; -d dbname <path><br>–host &lt;:port&gt;, -h &lt;:port&gt;：<br>MongoDB所在服务器地址，默认为： localhost:27017<br>–db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2<br>–drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！<br><path>：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。你不能同时指定 <path> 和 –dir 选项，–dir也可以设置备份目录。<br>–dir：指定备份的目录,你不能同时指定 <path> 和 –dir 选项。<br>结巴分词<br>参考资料：</p><p><a href="https://www.cnblogs.com/clsn/p/8244206.html#auto_id_9" target="_blank" rel="noopener">https://www.cnblogs.com/clsn/p/8244206.html#auto_id_9</a></p><p><a href="https://motor.readthedocs.io/en/stable/tutorial-asyncio.html" target="_blank" rel="noopener">https://motor.readthedocs.io/en/stable/tutorial-asyncio.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CentOS下yum-Mongodb安装？&quot;&gt;&lt;a href=&quot;#CentOS下yum-Mongodb安装？&quot; class=&quot;headerlink&quot; title=&quot;CentOS下yum Mongodb安装？&quot;&gt;&lt;/a&gt;CentOS下yum Mongodb安装？&lt;/h1&gt;
    
    </summary>
    
    
      <category term="Mongodb" scheme="https://luckyle.top/categories/Mongodb/"/>
    
    
      <category term="Mongdb" scheme="https://luckyle.top/tags/Mongdb/"/>
    
  </entry>
  
  <entry>
    <title>随机验证码</title>
    <link href="https://luckyle.top/2019/12/20/%E9%9A%8F%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>https://luckyle.top/2019/12/20/%E9%9A%8F%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81/</id>
    <published>2019-12-20T11:24:52.000Z</published>
    <updated>2019-12-25T08:24:23.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="验证码的书写"><a href="#验证码的书写" class="headerlink" title="验证码的书写"></a>验证码的书写</h1><p>​    验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分<a href="https://baike.baidu.com/item/计算机" target="_blank" rel="noopener">计算机</a>和人类的<a href="https://baike.baidu.com/item/图灵测试" target="_blank" rel="noopener">图灵测试</a>）的缩写，是一种区分用户是计算机还是人的公共全自动<a href="https://baike.baidu.com/item/程序/71525" target="_blank" rel="noopener">程序</a>。可以防止：恶意破解密码、<a href="https://baike.baidu.com/item/刷票/6540942" target="_blank" rel="noopener">刷票</a>、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Django</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> make_password,check_password</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> web.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入图片库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导入绘画库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageDraw</span><br><span class="line"><span class="comment">#字体库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont</span><br><span class="line"><span class="comment">#随机库</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#图片库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="comment">#文件流</span></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取随机6位字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_str</span><span class="params">()</span>:</span></span><br><span class="line">    a_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>)])  <span class="comment">#小写字母</span></span><br><span class="line">    A_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>)])   <span class="comment">#大写字母</span></span><br><span class="line">    num_=[str(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>)]   <span class="comment">#数字 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(a_+A_+num_,<span class="number">4</span>))  <span class="comment">#返回随机4位字符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义验证码类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mycode</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment">#定义随机取色方法,混淆</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_random_color</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#三原色</span></span><br><span class="line">        R=random.randrange(<span class="number">255</span>)</span><br><span class="line">        G=random.randrange(<span class="number">255</span>)</span><br><span class="line">        B=random.randrange(<span class="number">255</span>)</span><br><span class="line">        <span class="keyword">return</span> (R,G,B)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#定义画布</span></span><br><span class="line">        image_size=(<span class="number">120</span>,<span class="number">60</span>)</span><br><span class="line">        <span class="comment">#定义图像 颜色种类  画布  背景颜色</span></span><br><span class="line">        image=Image.new(<span class="string">'RGB'</span>,image_size,<span class="string">'white'</span>)</span><br><span class="line">        <span class="comment">#定义画笔</span></span><br><span class="line">        draw=ImageDraw.Draw(image,<span class="string">'RGB'</span>)</span><br><span class="line">        <span class="comment">#随机字符串的组成</span></span><br><span class="line">        source=get_random_str()</span><br><span class="line">        <span class="comment">#定义一个容器，接收</span></span><br><span class="line">        code_str=<span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="comment">#取色</span></span><br><span class="line">            text_color=self.get_random_color()</span><br><span class="line">            <span class="comment">#获取一个字符串</span></span><br><span class="line">            tmp_num=random.randrange(len(source))</span><br><span class="line">            <span class="comment">#获取字符集</span></span><br><span class="line">            random_str=source[tmp_num]</span><br><span class="line">            <span class="comment">#将随机生成的字符串放入定义好的容器</span></span><br><span class="line">            code_str+=random_str</span><br><span class="line">            <span class="comment">#将文字输入绘图</span></span><br><span class="line">            <span class="comment">#宽高，字符，颜色</span></span><br><span class="line">            draw.text((<span class="number">10</span>+<span class="number">30</span>*i,<span class="number">20</span>),random_str,text_color)</span><br><span class="line">        <span class="comment">#建立io文件流</span></span><br><span class="line">        buf=io.BytesIO()</span><br><span class="line">        <span class="comment">#将图片内容保存在内存中</span></span><br><span class="line">        image.save(buf,<span class="string">'png'</span>)</span><br><span class="line">        <span class="comment">#将验证码放入session</span></span><br><span class="line">        request.session[<span class="string">'code'</span>]=code_str</span><br><span class="line">        <span class="comment">#可以存入redis中   建立连接   存key  取key</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(buf.getvalue(),<span class="string">'image/png'</span>)   <span class="comment">#从内存中获取数据</span></span><br></pre></td></tr></table></figure><h4 id="点击图片且刷新"><a href="#点击图片且刷新" class="headerlink" title="点击图片且刷新"></a>点击图片且刷新</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">&lt;image <span class="string">":src=src"</span> <span class="meta">@click</span>=<span class="string">'changecode'</span>&gt;</span><br><span class="line">src=<span class="string">'http://127.0.0.1:8000/api/mycode/'</span></span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line"><span class="comment">//点击刷新验证码</span></span><br><span class="line"><span class="comment">//每次给它传一个随机字符,只要传了参数，就不会缓存，直接刷新</span></span><br><span class="line"><span class="comment">//在js中随机生成字符</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">10</span>);</span><br><span class="line"><span class="keyword">this</span>.src=<span class="keyword">this</span>.src+<span class="string">'?code='</span>+num;</span><br><span class="line"></span><br><span class="line">changecode()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;验证码的书写&quot;&gt;&lt;a href=&quot;#验证码的书写&quot; class=&quot;headerlink&quot; title=&quot;验证码的书写&quot;&gt;&lt;/a&gt;验证码的书写&lt;/h1&gt;&lt;p&gt;​    验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分&lt;a href=&quot;https://baike.baidu.com/item/计算机&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计算机&lt;/a&gt;和人类的&lt;a href=&quot;https://baike.baidu.com/item/图灵测试&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图灵测试&lt;/a&gt;）的缩写，是一种区分用户是计算机还是人的公共全自动&lt;a href=&quot;https://baike.baidu.com/item/程序/71525&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;程序&lt;/a&gt;。可以防止：恶意破解密码、&lt;a href=&quot;https://baike.baidu.com/item/刷票/6540942&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;刷票&lt;/a&gt;、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>&#39;hexo快速搭建博客&#39;</title>
    <link href="https://luckyle.top/2019/12/20/hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://luckyle.top/2019/12/20/hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-12-20T08:23:28.000Z</published>
    <updated>2019-12-25T08:25:11.122Z</updated>
    
    <content type="html"><![CDATA[<p>使用Hexo建立一个轻量、简易、高逼格的博客</p><pre><code>在之前的一篇文章中，介绍了如何使用Hugo在三分钟之内建立一个简单的个人博客系统，它是基于go lang的，其实，市面上还有一款类似的静态页生成器，就是Hexo 读音/hækso/ ，它是基于node.js的，和Hugo一样，Hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。</code></pre><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先安装Hexo，在此之前，请确保电脑里已经安装好新版的<span class="keyword">node</span>.<span class="title">js</span></span><br></pre></td></tr></table></figure><p>​    </p><p>npm install -g hexo-cli</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果感觉安装速度比较慢，可以为<span class="built_in">npm</span>指定国内的源</span><br></pre></td></tr></table></figure><p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装完成后，创建博客项目</span><br></pre></td></tr></table></figure><p>hexo init blog</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这样，就建立起了一个<span class="keyword">blog文件夹，进入到blog目录下 </span>cd <span class="keyword">blog，建立第一篇文章</span></span><br></pre></td></tr></table></figure><p>hexo new myfirst</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后运行hexo服务</span><br></pre></td></tr></table></figure><p>hexo server</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">就可以在本地访问你的博客网站了，默认端口号是<span class="number">4000</span></span><br><span class="line"></span><br><span class="line">那么如何将博客网站打包呢？直接运行打包命令，这样就能使用 Hexo 引擎将 Markdown 格式的文件解析成可以使用浏览器查看的 HTML 文件，HTML 文件存储在 blog/<span class="keyword">public</span> 目录下</span><br></pre></td></tr></table></figure><p>hexo generate</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下面我们可以配置一下hexo主题，Hexo 提供了默认主题 landscape，主题的位置在 blog -&gt;themes 文件夹下。主题根据自己喜好可以在网上找到<span class="symbol">:https</span><span class="symbol">://hexo</span>.io/themes/</span><br><span class="line"></span><br><span class="line">主题都放在blog/themes文件夹下面，这我们下载一个新的主题</span><br></pre></td></tr></table></figure><p>mkdir themes/next<br>git clone –branch v5.1.2 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后在修改 <span class="regexp">/blog/</span>config.yml 文件，将其中的 theme 改成 <span class="keyword">next</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果没有自己的域名和服务器怎么办？没关系，可以申请 <span class="selector-tag">Github</span> 免费静态内容空间，在<span class="selector-tag">github</span><span class="selector-class">.com</span>注册一个账号，然后创建一个新的仓库</span><br></pre></td></tr></table></figure><p>​    </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">仓库名称一定要定义成 账号名<span class="selector-class">.github</span><span class="selector-class">.io</span>，这种形式，注意账号名一定要和你的<span class="selector-tag">github</span>当前登录的账号吻合</span><br></pre></td></tr></table></figure><p>​      </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这样你的静态内容空间就已经创建好了，在浏览器输入你的 <span class="string">https:</span><span class="comment">//你的账号.github.io/ 就可以访问了。</span></span><br><span class="line"></span><br><span class="line">将之前打包好的<span class="keyword">public</span>中的文件push到刚刚创建好的github仓库中去</span><br><span class="line"></span><br><span class="line">访问静态空间网址<span class="string">https:</span><span class="comment">//仓库名.github.io</span></span><br></pre></td></tr></table></figure><p>​    </p><p>没有问题，搞定收工</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Hexo建立一个轻量、简易、高逼格的博客&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在之前的一篇文章中，介绍了如何使用Hugo在三分钟之内建立一个简单的个人博客系统，它是基于go lang的，其实，市面上还有一款类似的静态页生成器，就是Hexo 读音/hækso/ ，它是基于nod
      
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>send_verify</title>
    <link href="https://luckyle.top/2019/12/20/send-verify/"/>
    <id>https://luckyle.top/2019/12/20/send-verify/</id>
    <published>2019-12-20T00:49:11.000Z</published>
    <updated>2019-12-25T08:25:56.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django-vue-验证码发送"><a href="#Django-vue-验证码发送" class="headerlink" title="Django +vue 验证码发送"></a>Django +vue 验证码发送</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> web.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL   <span class="comment">#settings里的一些配置</span></span><br><span class="line"><span class="keyword">import</span> random </span><br><span class="line"></span><br><span class="line"><span class="comment">#settings配置具体如下:</span></span><br><span class="line">EMAIL_USE_SSL = <span class="literal">True</span> <span class="comment"># Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议</span></span><br><span class="line">    EMAIL_HOST = <span class="string">'smtp.qq.com'</span>  <span class="comment"># 邮件服务器地址</span></span><br><span class="line">    EMAIL_PORT = <span class="number">465</span> <span class="comment"># 邮件服务器端口</span></span><br><span class="line"> </span><br><span class="line">    EMAIL_HOST_USER = <span class="string">'1315532054@qq.com'</span> <span class="comment"># 登陆邮件服务器的账号</span></span><br><span class="line">    EMAIL_HOST_PASSWORD = <span class="string">'ownkpkdkumubhdjg'</span>  <span class="comment"># 登陆邮件服务器的密码</span></span><br><span class="line">    DEFAULT_FROM_EMAIL = EMAIL_HOST_USER <span class="comment"># 邮件的发送者</span></span><br></pre></td></tr></table></figure><!-- < !--more--> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取随机6位字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_str</span><span class="params">()</span>:</span></span><br><span class="line">    a_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">97</span>,<span class="number">123</span>)])</span><br><span class="line">    A_=list([chr(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">65</span>,<span class="number">91</span>)])</span><br><span class="line">    num_=[str(var) <span class="keyword">for</span> var <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(a_+A_+num_,<span class="number">6</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#邮件发送</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">send_verify</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">           1. 先检查 对应邮件是否再memcache里已经存在了验证码</span></span><br><span class="line"><span class="string">           2. 发现没有存在,那么需要生成6位随机字符</span></span><br><span class="line"><span class="string">           3. 存储入到memcache里,并设置60s的过期时间</span></span><br><span class="line"><span class="string">               email: 6str :60s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           遇到了同步发送邮件的问题,应该怎么办</span></span><br><span class="line"><span class="string">       '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        email=request.data[<span class="string">'email'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># email=request.POST.get('email')</span></span><br><span class="line">        <span class="comment"># 1. 先检查 对应邮件是否再memcache里已经存在了验证码</span></span><br><span class="line">        token=men.get(email)</span><br><span class="line">        <span class="comment">#2.如果没有存在，那么需要生成随机字符</span></span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'code'</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="string">'message'</span>:<span class="string">'该邮箱已存在验证码'</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#该邮箱没有，生成随机字符</span></span><br><span class="line">            token=get_random_str()  <span class="comment">#随机字符</span></span><br><span class="line">            subject=<span class="string">'实验楼。。。。。。。。。。。'</span></span><br><span class="line">            message=<span class="string">'你的验证码是:%s'</span>%token</span><br><span class="line">            men.set(email,token,<span class="number">100</span>)  <span class="comment">#存储到memcache</span></span><br><span class="line">            <span class="comment"># print(men.get(token))</span></span><br><span class="line">            send_mail(subject,message,DEFAULT_FROM_EMAIL,[email])</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;</span><br><span class="line">                <span class="string">'code'</span>:<span class="number">1</span>,</span><br><span class="line">                <span class="string">'message'</span>:<span class="string">'验证码已发送'</span></span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">send_verify()&#123;</span><br><span class="line">        <span class="keyword">if</span>(!this.email)&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        let form_data=new FormData()</span><br><span class="line">        form_data.append(<span class="string">'email'</span>,this.email)</span><br><span class="line"></span><br><span class="line">        axios(&#123;</span><br><span class="line">            url:<span class="string">'http://127.0.0.1:8000/api/send_verify/'</span>,</span><br><span class="line">            method:<span class="string">'post'</span>,</span><br><span class="line">            data:form_data</span><br><span class="line">        &#125;).then(res=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.data.code==<span class="number">1</span>)&#123;</span><br><span class="line">                alert(res.data.message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Django-vue-验证码发送&quot;&gt;&lt;a href=&quot;#Django-vue-验证码发送&quot; class=&quot;headerlink&quot; title=&quot;Django +vue 验证码发送&quot;&gt;&lt;/a&gt;Django +vue 验证码发送&lt;/h1&gt;&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://luckyle.top/2019/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://luckyle.top/2019/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2019-09-02T06:05:01.000Z</published>
    <updated>2019-12-25T08:24:10.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于数据结构"><a href="#关于数据结构" class="headerlink" title="关于数据结构"></a>关于数据结构</h1><h5 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h5><p>简单地说，数据结构是以某种特定的布局方式存储数据的容器。这种“布局方式”决定了数据结构对于某些操作是高效的，而对于其他操作则是低效的。首先我们需要理解各种数据结构，才能在处理实际问题时选取最合适的数据结构。<a id="more"></a></p><h5 id="为什么我们需要数据结构？"><a href="#为什么我们需要数据结构？" class="headerlink" title="为什么我们需要数据结构？"></a>为什么我们需要数据结构？</h5><p>数据是计算机科学当中最关键的实体，而数据结构则可以将数据以某种组织形式存储，因此，数据结构的价值不言而喻。</p><p>无论你以何种方式解决何种问题，你都需要处理数据——无论是涉及员工薪水、股票价格、购物清单，还是只是简单的电话簿问题。</p><p>数据需要根据不同的场景，按照特定的格式进行存储。有很多数据结构能够满足以不同格式存储数据的需求。</p><h5 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h5><p>首先列出一些最常见的数据结构，我们将逐一说明：</p><p>数组 栈 队列 链表 树 字典树（这是一种高效的树形结构，但值得单独说明） 散列表（哈希表）</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是最简单、也是使用最广泛的数据结构。栈、队列等其他数据结构均由数组演变而来。下图是一个包含元素（1，2，3和4）的简单数组，数组长度为4。</p><p>每个数据元素都关联一个正数值，我们称之为索引，它表明数组中每个元素所在的位置。大部分语言将初始索引定义为零。</p><p>以下是数组的两种类型：</p><p>一维数组（如上所示） 多维数组（数组的数组）</p><p>数组的基本操作</p><p>Insert——在指定索引位置插入一个元素 Get——返回指定索引位置的元素 Delete——删除指定索引位置的元素 Size——得到数组所有元素的数量</p><p>面试中关于数组的常见问题</p><p>寻找数组中第二小的元素 找到数组中第一个不重复出现的整数 合并两个有序数组 重新排列数组中的正值和负值</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>著名的撤销操作几乎遍布任意一个应用。但你有没有思考过它是如何工作的呢？这个问题的解决思路是按照将最后的状态排列在先的顺序，在内存中存储历史工作状态（当然，它会受限于一定的数量）。这没办法用数组实现。但有了栈，这就变得非常方便了。</p><p>可以把栈想象成一列垂直堆放的书。为了拿到中间的书，你需要移除放置在这上面的所有书。这就是LIFO（后进先出）的工作原理。</p><p>下图是包含三个数据元素（1，2和3）的栈，其中顶部的3将被最先移除：</p><h5 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h5><p>Push——在顶部插入一个元素 Pop——返回并移除栈顶元素 isEmpty——如果栈为空，则返回true Top——返回顶部元素，但并不移除它</p><h5 id="面试中关于栈的常见问题"><a href="#面试中关于栈的常见问题" class="headerlink" title="面试中关于栈的常见问题"></a>面试中关于栈的常见问题</h5><p>使用栈计算后缀表达式 对栈的元素进行排序 判断表达式是否括号平衡</p><p>应用场景：逆序输出，语法检查，进制转换</p><p>在我们日常编程中，括号都是成对出现的，比如“()”“[]”“{}”“&lt;&gt;”这些成对出现的符号</p><p>那么具体处理的方法就是:凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错</p><p>将十进制的数转换为2-9的任意进制的数</p><p>我们都知道，通过求余法，可以将十进制数转换为其他进制，比如要转为八进制，将十进制数除以8，记录余数，然后继续将商除以8，一直到商等于0为止，最后将余数倒着写数来就可以了。</p><p>比如100的八进制，100首先除以8商12余4,4首先进栈，然后12除以8商1余4，第二个余数4进栈，接着1除以8，商0余1，第三个余数1进栈，最后将三个余数出栈，就得到了100的八进制数144,</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>与栈相似，队列是另一种顺序存储元素的线性数据结构。栈与队列的最大差别在于栈是LIFO（后进先出），而队列是FIFO，即先进先出。</p><p>一个完美的队列现实例子：售票亭排队队伍。如果有新人加入，他需要到队尾去排队，而非队首——排在前面的人会先拿到票，然后离开队伍。</p><p>下图是包含四个元素（1，2，3和4）的队列，其中在顶部的1将被最先移除：</p><p>移除先入队的元素、插入新元素</p><h5 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h5><p>Enqueue()——在队列尾部插入元素 Dequeue()——移除队列头部的元素 isEmpty()——如果队列为空，则返回true Top()——返回队列的第一个元素</p><p>面试中关于队列的常见问题</p><p>使用队列表示栈 对队列的前k个元素倒序 使用队列生成从1到n的二进制数</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是另一个重要的线性数据结构，乍一看可能有点像数组，但在内存分配、内部结构以及数据插入和删除的基本操作方面均有所不同。</p><p>链表就像一个节点链，其中每个节点包含着数据和指向后续节点的指针。 链表还包含一个头指针，它指向链表的第一个元素，但当列表为空时，它指向null或无具体内容。</p><p>链表一般用于实现文件系统、哈希表和邻接表。</p><p>这是链表内部结构的展示：</p><p>链表包括以下类型：</p><p>单链表（单向） 双向链表（双向）</p><h5 id="链表的基本操作："><a href="#链表的基本操作：" class="headerlink" title="链表的基本操作："></a>链表的基本操作：</h5><p>InsertAtEnd - 在链表的末尾插入指定元素 InsertAtHead - 在链接列表的开头/头部插入指定元素 Delete - 从链接列表中删除指定元素 DeleteAtHead - 删除链接列表的第一个元素 Search - 从链表中返回指定元素 isEmpty - 如果链表为空，则返回true</p><p>面试中关于链表的常见问题</p><p>反转链表 检测链表中的循环 返回链表倒数第N个节点 删除链表中的重复项</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树形结构是一种层级式的数据结构，由顶点（节点）和连接它们的边组成。 树类似于图，但区分树和图的重要特征是树中不存在环路。</p><p>树形结构被广泛应用于人工智能和复杂算法，它可以提供解决问题的有效存储机制。</p><p>这是一个简单树的示意图，以及树数据结构中使用的基本术语：</p><p>Root - 根节点</p><p>Parent - 父节点</p><p>Child - 子节点</p><p>Leaf - 叶子节点</p><p>Sibling - 兄弟节点</p><p>以下是树形结构的主要类型：</p><p>N元树 平衡树 二叉树 二叉搜索树 AVL树 红黑树 2-3树</p><p>其中，二叉树和二叉搜索树是最常用的树。</p><h5 id="面试中关于树结构的常见问题："><a href="#面试中关于树结构的常见问题：" class="headerlink" title="面试中关于树结构的常见问题："></a>面试中关于树结构的常见问题：</h5><p>求二叉树的高度 在二叉搜索树中查找第k个最大值 查找与根节点距离k的节点 在二叉树中查找给定节点的祖先节点</p><p>字典树（Trie）</p><p>字典树，也称为“前缀树”，是一种特殊的树状数据结构，对于解决字符串相关问题非常有效。它能够提供快速检索，主要用于搜索字典中的单词，在搜索引擎中自动提供建议，甚至被用于IP的路由。</p><p>这些单词以顶部到底部的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“theirs”的底部。</p><p>面试中关于字典树的常见问题</p><p>计算字典树中的总单词数 打印存储在字典树中的所有单词 使用字典树对数组的元素进行排序 使用字典树从字典中形成单词 构建T9字典（字典树+ DFS ）</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希法（Hashing）是一个用于唯一标识对象并将每个对象存储在一些预先计算的唯一索引（称为“键（key）”）中的过程。因此，对象以键值对的形式存储，这些键值对的集合被称为“字典”。可以使用键搜索每个对象。基于哈希法有很多不同的数据结构，但最常用的数据结构是哈希表。</p><p>哈希表通常使用数组实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于数据结构&quot;&gt;&lt;a href=&quot;#关于数据结构&quot; class=&quot;headerlink&quot; title=&quot;关于数据结构&quot;&gt;&lt;/a&gt;关于数据结构&lt;/h1&gt;&lt;h5 id=&quot;什么是数据结构？&quot;&gt;&lt;a href=&quot;#什么是数据结构？&quot; class=&quot;headerlink&quot; title=&quot;什么是数据结构？&quot;&gt;&lt;/a&gt;什么是数据结构？&lt;/h5&gt;&lt;p&gt;简单地说，数据结构是以某种特定的布局方式存储数据的容器。这种“布局方式”决定了数据结构对于某些操作是高效的，而对于其他操作则是低效的。首先我们需要理解各种数据结构，才能在处理实际问题时选取最合适的数据结构。
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python基础</title>
    <link href="https://luckyle.top/2019/08/11/python%E5%9F%BA%E7%A1%80/"/>
    <id>https://luckyle.top/2019/08/11/python%E5%9F%BA%E7%A1%80/</id>
    <published>2019-08-11T02:18:24.000Z</published>
    <updated>2019-12-25T08:25:35.572Z</updated>
    
    <content type="html"><![CDATA[<h5 id="解释一下Python中的三元运算"><a href="#解释一下Python中的三元运算" class="headerlink" title="解释一下Python中的三元运算"></a>解释一下Python中的三元运算</h5><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">on</span> <span class="literal">true</span>] <span class="keyword">if</span> [expression] <span class="keyword">else</span> [<span class="keyword">on</span> <span class="literal">false</span>]</span><br></pre></td></tr></table></figure><p>如果表达式为True，就执行[on true]中的语句。否则，就执行[on false]中的语句</p><p>a,b=2,3</p><p>min=a if a&lt;b else b</p><p>min</p><h5 id="GIl全局解释器锁"><a href="#GIl全局解释器锁" class="headerlink" title="GIl全局解释器锁"></a>GIl全局解释器锁</h5><p>GIL: 全局解释器锁（英语：Global Interpreter Lock，缩写GIL），是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。[1]即便在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程。<a id="more"></a></p><p>解释一下Python中的继承</p><p>当一个类继承自另一个类，它就被称为一个子类/派生类，继承自父类/基类/超类。它会继承/获取所有类成员（属性和方法）。</p><p>继承能让我们重新使用代码，也能更容易的创建和维护应用。Python支持如下种类的继承：</p><h5 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h5><p>一个类继承自单个基类 多继承：一个类继承自多个基类 多级继承：一个类继承自单个基类，后者则继承自另一个基类 分层继承：多个类继承自单个基类 混合继承：两种或多种类型继承的混合</p><h5 id="解释Python中的help-和dir-函数"><a href="#解释Python中的help-和dir-函数" class="headerlink" title="解释Python中的help()和dir()函数"></a>解释Python中的help()和dir()函数</h5><p>Help()函数是一个内置函数，用于查看函数或模块用途的详细说明：</p><p>import copy</p><p>help(copy.copy)</p><p>Dir()函数也是Python内置函数，dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。</p><p>dir(copy.copy)</p><h5 id="什么是猴子补丁？"><a href="#什么是猴子补丁？" class="headerlink" title="什么是猴子补丁？"></a>什么是猴子补丁？</h5><p>在运行期间动态修改一个类或模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line"></span><br><span class="line">   def func(self):</span><br><span class="line"></span><br><span class="line">     print(&quot;Hi&quot;)</span><br><span class="line"></span><br><span class="line">def monkey(self):</span><br><span class="line"></span><br><span class="line">    print(&quot;Hi, monkey&quot;)</span><br><span class="line"></span><br><span class="line">m.A.func = monkey</span><br><span class="line"></span><br><span class="line">a = m.A()</span><br><span class="line"></span><br><span class="line">a.func()</span><br></pre></td></tr></table></figure><h5 id="请解释使用args和-kwargs的含义"><a href="#请解释使用args和-kwargs的含义" class="headerlink" title="请解释使用args和*kwargs的含义"></a>请解释使用args和*kwargs的含义</h5><p>当我们不知道向函数传递多少参数时，比如我们向传递一个列表或元组，我们就使用*args。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def func<span class="comment">(*args):</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    for i in args:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        print(i)  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">func(3,2,1,4,7)</span></span><br></pre></td></tr></table></figure><p>在我们不知道该传递多少关键字参数时，使用**kwargs来收集关键字参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def func(**kwargs):</span><br><span class="line"></span><br><span class="line">    for i in kwargs:</span><br><span class="line"></span><br><span class="line">        print(i,kwargs[i])</span><br><span class="line"> func(a=1,b=2,c=7)</span><br></pre></td></tr></table></figure><h5 id="什么是负索引？"><a href="#什么是负索引？" class="headerlink" title="什么是负索引？"></a>什么是负索引？</h5><p>负索引和正索引不同，它是从右边开始检索。</p><p>它也能用于列表中的切片：</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mylist=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">mylist[-<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">mylist[-<span class="number">6</span>:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h5 id="解释Python中的join-和split-函数"><a href="#解释Python中的join-和split-函数" class="headerlink" title="解释Python中的join()和split()函数"></a>解释Python中的join()和split()函数</h5><p>Join()能让我们将指定字符添加至字符串中。</p><p>Split()能让我们用指定字符分割字符串。</p><h5 id="怎么移除一个字符串中的前导空格？"><a href="#怎么移除一个字符串中的前导空格？" class="headerlink" title="怎么移除一个字符串中的前导空格？"></a>怎么移除一个字符串中的前导空格？</h5><p>字符串中的前导空格就是出现在字符串中第一个非空格字符前的空格。我们使用方法Istrip()可以将它从字符串中移除。</p><p>‘   Ayushi ‘.lstrip()</p><p>可以看到，该字符串既有前导字符，也有后缀字符，调用Istrip()去除了前导空格。如果我们想去除后缀空格，就用rstrip()方法。</p><p>‘   Ayushi ‘.rstrip()</p><h5 id="Python中的pass语句是什么？"><a href="#Python中的pass语句是什么？" class="headerlink" title="Python中的pass语句是什么？"></a>Python中的pass语句是什么？</h5><p>在用Python写代码时，有时可能还没想好函数怎么写，只写了函数声明，但为了保证语法正确，必须输入一些东西，在这种情况下，我们会使用pass语句。</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def func<span class="comment">(*args):</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pass</span></span><br></pre></td></tr></table></figure><p>同样，break语句能让我们跳出循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(7):</span><br><span class="line"></span><br><span class="line">    if i==3: </span><br><span class="line">break</span><br></pre></td></tr></table></figure><p>最后，continue语句能让我们跳到下个循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(7):</span><br><span class="line"></span><br><span class="line">   if i==3: </span><br><span class="line">   continue</span><br></pre></td></tr></table></figure><h5 id="Python中的闭包是什么？"><a href="#Python中的闭包是什么？" class="headerlink" title="Python中的闭包是什么？"></a>Python中的闭包是什么？</h5><p>当一个嵌套函数在其外部区域引用了一个值时，该嵌套函数就是一个闭包。其意义就是会记录这个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def A(x):</span><br><span class="line"></span><br><span class="line">    def B():</span><br><span class="line"></span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line">    return B</span><br></pre></td></tr></table></figure><h5 id="谈一谈Python的装饰器（decorator）"><a href="#谈一谈Python的装饰器（decorator）" class="headerlink" title="谈一谈Python的装饰器（decorator）"></a>谈一谈Python的装饰器（decorator）</h5><p>装饰器本质上是一个Python函数，它可以让其它函数在不作任何变动的情况下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景。比如：插入日志、性能测试、事务处理、缓存、权限校验等。有了装饰器我们就可以抽离出大量的与函数功能无关的雷同代码进行重用。</p><p>装饰器其实就是一个闭包，把一个函数当做参数然后返回一个替代版函数</p><h5 id="解释一下Python中的逻辑运算符"><a href="#解释一下Python中的逻辑运算符" class="headerlink" title="解释一下Python中的逻辑运算符"></a>解释一下Python中的逻辑运算符</h5><p>Python中有3个逻辑运算符：and，or，not</p><h5 id="Python支持什么数据类型？"><a href="#Python支持什么数据类型？" class="headerlink" title="Python支持什么数据类型？"></a>Python支持什么数据类型？</h5><p>Numbers（数字）——用于保存数值</p><p>Strings（字符串）——字符串是一个字符序列。我们用单引号或双引号来声明字符串。</p><p>Lists（列表）——列表就是一些值的有序集合，我们用方括号声明列表。</p><p>Tuples（元组）——元组和列表一样，也是一些值的有序集合，区别是元组是不可变的，意味着我们无法改变元组内的值。</p><p>Dictionary（字典）——字典是一种数据结构，含有键值对。我们用大括号声明字典</p><h5 id="什么是切片？"><a href="#什么是切片？" class="headerlink" title="什么是切片？"></a>什么是切片？</h5><p>切片是Python中的一种方法，能让我们只检索列表、元素或字符串的一部分。在切片时，我们使用切片操作符[]。</p><p>(1,2,3,4,5)[2:4]</p><p>Python中的不可变集合（frozenset）是什么？</p><p>首先，我们讨论一下什么是集合。集合就是一系列数据项的合集，不存在任何副本。另外，集合是无序的。</p><p>这就意味着我们无法索引它。</p><p>不过，集合是可变的。而不可变集合却不可变，这意味着我们无法改变它的值，从而也使其无法作为字典的键值。</p><p>myset=frozenset([1,3,2,2])</p><p>myset</p><h5 id="解释lambda表达式，什么时候会用到它？"><a href="#解释lambda表达式，什么时候会用到它？" class="headerlink" title="解释lambda表达式，什么时候会用到它？"></a>解释lambda表达式，什么时候会用到它？</h5><p>如果我们需要一个只有单一表达式的函数，我们可以匿名定义它。拉姆达表达式通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。</p><p>(lambda a,b:a if a&gt;b else b)(3,3.5)</p><h5 id="实现斐波那契数列"><a href="#实现斐波那契数列" class="headerlink" title="实现斐波那契数列"></a>实现斐波那契数列</h5><p>fib = lambda n : n if n &lt;= 2 else fib(n-1)+fib(n-2)</p><h5 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h5><p>在调用一个函数的过程中，直接或间接地调用了函数本身这个就叫递归。但为了避免出现死循环，必须要有一个结束条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def facto(n):</span><br><span class="line"></span><br><span class="line">    if n==1: </span><br><span class="line">    return 1</span><br><span class="line"></span><br><span class="line">    return n*facto(n-1)</span><br><span class="line"></span><br><span class="line">facto(4)</span><br></pre></td></tr></table></figure><h5 id="什么是生成器？"><a href="#什么是生成器？" class="headerlink" title="什么是生成器？"></a>什么是生成器？</h5><p>生成器会生成一系列的值用于迭代，这样看它又是一种可迭代对象。它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。</p><h5 id="什么是迭代器？"><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h5><p>迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。我们使用inter()函数创建迭代器。</p><h5 id="请说说生成器和迭代器之间的区别"><a href="#请说说生成器和迭代器之间的区别" class="headerlink" title="请说说生成器和迭代器之间的区别?"></a>请说说生成器和迭代器之间的区别?</h5><p>在使用生成器时，我们创建一个函数；在使用迭代器时，我们使用内置函数iter()和next()。 在生成器中，我们使用关键字‘yield’来每次生成/返回一个对象。 生成器中有多少‘yield’语句，你可以自定义。 每次‘yield’暂停循环时，生成器会保存本地变量的状态。而迭代器并不会使用局部变量，它只需要一个可迭代对象进行迭代。 使用类可以实现你自己的迭代器，但无法实现生成器。 生成器运行速度快，语法简洁，更简单。 迭代器更能节约内存。</p><h5 id="Python中的yield用法"><a href="#Python中的yield用法" class="headerlink" title="Python中的yield用法"></a>Python中的yield用法</h5><p>yield简单说来就是一个生成器，这样函数它记住上次返 回时在函数体中的位置。对生成器第 二次(或n 次)调用跳转至该函 次)调用跳转至该函数。</p><h5 id="解释Python的参数传递机制"><a href="#解释Python的参数传递机制" class="headerlink" title="解释Python的参数传递机制"></a>解释Python的参数传递机制</h5><p>Python使用按引用传递（pass-by-reference）将参数传递到函数中。如果你改变一个函数内的参数，会影响到函数的调用。这是Python的默认操作。不过，如果我们传递字面参数，比如字符串、数字或元组，它们是按值传递，这是因为它们是不可变的。</p><p>python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值’来传递对象。</p><h5 id="如何在Python中创建自己的包？"><a href="#如何在Python中创建自己的包？" class="headerlink" title="如何在Python中创建自己的包？"></a>如何在Python中创建自己的包？</h5><p>Python中创建包是比较方便的，只需要在当前目录建立一个文件夹，文件夹中包含一个init.py文件和若干个模块文件，其中init.py可以是一个空文件，但还是建议将包中所有需要导出的变量放到all中，这样可以确保包的接口清晰明了，易于使用。</p><h5 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h5><p>元类是类的类对象，换言之类是元类的实例，Python中默认的元类为type，可以通过自定义元类的方式实现对类创建的控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;解释一下Python中的三元运算&quot;&gt;&lt;a href=&quot;#解释一下Python中的三元运算&quot; class=&quot;headerlink&quot; title=&quot;解释一下Python中的三元运算&quot;&gt;&lt;/a&gt;解释一下Python中的三元运算&lt;/h5&gt;&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;] &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; [expression] &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;p&gt;如果表达式为True，就执行[on true]中的语句。否则，就执行[on false]中的语句&lt;/p&gt;
&lt;p&gt;a,b=2,3&lt;/p&gt;
&lt;p&gt;min=a if a&amp;lt;b else b&lt;/p&gt;
&lt;p&gt;min&lt;/p&gt;
&lt;h5 id=&quot;GIl全局解释器锁&quot;&gt;&lt;a href=&quot;#GIl全局解释器锁&quot; class=&quot;headerlink&quot; title=&quot;GIl全局解释器锁&quot;&gt;&lt;/a&gt;GIl全局解释器锁&lt;/h5&gt;&lt;p&gt;GIL: 全局解释器锁（英语：Global Interpreter Lock，缩写GIL），是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。[1]即便在多核心处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程。
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Mysql事务</title>
    <link href="https://luckyle.top/2019/06/09/Mysql%E4%BA%8B%E5%8A%A1/"/>
    <id>https://luckyle.top/2019/06/09/Mysql%E4%BA%8B%E5%8A%A1/</id>
    <published>2019-06-09T07:26:52.000Z</published>
    <updated>2019-12-25T08:25:28.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h1><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！<a id="more"></a></p><ul><li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li><li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li><li>事务用来管理 insert,update,delete 语句</li></ul><p>一般来说，事务是必须满足4个条件（ACID）：：原子性（<strong>A</strong>tomicity，或称不可分割性）、一致性（<strong>C</strong>onsistency）、隔离性（<strong>I</strong>solation，又称独立性）、持久性（<strong>D</strong>urability）。</p><ul><li><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><hr><p>‘- 显示数据库：show databases;</p><h5 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h5><p>​    sql server（微软）windows 专有数据<br>​    mysql    默认端口:3306<br>​    oracle（重点）甲骨文<br>​    access<br>​    sqlite<br>​    ibm db2<br>​    关系型数据库管理系统</p><p>-查看 mysql 版本： select version();<br>primary key 主键   auto_increment 自动递增   not null ,要求该约束所修饰的字段，不能为null或空    unsigned 约束的字段，会去掉负值，添加到正值，范围 x 2 + 1</p><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>命令格式：select * from 表名 order by 字段名 asc(升序)|desc（降序）;<br>多字段排序<br>select * from department order by groups desc,kpi desc;<br>多字段排序时，先按第一字段排序，第一段相同的，再按第二字段排序。</p><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><ul><li>创建数据库命令格式： <code>create database 数据库名字 charset=字符集</code></li><li>创建表命令格式: <code>create table 表名( 字段 属性 );</code></li></ul><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul><li>删除表<br>命令格式：drop table 表名;</li><li>删库<br>格式: <code>drop database 库名;</code><br>删除主键<br>alter table 表名 drop 主键字段名;<br>删除数据<br>命令格式<br>delete from 表名 where 【条件】</li></ul><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>-修改已创建的表名<br>命令格式：alter table 原表名 rename to  新表名;</p><p>旧改法：<br>      alter user ‘root’@’localhost’ identified by ‘mysql’;</p><p>-10.1.38-MariaDB 修改密码：<br>    update mysql.user set Password = password(‘1999’) where             user=’(root）’;<br>    flush privileges;<br>    exit;</p><p>远程链接:<br>    GRANT ALL PRIVILEGES ON * .* TO ‘root’@’%’ IDENTIFIED BY ‘root’ WITH GRANT OPTION;</p><p>mysql 配置文件：<br>     windows -&gt; mysql/bin/my.ini<br>     linux -&gt; mysq/my.cnf</p><h5 id="修改创建好的表字"><a href="#修改创建好的表字" class="headerlink" title="修改创建好的表字"></a>修改创建好的表字</h5><p>段命令格式: alter table 表名 change 原字段名 新字段名 字段类型 字段属性（约束）;<br>添加新的字段<br>命令格式: alter table 表名 add 字段名 字段类型 字段属性（约束）;<br>修改表名<br>命令格式：alter table 旧表名 rename to 新表名;<br>创建表后修改主键<br>alter table 表名 change 原字段名（要设为主键的字段） 新字段名 int primary key auto_incremnt not null;<br>修改数据<br>update 表名 set 字段名1=要修改值1,字段名2=要修改值2 where [条件]</p><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>基本查询<br>命令格式：select [要查询的字段，如果是所有字段，就是*;如果单个，写字段名] from 【表名】 where 【条件】<br>范围查询<br>命令格式： select [字段] from 表名 where 字段名 between 开始 and 结束<br>in ( ) 在 … 里 not in<br>模糊查询<br>命令格式： select [字段] from 表名 where 字段 like …%…<br>内联接查询<br>命令格式:select [字段] from 表名1 inner join 表名2 on 表名1.连接字段=表名2.连接字段<br>右链接<br>select * from student s right join class c on s.cls_id=c.id<br>左连接<br>select *  from class c left join student s on s.cls_id=c.id;<br>全联接<br> select * from class c left join student s on c.id=s.cls_id<br> union<br> select * from class c right join student s on c.id=s.cls_id;<br>自联接（自查询)<br>表和自身的连接，使用 inner join 来完成</p><h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><p>命令格式:<br>insert into 表名（字段名1,字段名2,字段名3…..）values(值1,值2,值3…);<br>另外一种形式<br>insert into 表名 values(字段1的值，字段2的值，字段3的值。。。。);</p><p>-分组<br>group by 分组<br>分组  group_concat()+group by </p><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="-聚合函数"></a>-聚合函数</h5><p>统计函数 count（）<br>命令格式： select count(要统计的字段) from 表名 where [条件]<br>求最大值<br>命令格式：select max(求最大值的字段) from 表名;<br>求最小值<br>命令格式：select min(要计算最小值的字段) from 表名;<br>求和<br>命令格式:<br>select sum(要求和/总数的字段) from 表名;<br>求平均值<br>select avg(要求平均值字段) from 表名;</p><p>having<br>having 和 where 都 可以对记录进行筛选；但是having跟在group by 后面，group by 跟在 where 后面；having 后面条件必须在 select 字段中出现，没有，就会报错；where 是必须是表中字段<br>where … group by … having</p><h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p>命令格式：<br>create view 视图名字 as select语句;<br>查看视图<br>命令格式：show tables;<br>删除视图<br>drop view 视图名字<br>修改视图<br>create or replace view 视图名字 as select语句;</p><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>查看索引<br>命令格式：<br>show index from 表名；<br>创建索引的命令<br>格式：<br>create index idx_索引名  on 表名（字段名（索引长度））<br>删除索引<br>命令格式:<br>drop index 索引名称 on 表名;</p><h5 id="三范式："><a href="#三范式：" class="headerlink" title="三范式："></a>三范式：</h5><p>1：确保每列保持原子性<br>2：确保表中每列都和主键直接相关<br>3：确保每列都和主键列直接相关，而不是间接相关</p><h5 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h5><p>​    是一个操作序列，这些操作要么都执行，要么都不执行，它是一个完整的，不可分割的工作单位。<br>事务具有的特性：原子性 ，一致，隔离，持久<br>开启事务：start transaction   / begin<br>提交         commit</p><p>当前时间加1天<br>select date_add(now(),interyal 1day)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL-事务&quot;&gt;&lt;a href=&quot;#MySQL-事务&quot; class=&quot;headerlink&quot; title=&quot;MySQL 事务&quot;&gt;&lt;/a&gt;MySQL 事务&lt;/h1&gt;&lt;p&gt;MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！
    
    </summary>
    
    
      <category term="Mysql" scheme="https://luckyle.top/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://luckyle.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>八大排序</title>
    <link href="https://luckyle.top/2018/12/11/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
    <id>https://luckyle.top/2018/12/11/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</id>
    <published>2018-12-11T07:53:09.000Z</published>
    <updated>2019-12-25T08:24:01.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序；首先将第一个作为已经排好序的，然后每次从后的取出插入到前面并排序；<a id="more"></a></p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def insert_sort(<span class="keyword">ilist</span>):</span><br><span class="line">    <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="keyword">ilist</span>)):</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">ilist</span>[i] &lt; <span class="keyword">ilist</span>[<span class="keyword">j</span>]:</span><br><span class="line">                <span class="keyword">ilist</span>.<span class="keyword">insert</span>(<span class="keyword">j</span>, <span class="keyword">ilist</span>.<span class="keyword">pop</span>(i))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">ilist</span></span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def <span class="keyword">bubble_sort(blist):</span></span><br><span class="line"><span class="keyword"> </span>   <span class="built_in">count</span> = len(<span class="keyword">blist)</span></span><br><span class="line"><span class="keyword"> </span>   for i in range(<span class="number">0</span>, <span class="built_in">count</span>):</span><br><span class="line">        for <span class="keyword">j </span>in range(i + <span class="number">1</span>, <span class="built_in">count</span>):</span><br><span class="line">            if <span class="keyword">blist[i] </span>&gt; <span class="keyword">blist[j]:</span></span><br><span class="line"><span class="keyword"> </span>               <span class="keyword">blist[i], </span><span class="keyword">blist[j] </span>= <span class="keyword">blist[j], </span><span class="keyword">blist[i]</span></span><br><span class="line"><span class="keyword"> </span>   return <span class="keyword">blist</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">blist </span>= <span class="keyword">bubble_sort([4,5,6,7,3,2,6,9,8])</span></span><br><span class="line"><span class="keyword">print(blist)</span></span><br></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p><p>时间复杂度：O(nlog₂n)</p><p>空间复杂度：O(nlog₂n)</p><p>稳定性：不稳定</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def quick<span class="constructor">_sort(<span class="params">qlist</span>)</span>:</span><br><span class="line">    <span class="keyword">if</span> qlist<span class="operator"> == </span><span class="literal">[]</span>:</span><br><span class="line">        return <span class="literal">[]</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        qfirst = qlist<span class="literal">[<span class="number">0</span>]</span></span><br><span class="line">        qless = quick<span class="constructor">_sort([<span class="params">l</span> <span class="params">for</span> <span class="params">l</span> <span class="params">in</span> <span class="params">qlist</span>[1:] <span class="params">if</span> <span class="params">l</span> &lt; <span class="params">qfirst</span>])</span></span><br><span class="line">        qmore = quick<span class="constructor">_sort([<span class="params">m</span> <span class="params">for</span> <span class="params">m</span> <span class="params">in</span> <span class="params">qlist</span>[1:] <span class="params">if</span> <span class="params">m</span> &gt;= <span class="params">qfirst</span>])</span></span><br><span class="line">        return qless + <span class="literal">[<span class="identifier">qfirst</span>]</span> + qmore</span><br><span class="line"></span><br><span class="line">qlist = quick<span class="constructor">_sort([4,5,6,7,3,2,6,9,8])</span></span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(1)</p><p>稳定性：不稳定</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def select_sort(slist):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(slist)):</span><br><span class="line">        x = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(slist)):</span><br><span class="line">            <span class="keyword">if</span> slist[j] &lt; slist[x]:</span><br><span class="line">                x = j</span><br><span class="line">        slist[i], slist[x] = slist[x], slist[i]</span><br><span class="line">    <span class="keyword">return</span> slist</span><br><span class="line"></span><br><span class="line">slist = select_sort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序：采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并</p><p>时间复杂度：O(nlog₂n)</p><p>空间复杂度：O(1)</p><p>稳定性：稳定</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def merge_sort(array):</span><br><span class="line">    def merge_arr(arr_l, arr_r):</span><br><span class="line">       <span class="built_in"> array </span>= []</span><br><span class="line">        while len(arr_l)<span class="built_in"> and </span>len(arr_r):</span><br><span class="line">           <span class="built_in"> if </span>arr_l[0] &lt;= arr_r[0]:</span><br><span class="line">                array.append(arr_l.pop(0))</span><br><span class="line">            elif arr_l[0] &gt; arr_r[0]:</span><br><span class="line">                array.append(arr_r.pop(0))</span><br><span class="line">       <span class="built_in"> if </span>len(arr_l) != 0:</span><br><span class="line">           <span class="built_in"> array </span>+= arr_l</span><br><span class="line">        elif len(arr_r) != 0:</span><br><span class="line">           <span class="built_in"> array </span>+= arr_r</span><br><span class="line">       <span class="built_in"> return </span>array</span><br><span class="line"></span><br><span class="line">    def recursive(array):</span><br><span class="line">       <span class="built_in"> if </span>len(array) == 1:</span><br><span class="line">           <span class="built_in"> return </span>array</span><br><span class="line">        mid = len(array) // 2</span><br><span class="line">        arr_l = recursive(array[:mid])</span><br><span class="line">        arr_r = recursive(array[mid:])</span><br><span class="line">       <span class="built_in"> return </span>merge_arr(arr_l, arr_r)</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> return </span>recursive(array)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;p&gt;插入排序：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序；首先将第一个作为已经排好序的，然后每次从后的取出插入到前面并排序；
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Python" scheme="https://luckyle.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>虚拟环境</title>
    <link href="https://luckyle.top/2018/11/24/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>https://luckyle.top/2018/11/24/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</id>
    <published>2018-11-24T07:41:57.000Z</published>
    <updated>2019-12-25T08:21:45.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建爬虫系统"><a href="#构建爬虫系统" class="headerlink" title="构建爬虫系统"></a>构建爬虫系统</h1><h2 id="一、实现目的"><a href="#一、实现目的" class="headerlink" title="一、实现目的"></a>一、实现目的</h2><p>爬虫是文档的重要来源，所以这一节也比较重要，我会从爬虫的基础讲起，爬虫的构成如何编写爬虫等等，希望大家能跟着文档一步步动手做下去。<a id="more"></a></p><h4 id="1-1-实验知识点"><a href="#1-1-实验知识点" class="headerlink" title="1.1 实验知识点"></a>1.1 实验知识点</h4><ul><li>爬虫的基本概念</li><li>异步爬虫框架ruia的使用介绍</li><li>基于ruia构造异步爬虫系统</li></ul><h4 id="1-2-实验环境"><a href="#1-2-实验环境" class="headerlink" title="1.2 实验环境"></a>1.2 实验环境</h4><ul><li>Python 3.6+</li><li>MongoDB</li></ul><h2 id="二、开发准备"><a href="#二、开发准备" class="headerlink" title="二、开发准备"></a>二、开发准备</h2><h5 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建项目代码目录</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">-p ~/Code/monkey</span></span><br><span class="line"><span class="comment"># 进入项目根目录</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">~/Code/monkey</span></span><br><span class="line"><span class="comment"># 创建一个名叫env的虚拟环境(注：Python3自带pyenv)</span></span><br><span class="line"><span class="attr">python3</span> <span class="string">-m venv env  </span></span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line"><span class="attr">source</span> <span class="string">env/bin/activate</span></span><br><span class="line"><span class="comment"># 安装项目依赖的包</span></span><br><span class="line"><span class="attr">pip</span> <span class="string">install -r requirements.txt</span></span><br></pre></td></tr></table></figure><h2 id="三、小试牛刀"><a href="#三、小试牛刀" class="headerlink" title="三、小试牛刀"></a>三、小试牛刀</h2><h3 id="3-1-使用requests-lxml爬取网页"><a href="#3-1-使用requests-lxml爬取网页" class="headerlink" title="3.1 使用requests + lxml爬取网页"></a>3.1 使用requests + lxml爬取网页</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注：以下代码未经过运行测试，只是手写思路</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://movie.douban.com/subject/1292052/'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>:<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Safari/605.1.15"</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(url,headers=headers)</span><br><span class="line">tree = etree.HTML(r.text)</span><br><span class="line">el = tree.xpath(<span class="string">'//*[@id="content"]/h1/span[1]/text()'</span>)</span><br><span class="line">print(el)</span><br></pre></td></tr></table></figure><h3 id="3-2-使用ruia框架爬取网页"><a href="#3-2-使用ruia框架爬取网页" class="headerlink" title="3.2 使用ruia框架爬取网页"></a>3.2 使用ruia框架爬取网页</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ruia <span class="keyword">import</span> Item, TextField</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanItem</span><span class="params">(Item)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    定义爬虫的目标字段</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    title = TextField(css_select=<span class="string">'#content &gt; h1 &gt; span:nth-child(1)'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async_func = DoubanItem.get_item(url=<span class="string">"https://movie.douban.com/subject/1292052/"</span>)</span><br><span class="line">item = asyncio.get_event_loop().run_until_complete(async_func)</span><br><span class="line">print(item.title)</span><br></pre></td></tr></table></figure><h2 id="上午主要内容总结"><a href="#上午主要内容总结" class="headerlink" title="上午主要内容总结"></a>上午主要内容总结</h2><ul><li><p>掌握快速学习的能力，任何框架都是那么容易</p></li><li><p>做项目时，一定要用虚拟环境，学会使用pip freeze &gt;&gt; requirements.txt命令，学会使用pip install -r requirements.txt</p><p>我们通常会把项目依赖的环境命名为“requirements.txt”</p></li><li><p>学会借力：例如，借助浏览器的copy xpath功能快速定位元素位置</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;构建爬虫系统&quot;&gt;&lt;a href=&quot;#构建爬虫系统&quot; class=&quot;headerlink&quot; title=&quot;构建爬虫系统&quot;&gt;&lt;/a&gt;构建爬虫系统&lt;/h1&gt;&lt;h2 id=&quot;一、实现目的&quot;&gt;&lt;a href=&quot;#一、实现目的&quot; class=&quot;headerlink&quot; title=&quot;一、实现目的&quot;&gt;&lt;/a&gt;一、实现目的&lt;/h2&gt;&lt;p&gt;爬虫是文档的重要来源，所以这一节也比较重要，我会从爬虫的基础讲起，爬虫的构成如何编写爬虫等等，希望大家能跟着文档一步步动手做下去。
    
    </summary>
    
    
      <category term="Linux" scheme="https://luckyle.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://luckyle.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>四十岁的吃鸡玩家</title>
    <link href="https://luckyle.top/2018/09/21/%E5%9B%9B%E5%8D%81%E5%B2%81%E7%9A%84%E5%90%83%E9%B8%A1%E7%8E%A9%E5%AE%B6/"/>
    <id>https://luckyle.top/2018/09/21/%E5%9B%9B%E5%8D%81%E5%B2%81%E7%9A%84%E5%90%83%E9%B8%A1%E7%8E%A9%E5%AE%B6/</id>
    <published>2018-09-21T05:29:49.000Z</published>
    <updated>2019-12-25T08:24:17.326Z</updated>
    
    <content type="html"><![CDATA[<p>四十岁的吃鸡玩家<br>我从家里出来，在马路边四处张望，寻找我叫的那辆滴滴快车。<br>司机已经来过电话，我拜托他多等一会儿，但现在已经过去了十多分钟，不知道他会不会已经取消订单。<br>情况并没有那么糟，我最终找到了那辆车。我上车之后才发现，司机居然在玩“刺激战场”。我看了一眼，三级包三级头，还挺肥。<br> <a id="more"></a><br>司机没有埋怨我的姗姗来迟，反而问我急不急着赶路。我连忙摆手，说道：“不急不急，你好好玩吧，这把有望吃鸡啊。”<br>司机一听，兴奋的说：“你也玩这个啊？”<br>“我就没事儿瞎玩玩。”<br>“你们年轻人玩这个应该挺厉害，我连前十都没进过几次。”<br>“哪有，你这把就很稳啊，这不马上就进前十了嘛。”<br>“哈哈，这把运气好…”<br>他话还没说完，就听见了一声枪响。他立刻集中精神，趴在草里，转动视角观察周围。<br>我也不再说话，静静的看他冲进决赛圈。</p><p>这时我才注意到，这位吃鸡玩家已经长了不少白发，脸上也有了皱纹。没想到这个年纪的大叔，也会热衷于吃鸡。</p><p>最后他止步于第二名，被一个穿着吉利服的“伏地魔”给淘汰了，只差一步就能吃鸡。我还觉得有些遗憾，他却十分满足。我忽然很好奇，他是因为什么开始玩这个游戏，他笑容一滞，随后说道：“因为我儿子喜欢玩这个，我就想着，要是我也玩的话，就能和他多说上几句话。”</p><p>我一时语塞，愣了片刻才缓缓开口：“你儿子真幸运，有你这样贴心的父亲。”<br>司机笑了笑：“嗐，天下哪个父母不是为了儿女操碎了心。”<br>“也是。你儿子多大了啊？”<br>“刚中考完，马上就高一了。”<br>他顿了顿，继续说道：“小时候还挺爱说话，上初中之后就不怎么和我聊天了。”<br>我安慰着：“叛逆期嘛，过了这段时间就好了。平时多陪陪他吧，比如一起吃鸡什么的。”<br>“现在每天晚上我都拉着他一起玩游戏，”他有些无奈，“但他嫌我技术差，不爱和我玩。每次都是我去睡的时候，他才能真正的和他的朋友玩。”</p><p>我忽然知道他为什么不会因为第二名而遗憾了，因为他在乎的从来都不是名次。第二名，意味着他的技术有了进步，意味着他能和儿子玩得更久。</p><p>我不知该如何接话。就在我沉默的时候，他又说道：“嘿嘿，我还打算下个‘王者荣耀’，我儿子也喜欢玩这个。”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;四十岁的吃鸡玩家&lt;br&gt;我从家里出来，在马路边四处张望，寻找我叫的那辆滴滴快车。&lt;br&gt;司机已经来过电话，我拜托他多等一会儿，但现在已经过去了十多分钟，不知道他会不会已经取消订单。&lt;br&gt;情况并没有那么糟，我最终找到了那辆车。我上车之后才发现，司机居然在玩“刺激战场”。我看了一眼，三级包三级头，还挺肥。&lt;br&gt;
    
    </summary>
    
    
      <category term="Live" scheme="https://luckyle.top/categories/Live/"/>
    
    
      <category term="Live" scheme="https://luckyle.top/tags/Live/"/>
    
  </entry>
  
  <entry>
    <title>Django</title>
    <link href="https://luckyle.top/2018/07/15/Django/"/>
    <id>https://luckyle.top/2018/07/15/Django/</id>
    <published>2018-07-15T11:44:03.000Z</published>
    <updated>2019-12-25T08:24:49.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Django-、Flask、Tornado的对比"><a href="#Django-、Flask、Tornado的对比" class="headerlink" title="Django 、Flask、Tornado的对比"></a>Django 、Flask、Tornado的对比</h1><p>1.Django走的是大而全的方向,开发效率高。它的MTV框架,自带的ORM,admin后台管理,自带的sqlite数据库和开发测试用的服务器 给开发者提高了超高的开发效率</p><p>2.Flask是轻量级的框架,自由,灵活,可扩展性很强,核心基于Werkzeug WSGI工具和jinja2模板引擎</p><p>3.Tornado走的是少而精的方向,性能优越。它最出名的是异步非阻塞的设计方式</p><p>Tornado的两大核心模块： 1.iostraem：对非阻塞式的socket进行简单的封装 2.ioloop：对I/O多路复用的封装，它实现了一个单例<a id="more"></a></p><h2 id="什么是wsgi？"><a href="#什么是wsgi？" class="headerlink" title="什么是wsgi？"></a>什么是wsgi？</h2><p>WSGI，描述web server如何与web application通信的一种规范</p><p>WSGI协议主要包括server和application两部分：</p><p>WSGI server负责从客户端接收请求，将request转发给application，将application返回的response返回给客户端； WSGI application接收由server转发的request，处理请求，并将处理结果返回给server。</p><p>application中可以包括多个栈式的中间件(middlewares)，这些中间件需要同时实现server与application，因此可以在WSGI服务器与WSGI应用之间起调节作用：对服务器来说，中间件扮演应用程序，对应用程序来说，中间件扮演服务器。</p><h2 id="简述什么是FBV和CBV？"><a href="#简述什么是FBV和CBV？" class="headerlink" title="简述什么是FBV和CBV？"></a>简述什么是FBV和CBV？</h2><p>FBV（function base views） 基于函数的视图 CBV（class base views） 基于类的视图</p><p>使用fbv的模式,在url匹配成功之后,会直接执行对应的视图函数</p><p>使用cbv模式,在url匹配成功之后,会找到视图函数中对应的类,然后这个类回到请求头中找到对应的Request Method</p><p>用户发送url请求,Django会依次遍历路由映射表中的所有记录,一旦路由映射表其中的一条匹配成功了,就执行视图函数中对应的函数名,这是fbv的执行流程</p><p>当服务端使用cbv模式的时候,用户发给服务端的请求包含url和method,这两个信息都是字符串类型 服务端通过路由映射表匹配成功后会自动去找dispatch方法,然后Django会通过dispatch反射的方式找到类中对应的方法并执行 类中的方法执行完毕之后,会把客户端想要的数据返回给dispatch方法,由dispatch方法把数据返回经客户端</p><h2 id="django请求的生命周期"><a href="#django请求的生命周期" class="headerlink" title="django请求的生命周期"></a>django请求的生命周期</h2><p><img src="C:%5CUsers%5Clenovo%5CDesktop%5Cdjango_r.png" alt=""></p><p>1.wsgi,请求封装后交给web框架 （Flask、Django）</p><p>2.中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf、request.session</p><p>3.路由匹配 根据浏览器发送的不同url去匹配不同的视图函数</p><p>4.视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm、templates =&gt; 渲染</p><p>5.中间件，对响应的数据进行处理。</p><p>6.wsgi,将响应的内容发送给浏览器。</p><h2 id="说一下Django，MIDDLEWARES中间件的作用和应用场景？"><a href="#说一下Django，MIDDLEWARES中间件的作用和应用场景？" class="headerlink" title="说一下Django，MIDDLEWARES中间件的作用和应用场景？"></a>说一下Django，MIDDLEWARES中间件的作用和应用场景？</h2><p>中间件是介于request与response处理之间的一道处理过程,用于在全局范围内改变Django的输入和输出。</p><p>简单的来说中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作</p><p>例如：</p><p>1.Django项目中默认启用了csrf保护,每次请求时通过CSRF中间件检查请求中是否有正确#token值</p><p>2.当用户在页面上发送请求时，通过自定义的认证中间件，判断用户是否已经登陆，未登陆就去登陆。</p><p>3.当有用户请求过来时，判断用户是否在白名单或者在黑名单里</p><p>其内置的五个方法:</p><p>1.process_request : 请求进来时,权限认证</p><p>2.process_view : 路由匹配之后,能够得到视图函数</p><p>3.process_exception : 异常时执行</p><p>4.process_template_responseprocess : 模板渲染时执行</p><p>5.process_response : 请求有响应时执行</p><p>如果你想修改请求，例如被传送到view中的HttpRequest对象</p><p>或者你想修改view返回的HttpResponse对象，这些都可以通过中间件来实现</p><p>可能你还想在view执行之前做一些操作，这种情况也可以用 middleware来实现。 比如我们写一个判断浏览器来源，是pc还是手机，这里手机我们采用iphone，因为暂时没有其他设备。我们有不想把这个逻辑加到视图函数里，想作为一个通用服务，作为一个可插拔的组件被使用，最好的方法就是实现为中间件</p><p>或者说做一个拦截器，发现一定的时间内某个ip对网页的访问次数过多，则将其加入黑名单</p><h2 id="django-orm-和-queryset"><a href="#django-orm-和-queryset" class="headerlink" title="django orm 和 queryset"></a>django orm 和 queryset</h2><p>O(objects):类和对象。</p><p>R(Relation):关系，关系数据库中的表格。</p><p>M(Mapping):映射。</p><p>Django ORM框架的功能：</p><p>a) 建立模型类和表之间的对应关系，允许我们通过面向对象的方式来操作数据库。</p><p>b) 根据设计的模型类生成数据库中的表格。</p><p>c) 通过方便的配置就可以进行数据库的切换。</p><p>缺点：</p><p>性能损耗，过度封装</p><p>有一定的学习成本</p><h2 id="使用orm和原生sql的优缺点？"><a href="#使用orm和原生sql的优缺点？" class="headerlink" title="使用orm和原生sql的优缺点？"></a>使用orm和原生sql的优缺点？</h2><p>使用 ORM 最大的优点就是快速开发，让我们将更多的精力放在业务上而不是数据库上，下面是 ORM 的几个优点</p><p>隐藏了数据访问细节，使通用数据库交互变得简单易行。同时 ORM 避免了不规范、冗余、风格不统一的 SQL 语句，可以避免很多人为的 bug，方便编码风格的统一和后期维护。 将数据库表和对象模型关联，我们只需针对相关的对象模型进行编码，无须考虑对象模型和数据库表之间的转化，大大提高了程序的开发效率。 方便数据库的迁移。当需要迁移到新的数据库时，不需要修改对象模型，只需要修改数据库的配置。 ORM 的最令人诟病的地方就是性能问题，不过现在已经提高了很多，下面是 ORM 的几个缺点</p><p>性能问题 自动化进行数据库关系的映射需要消耗系统资源 程序员编码 在处理多表联查、where 条件复杂的查询时，ORM 可能会生成的效率低下的 SQL 通过 Lazy load 和 Cache 很大程度上改善了性能问题 SQL 调优，SQL 语句是由 ORM 框架自动生成，虽然减少了 SQL 语句错误的发生，但是也给 SQL 调优带来了困难。 越是功能强大的 ORM 越消耗内存，因为一个 ORM Object 会带有很多成员变量和成员函数。 对象和关系之间并不是完美映射 一般来说 ORM 足以满足我们的需求，如果对性能要求特别高或者查询十分复杂，可以考虑使用原生 SQL 和 ORM 共用的方式 使用原生sql优点：</p><p>进行复杂的查询时更加灵活 可以根据需要编写特殊的sql语句 使用原生sql缺点：</p><p>需要对输入进行严格的检测 自己写的sql语句，很多时候使用的是字符串拼接，可能会有sql注入的漏洞 不能使用django orm相关的一些特性</p><h2 id="列举django-orm-中所有的方法（QuerySet对象的所有方法）"><a href="#列举django-orm-中所有的方法（QuerySet对象的所有方法）" class="headerlink" title="列举django orm 中所有的方法（QuerySet对象的所有方法）"></a>列举django orm 中所有的方法（QuerySet对象的所有方法）</h2><p>从数据库中查询出来的结果一般是一个集合，这个集合叫做 QuerySet</p><p>filter 过滤 exclude 排除 annotate 聚合 order_by 排序 reverse 反向排序 distinct 去除查询结果中重复的行 values 迭代时返回字典而不是模型实例对象 values_list 迭代时返回元组而不是字典 dates 表示特定种类的所有可用日期 datetimes 表示特定种类的所有可用日期 none 不返回任何对象 all 返回所有结果 select_related 外键查询 prefetch_related 在单个批处理中自动检索每个指定查找的相关对象 defer 告诉django不要查询某些字段 using 多个数据库时控制QuerySet在哪个数据库上求值</p><h2 id="Django本身提供了runserver，为什么不能用来部署？-runserver与uWSGI的区别"><a href="#Django本身提供了runserver，为什么不能用来部署？-runserver与uWSGI的区别" class="headerlink" title="Django本身提供了runserver，为什么不能用来部署？(runserver与uWSGI的区别)"></a>Django本身提供了runserver，为什么不能用来部署？(runserver与uWSGI的区别)</h2><p>1.runserver方法是调试 Django 时经常用到的运行方式，它使用Django自带的 WSGI Server 运行，主要在测试和开发中使用，并且 runserver 开启的方式也是单进程 。 2.uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http 等协议。注意uwsgi是一种通信协议，而uWSGI是实现uwsgi协议和WSGI协议的 Web 服务器。uWSGI具有超快的性能、低内存占用和多app管理等优点，并且搭配着Nginx就是一个生产环境了，能够将用户访问请求与应用 app 隔离开，实现真正的部署 。相比来讲，支持的并发量更高，方便管理多进程，发挥多核的优势，提升性能。</p><h2 id="谈谈你对restful规范的认识？"><a href="#谈谈你对restful规范的认识？" class="headerlink" title="谈谈你对restful规范的认识？"></a>谈谈你对restful规范的认识？</h2><p>首先restful是一种软件架构风格或者说是一种设计风格，并不是标准，它只是提供了一组设计原则和约束条件，主要用于客户端和服务器交互类的软件。<br>就像设计模式一样，并不是一定要遵循这些原则，而是基于这个风格设计的软件可以更简洁，更有层次，我们可以根据开发的实际情况，做相应的改变。</p><p>它里面提到了一些规范，例如：</p><p>1.restful 提倡面向资源编程,在url接口中尽量要使用名词，不要使用动词</p><p>2、在url接口中推荐使用Https协议，让网络接口更加安全 <a href="https://baidum/v1/mycss？page=3" target="_blank" rel="noopener">https://baidum/v1/mycss？page=3</a> （Https是Http的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL， 因此加密的详细内容就需要SSL（安全套接层协议））</p><p>3、在url中可以体现版本号 <a href="https://v1.bootcss.com/mycss" target="_blank" rel="noopener">https://v1.bootcss.com/mycss</a></p><p>不同的版本可以有不同的接口，使其更加简洁，清晰</p><p>4、url中可以体现是否是API接口 <a href="https://baidum/api/mycss" target="_blank" rel="noopener">https://baidum/api/mycss</a></p><p>5、url中可以添加条件去筛选匹配 <a href="https://baidum/v1/mycss？page=3" target="_blank" rel="noopener">https://baidum/v1/mycss？page=3</a></p><p>6、可以根据Http不同的method，进行不同的资源操作 （5种方法：GET / POST / PUT / DELETE / PATCH）</p><p>7、响应式应该设置状态码</p><p>8、有返回值，而且格式为统一的json格式</p><p>9、返回错误信息</p><p>10、返回结果中要提供帮助链接，即API最好做到接口文档</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Django-、Flask、Tornado的对比&quot;&gt;&lt;a href=&quot;#Django-、Flask、Tornado的对比&quot; class=&quot;headerlink&quot; title=&quot;Django 、Flask、Tornado的对比&quot;&gt;&lt;/a&gt;Django 、Flask、Tornado的对比&lt;/h1&gt;&lt;p&gt;1.Django走的是大而全的方向,开发效率高。它的MTV框架,自带的ORM,admin后台管理,自带的sqlite数据库和开发测试用的服务器 给开发者提高了超高的开发效率&lt;/p&gt;
&lt;p&gt;2.Flask是轻量级的框架,自由,灵活,可扩展性很强,核心基于Werkzeug WSGI工具和jinja2模板引擎&lt;/p&gt;
&lt;p&gt;3.Tornado走的是少而精的方向,性能优越。它最出名的是异步非阻塞的设计方式&lt;/p&gt;
&lt;p&gt;Tornado的两大核心模块： 1.iostraem：对非阻塞式的socket进行简单的封装 2.ioloop：对I/O多路复用的封装，它实现了一个单例
    
    </summary>
    
    
      <category term="Django" scheme="https://luckyle.top/categories/Django/"/>
    
    
      <category term="Django" scheme="https://luckyle.top/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://luckyle.top/2018/03/23/Docker/"/>
    <id>https://luckyle.top/2018/03/23/Docker/</id>
    <published>2018-03-23T06:59:59.000Z</published>
    <updated>2019-12-25T08:24:59.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><ul><li>什么是docker：小海腾<ul><li>KVM、Xen、VMware、VirtualBox、Hyper-V</li><li>VMM</li></ul></li><li>容器技术：在计算机的世界中, 容器拥有一段漫长且传奇的历史。容器与管理程序虚拟化 (hypervisor virtualization，HV)有所不同，管理程序虚拟化通过中间层将一台或者多台独立 的机器虚拟运行与物理硬件之上，而容器则是直接运行在操作系统内核之上的用户空间。因 此，容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行 在同一台宿主机上。</li><li>docker-ee：收费的</li><li>docker-ce：免费的<a id="more"></a></li></ul><h3 id="docker特点"><a href="#docker特点" class="headerlink" title="docker特点"></a>docker特点</h3><ul><li><p>上手快：用户只需要几分钟，就可以把自己的程序“Docker 化”。Docker 依赖于“写时复制” (copy-on-write)模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改” 的境界；随后，就可以创建容器来运行应用程序了。大多数 Docker 容器只需要不到 1 秒中即可 启动。由于去除了管理程序的开销，Docker 容器拥有很高的性能，同时同一台宿主机中也 可以运行更多的容器，使用户尽可能的充分利用系统资源</p></li><li><p>职责的逻辑分类：使用 Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如 何管理容器。Docker 设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署 的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题(测试环境都是正 常的，上线后出了问题就归结为肯定是运维的问题)”</p></li><li><p>快速高效的开发生命周期：Docker 的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用 程序具备可移植性，易于构建，并易于协作。(通俗一点说，Docker 就像一个盒子，里面 可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件 件的取。)</p></li><li><p>鼓励使用面向服务的架构：Docker 还鼓励面向服务的体系结构和微服务架构。Docker 推荐单个容器只运行一个应 用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服 务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序 都变得非常简单，同时也提高了程序的内省性。(当然，可以在一个容器中运行多个应用程 序)</p></li></ul><h3 id="Docker客户端和服务器"><a href="#Docker客户端和服务器" class="headerlink" title="Docker客户端和服务器"></a>Docker客户端和服务器</h3><ul><li>Docker 是一个客户端-服务器(C/S)架构程序。Docker 客户端只需要向 Docker 服务器 或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker 提供了 一个命令行工具 Docker 以及一整套 RESTful API。你可以在同一台宿主机上运行 Docker 守护 进程和客户端，也可以从本地的 Docker 客户端连接到运行在另一台宿主机上的远程 Docker 守护进程</li></ul><h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><ul><li>镜像是构建 Docker 的基石。用户基于镜像来运行自己的容器，镜像也是 Docker 生命周 期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构 建出来。例如:<ul><li>添加一个文件;</li><li>执行一个命令;</li><li>打开一个窗口。</li></ul></li><li>也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新</li></ul><h3 id="Registry镜像注册"><a href="#Registry镜像注册" class="headerlink" title="Registry镜像注册"></a>Registry镜像注册</h3><ul><li>Docker 用 Registry 来保存用户构建的镜像。</li><li>Registry 分为公共和私有两种。Docker 公司 运营公共的 Registry 叫做 Docker Hub</li><li>用户可以在 Docker Hub 注册账号，分享并保存自己的 镜像(说明:在 Docker Hub 下载镜像巨慢，可以自己构建私有的 Registry）</li></ul><h3 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h3><ul><li>Docker 可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容 器即可</li><li>容器是基于镜像启动起来的，容器中可以运行一个或多个进程</li><li>我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。容器基于 镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务</li><li>安装好的一个虚拟机</li></ul><h3 id="Docker镜像-1"><a href="#Docker镜像-1" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><ul><li>Docker 把应用程序及其依赖，打包在 image 文件里面</li><li>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例</li><li>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在自己操作系统所使用的image 基础上，往里面加入 Apache 服务器，形成你的image</li><li>就是一个操作系统文件</li></ul><h3 id="Docker容器操作"><a href="#Docker容器操作" class="headerlink" title="Docker容器操作"></a>Docker容器操作</h3><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run [option] 镜像名</span><br><span class="line"><span class="deletion">-i 表示以“交互模式”运行容器</span></span><br><span class="line"><span class="deletion">-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。</span></span><br><span class="line">–name 为创建的容器命名</span><br><span class="line"><span class="deletion">-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。</span></span><br><span class="line"><span class="deletion">-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不 会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。</span></span><br><span class="line"><span class="deletion">-p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射</span></span><br><span class="line"><span class="deletion">-e 为容器设置环境变量</span></span><br><span class="line">–network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同</span><br></pre></td></tr></table></figure><h4 id="停止或启动容器"><a href="#停止或启动容器" class="headerlink" title="停止或启动容器"></a>停止或启动容器</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="keyword">stop</span> 容器名或<span class="keyword">ID</span></span><br></pre></td></tr></table></figure><h3 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h3><ul><li>FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制， 充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务</li><li>FastDFS架构包括 <strong>Tracker server</strong> 和 <strong>Storage server</strong>。客户端请求Trackerserver进行过文件上传、下载<ul><li>通过<code>Tracker server</code>调度最终由Storage server完成文件上传、下载</li></ul></li><li><strong>Tracker server</strong><ul><li>作用是负载均衡和调度,通过Tracker server在文件上传时可以根据一些策略找到Storage server提供文件上传服务。可以将tracker称为<strong>追踪服务器</strong>或 <strong>调度服务器</strong></li></ul></li><li><strong>Storage server</strong><ul><li>作用是文件存储,客户端上传的文件最终存储在Storage存储器上,Storageserver没有实现自己的文件系统而是利用操作系统的文件系统来管理文件。可以将storage称为<strong>存储服务器</strong></li></ul></li></ul><h3 id="centos部署docker"><a href="#centos部署docker" class="headerlink" title="centos部署docker"></a>centos部署docker</h3><ul><li>安装docker</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum -y install yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加docker-repo源</span></span><br><span class="line">yum install docker-ce</span><br><span class="line"><span class="meta">#</span><span class="bash"> 尝试安装docker-ce</span></span><br><span class="line">yum erase docker-common-2:1.13.1-96.gitb2f74b2.el7.centos.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除已安装的docker</span></span><br></pre></td></tr></table></figure><ul><li>开启docker服务</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure><ul><li>查看docker镜像<ul><li>REPOSITORY：镜像所在的仓库名称</li><li>TAG：镜像标签</li><li>IMAGEID：镜像ID</li><li>CREATED：镜像的创建日期(不是获取该镜像的日期)</li><li>SIZE：镜像大小</li></ul></li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">image</span> <span class="keyword">ls</span></span><br><span class="line">docker  rm</span><br></pre></td></tr></table></figure><ul><li>拉取镜像及删除镜像</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">image</span> pull delron/fastdfs</span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，docker image pull是抓取 image 文件的命令。delron/fastdfs是 image 文件在仓库里面的位置，其中delron是 image 文件所在的组，fastdfs是 image 文件的名字</p></blockquote><ul><li>开启fastdfs的tracker服务</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dti <span class="params">--network=host</span> <span class="params">--name</span> tracker -v <span class="string">/var/fdfs/tracker</span>:<span class="string">/var/fdfs</span> delron/fastdfs tracker</span><br></pre></td></tr></table></figure><ul><li>开启fastdfs的storage服务</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -dti <span class="attribute">--network</span>=host --name storage -e <span class="attribute">TRACKER_SERVER</span>=47.97.210.11:22122 -v /var/fdfs/storage:/var/fdfs delron/fastdfs storage</span><br></pre></td></tr></table></figure><ul><li>关闭docker容器</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">stop</span> container_id</span><br></pre></td></tr></table></figure><ul><li>查看当前运行的容器</li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">container</span> <span class="keyword">ls</span></span><br></pre></td></tr></table></figure><h2 id="Fastdfs使用"><a href="#Fastdfs使用" class="headerlink" title="Fastdfs使用"></a>Fastdfs使用</h2><h3 id="python客户端"><a href="#python客户端" class="headerlink" title="python客户端"></a>python客户端</h3><ul><li>下载安装<code>fastdfs</code>的<code>python</code>客户端</li></ul><blockquote><p><a href="https://github.com/JaceHo/fdfs_client-py" target="_blank" rel="noopener">https://github.com/JaceHo/fdfs_client-py</a></p></blockquote><ul><li>windows兼容问题</li></ul><blockquote><p>解压下载好的压缩包，提取fdfs_client文件夹</p></blockquote><ul><li>将该文件夹放入python的三方包目录下</li></ul><blockquote><p>C:\Python37\Lib\site-packages</p></blockquote><ul><li>安装所需的两个额外模块</li></ul><blockquote><p>pip install mutagen<br>pip isntall requests </p></blockquote><ul><li>注释fdfs_client/storage_client.py文件中的第十二行</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">from</span> fdfs_client.sendfile <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><ul><li>创建client.conf文件到django下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># project/client.conf</span></span><br><span class="line"><span class="comment"># connect timeout in seconds</span></span><br><span class="line"><span class="comment"># default value is 30s</span></span><br><span class="line">connect_timeout=<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network timeout in seconds</span></span><br><span class="line"><span class="comment"># default value is 30s</span></span><br><span class="line">network_timeout=<span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the base path to store log files</span></span><br><span class="line">base_path=\static <span class="comment">#FastDFS客户端存放日志文件的目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tracker_server can ocur more than once, and tracker_server format is</span></span><br><span class="line"><span class="comment">#  "host:port", host can be hostname or ip address</span></span><br><span class="line">tracker_server=<span class="number">123.57</span><span class="number">.61</span><span class="number">.168</span>:<span class="number">22122</span> <span class="comment">#运行tracker服务的机器IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#standard log level as syslog, case insensitive, value list:</span></span><br><span class="line"><span class="comment">### emerg for emergency</span></span><br><span class="line"><span class="comment">### alert</span></span><br><span class="line"><span class="comment">### crit for critical</span></span><br><span class="line"><span class="comment">### error</span></span><br><span class="line"><span class="comment">### warn for warning</span></span><br><span class="line"><span class="comment">### notice</span></span><br><span class="line"><span class="comment">### info</span></span><br><span class="line"><span class="comment">### debug</span></span><br><span class="line">log_level=info</span><br><span class="line"></span><br><span class="line"><span class="comment"># if use connection pool</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">use_connection_pool = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># connections whose the idle time exceeds this time will be closed</span></span><br><span class="line"><span class="comment"># unit: second</span></span><br><span class="line"><span class="comment"># default value is 3600</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">connection_pool_max_idle_time = <span class="number">3600</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if load FastDFS parameters from tracker server</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line">load_fdfs_parameters_from_tracker=false</span><br><span class="line"></span><br><span class="line"><span class="comment"># if use storage ID instead of IP address</span></span><br><span class="line"><span class="comment"># same as tracker.conf</span></span><br><span class="line"><span class="comment"># valid only when load_fdfs_parameters_from_tracker is false</span></span><br><span class="line"><span class="comment"># default value is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">use_storage_id = false</span><br><span class="line"></span><br><span class="line"><span class="comment"># specify storage ids filename, can use relative or absolute path</span></span><br><span class="line"><span class="comment"># same as tracker.conf</span></span><br><span class="line"><span class="comment"># valid only when load_fdfs_parameters_from_tracker is false</span></span><br><span class="line"><span class="comment"># since V4.05</span></span><br><span class="line">storage_ids_filename = storage_ids.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#HTTP settings</span></span><br><span class="line">http.tracker_server_port=<span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#use "#include" directive to include HTTP other settiongs</span></span><br><span class="line"><span class="comment">##include http.conf</span></span><br></pre></td></tr></table></figure><ul><li>上传测试代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#client.upload_by_filename(文件名)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line">client = Fdfs_client(<span class="string">"client.conf"</span>)</span><br><span class="line"></span><br><span class="line">ret = client.upload_by_filename(<span class="string">'1.jpg'</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><blockquote><p>其中返回结果中的Remote file_id就是上传成功的保存文件名</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">'Group name': 'group1', </span><br><span class="line">'Remote file_id': 'group1\\M00/00/00/rBEUWlz_HzSAPPzBAAQ2UAPajsU035.jpg', </span><br><span class="line">'Status': 'Upload successed.', </span><br><span class="line">'Local file name': '1.jpg', </span><br><span class="line">'Uploaded size': '269.00KB', </span><br><span class="line">'Storage IP': '123.57.61.168\x008'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Django文件引擎"><a href="#Django文件引擎" class="headerlink" title="Django文件引擎"></a><code>Django</code>文件引擎</h3><ul><li>重构<code>django</code>文件上传引擎</li></ul><blockquote><p>存储类中必须实现_open()和_save()方法,以及任何后续使用中可能用到的其他方法。</p></blockquote><ul><li><code>_open(name, mode = ‘rb’)</code>：被<code>Storage.open()</code>调用,在打开文件时被调用</li><li><code>save(name, content)</code>：被<code>Storage.save()</code>调用,name是传入的文件名,<code>content</code>是<code>Django</code>接收到的文件内容,该方法需要将<code>content</code>文件内容保存。<code>Django</code>会将该方法的返回值保存到数据库中对应的文件字段,也就是说该方法应该返回要保存在数据库中的文件名信息。</li><li><code>exists(name)</code>：如果名为<code>name</code>的文件在文件系统中存在，按返回<code>True</code>，否则返回<code>False</code></li><li><code>url(name)</code>：返回文件的完整访问<code>URL</code></li><li><code>delete(name)</code>：删除<code>name</code>文件</li><li><code>listdir(path)</code>：列出指定路径的文件</li><li><code>size(name)</code>：返回<code>name</code>文件的总大小</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.core.files.storage <span class="keyword">import</span> Storage</span><br><span class="line"><span class="keyword">from</span> fdfs_client.client <span class="keyword">import</span> Fdfs_client</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastDFSStroage</span><span class="params">(Storage)</span>:</span></span><br><span class="line">    <span class="string">"""定义FastDFS客户端类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, base_url = None, client_conf = None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化对象</span></span><br><span class="line"><span class="string">        :param base_url:</span></span><br><span class="line"><span class="string">        :param client_conf:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> base_url <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            base_url = settings.FDAS_URL</span><br><span class="line">            <span class="comment"># 'http://123.57.61.168:8888' </span></span><br><span class="line">        self.base_url = base_url</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> client_conf <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            client_conf = settings.FDFS_CLIENT_CONF</span><br><span class="line">            <span class="comment"># FDFS_CLIENT_CONF = os.path.join(BASE_DIR, 'client.conf')</span></span><br><span class="line">        self.client_conf = client_conf</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_open</span><span class="params">(self, name, mode = <span class="string">'rb'</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        打开文件</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :param mode:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_save</span><span class="params">(self, name, content)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        保存文件</span></span><br><span class="line"><span class="string">        :param name: 传入文件名</span></span><br><span class="line"><span class="string">        :param content: 文件内容</span></span><br><span class="line"><span class="string">        :return:保存到数据库中的FastDFSDE文件名</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        client = Fdfs_client(self.client_conf)</span><br><span class="line">        ret = client.upload_by_buffer(content.read())</span><br><span class="line">        <span class="keyword">if</span> ret.get(<span class="string">"Status"</span>) != <span class="string">"Upload successed."</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"upload file failed"</span>)</span><br><span class="line">        file_name = ret.get(<span class="string">"Remote file_id"</span>)</span><br><span class="line">        <span class="keyword">return</span> file_name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exists</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        检查文件是否重复, FastDFS自动区分重复文件</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">url</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取name文件的完整url</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.base_url + name</span><br></pre></td></tr></table></figure><ul><li>将文件引擎设置到settings中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#settings.py</span></span><br><span class="line">DEFAULT_FILE_STORAGE = <span class="string">'goods.views.FastDFSStorage'</span></span><br></pre></td></tr></table></figure><ul><li>上传成功后的访问地址</li></ul><blockquote><p>在服务器IP地址的<code>8888</code>端口，记得打开对应阿里云的端口规则</p></blockquote><ul><li>注意：在新版本的Remote file_id，由<code>\\</code>斜杠变为了<code>/</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Remote file_id'</span>].replace(<span class="string">'\\'</span>,<span class="string">'/'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker&quot;&gt;&lt;a href=&quot;#docker&quot; class=&quot;headerlink&quot; title=&quot;docker&quot;&gt;&lt;/a&gt;docker&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;什么是docker：小海腾&lt;ul&gt;
&lt;li&gt;KVM、Xen、VMware、VirtualBox、Hyper-V&lt;/li&gt;
&lt;li&gt;VMM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容器技术：在计算机的世界中, 容器拥有一段漫长且传奇的历史。容器与管理程序虚拟化 (hypervisor virtualization，HV)有所不同，管理程序虚拟化通过中间层将一台或者多台独立 的机器虚拟运行与物理硬件之上，而容器则是直接运行在操作系统内核之上的用户空间。因 此，容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行 在同一台宿主机上。&lt;/li&gt;
&lt;li&gt;docker-ee：收费的&lt;/li&gt;
&lt;li&gt;docker-ce：免费的
    
    </summary>
    
    
      <category term="Docker" scheme="https://luckyle.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://luckyle.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>&#39;Jwt的应用&#39;</title>
    <link href="https://luckyle.top/2018/02/20/Jwt/"/>
    <id>https://luckyle.top/2018/02/20/Jwt/</id>
    <published>2018-02-20T08:23:28.000Z</published>
    <updated>2019-12-25T08:25:22.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><p>​     Json web token（JWT）是为了网络应用环境间传递声明而执行的一种基于JSON的开发标准（RFC 7519），该token被设计为紧凑且安全的，特别适用于分布式站点的单点登陆（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。<a id="more"></a></p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>   说起JWT，我们应该来谈一谈基于token的认证和传统的Session认证的区别。</p><h2 id="传统的session认证"><a href="#传统的session认证" class="headerlink" title="传统的session认证"></a>传统的session认证</h2><p>​    我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发送的请求，所以为了让我们的应用能识别是哪个用户发出的，我们只能在服务器存储一份用户登陆的信息，这份登陆信息会在响应时传递给服务器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的英哟个就能识别请求来自哪个用户了，这就是传统的基于sessino认证</p><p>​       但是这种基于session的认证使应用本身很难得扩展，随着不用客户端的增加，独立的服务器已无法承载更多的用户，而这个时候基于session认证应用的问题就会暴露出来</p><h2 id="基于session认证所显露的问题"><a href="#基于session认证所显露的问题" class="headerlink" title="基于session认证所显露的问题"></a>基于session认证所显露的问题</h2><p>​       Session：每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大</p><p>​        扩展性：用户认证之后，服务端做认证记录，如果认证的记录被保存在内存的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，响应的限制了负载均衡器的能力，也意味着限制了应用的扩展性</p><p>​        CSRF：因为是基于cookie来进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p><h2 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h2><p>​    基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或会话信息。这也就意味着机遇tokent认证机制的应用不需要去考虑用户在哪一台服务器登陆了，这就为应用的扩展提供了便利</p><p>​     流程是这样的</p><ul><li>用户使用用户名密码请求服务器</li><li>服务器进行验证用户信息</li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附加这个token值</li><li>服务器验证token，并返回数据</li></ul><p>​      这个token必须要在每次请求时发送给服务器，它应该保存在请求头中，另外，服务器要支持CORS（跨来源资源共享）策略，一般我们在服务端这么做就可以了 Access-Control-Allow-Origin：*</p><h2 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h2><p>​      JWT是由三部分构成，将这三段信息文本用链接构成了JWT字符串。就像这样</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ<span class="number">0</span>eXAiOiJKV<span class="number">1</span>QiLCJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiJ9</span>.eyJ<span class="attr">Vc2</span>VySWQiOjEyMywiVX<span class="symbol">Nlck5</span>hbWUiOiJhZ<span class="name">G1</span>pbiJ<span class="number">9.</span>Qjw<span class="number">1</span>epD<span class="number">5</span>P<span class="number">6</span>p<span class="number">4</span>Yy<span class="number">2</span>yju<span class="number">3</span>-fkq<span class="number">28</span>Pddz<span class="symbol">nqRj3</span>ESfALQy_U</span><br></pre></td></tr></table></figure><p>​    第一部分我们称它为头部（header）第二部分我们称其为载荷（payload，类似于飞机上承载的物品），第三部分是签证（signature）</p><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>​      JWT的头部承载的两部分信息：</p><ul><li><p>声明类型，这里是jwt</p></li><li><p>声明加密的算法，通常直接使用HMAC SHA256</p><p> 完整的头部就像下面这样的JSON</p></li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     'typ':'JWT',</span><br><span class="line">     'alg':'HS256'  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    然后将头部进行base64加密（该加密是可以对称解密的），构成了第一部分</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ<span class="number">0</span>eXAiOiJKV<span class="number">1</span>QiLCJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiJ9</span></span><br></pre></td></tr></table></figure><h2 id="plyload"><a href="#plyload" class="headerlink" title="plyload"></a>plyload</h2><p>​      载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p><ul><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明 </li></ul><p>​     标注中注册的声明（建议不强制使用）</p><ul><li>iss：jwt签发者</li><li>sub：jwt所面向的用户</li><li>aud：接收jwt的一方</li><li>exp：jwt的过期时间，这个过期时间必须大于签发时间</li><li>nbf：定义在什么时间之前，该jwt都是不可用的</li><li>iat：jwt的签发时间</li><li>jti：jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击 </li></ul><p>​    <strong>公共的声明：</strong></p><p>​       公共的声明可以添加任何的信息，一般添加用户的相关信息或其它业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密；</p><p>​     <strong>私有的声明</strong></p><p>​         私有的声明是提供者和消费者功能定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为名文信息。</p><p>​     定义一个payload</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    然后将其base64加密，得到jwt的一部分</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJzdWIiOiIxMj<span class="name">M0</span><span class="symbol">NTY3</span>ODkwIiwibmFtZSI<span class="number">6</span>Ikpva<span class="name">G4</span>gR<span class="name">G9</span>lIiwiYWRtaW<span class="number">4</span>iO<span class="symbol">nRydWV9</span></span><br></pre></td></tr></table></figure><p>Signature</p><p>​    jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ul><li>header(base64后的)</li><li>payload(base64后的)</li><li>secred     </li></ul><p>​       这个部分需要base64加密后的header和base64加密后的payload使用“.”连接组成的字符串，然后通过header中声明的加密方式进行加secret组合加密，然后就构成了jwt的第三部分</p><p>​      </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var encodedString = base64<span class="constructor">UrlEncode(<span class="params">header</span>)</span> + <span class="character">'.'</span> + base64<span class="constructor">UrlEncode(<span class="params">payload</span>)</span>;</span><br><span class="line">var signature = <span class="constructor">HMACSHA256(<span class="params">encodedString</span>, '<span class="params">secret</span>')</span>; <span class="comment">// TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure><p>​    将这三部分用“.”连接成一个完整的字符串，构成了最终的jwt：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI<span class="number">1</span><span class="symbol">NiIsInR5</span>cCI<span class="number">6</span>IkpX<span class="attr">VCJ9</span>.eyJzdWIiOiIxMj<span class="name">M0</span><span class="symbol">NTY3</span>ODkwIiwibmFtZSI<span class="number">6</span>Ikpva<span class="name">G4</span>gR<span class="name">G9</span>lIiwiYWRtaW<span class="number">4</span>iO<span class="symbol">nRydWV9</span>.TJVA<span class="number">95</span><span class="keyword">Or</span><span class="name">M7</span>E<span class="number">2</span>cBab<span class="number">30</span>RMHrHDcEfxjoYZgeFO<span class="symbol">NFh7</span>HgQ</span><br></pre></td></tr></table></figure><p>​     注意：secret是保存在服务器端的，jwt的签发也是在服务端的，secret就是用来进行jwt的签发和jwt的验证，所以它就是你服务端的私钥，在任何场景都不应该流露出去，一旦客户端得知这个secret，那就意味着客户端可以自我签发jwt了</p><p> 应用 </p><p>​      一般是在请求头里加入Authorization，并加上Bearer标注：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">fetch</span>(<span class="string">'api/user/1'</span>, &#123;</span><br><span class="line">  <span class="attribute">headers</span>: &#123;</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">'Bearer '</span> + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>​       服务端会验证token，如果验证通过就会返回相应的资源，整个流程就是这样</p><p><img src="https://images2017.cnblogs.com/blog/1147658/201711/1147658-20171118202151718-1630139158.png" alt="img"></p><p>   总结</p><p>​      优点：</p><ul><li>因为json的通用性，所以JWT是可以跨语言支持的，像C#，JavaScript，NodeJS，PHP等许多语言都可以使用</li><li>因为由了payload部分，所以JWT可以在自身存储一些其它业务逻辑所必要的非敏感信息</li><li>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的</li><li>它不需要在服务端保存会话信息，所以它易于应用的扩展</li></ul><p>​       安全相关</p><ul><li>不应该在jwt的payload部分存储敏感信息，因为该部分是客户端可解密的部分</li><li>保护好secret私钥。该私钥非常重要</li><li>如果可以，请使用https协议</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="comment">#加密</span></span><br><span class="line"><span class="comment">#第一个参数 用户敏感信息  第二个参数 密钥  第三个参数 加密算法 hs256</span></span><br><span class="line">encode_jwt=jwt.encode(&#123;<span class="string">'uid'</span>:<span class="string">'1'</span>&#125;,<span class="string">'123'</span>,algorithm=<span class="string">'HS256'</span>)</span><br><span class="line"><span class="comment">#返回一个字节码  加密后两个点分割，分成三部分。第一部分token头部，声明它是token  第二部分 载荷 存用户敏感信息  第三部分 算法</span></span><br><span class="line"><span class="comment">#转码  字符串  进行解密</span></span><br><span class="line">encode_str=str(encode_jwt,<span class="string">'utf-8'</span>)  <span class="comment">#强转， 声明编码python3 utf-8</span></span><br><span class="line"><span class="comment">#变成可用字符串</span></span><br><span class="line">print(encode_str)</span><br><span class="line"><span class="comment">#解码</span></span><br><span class="line">de_Code=jwt.decode(<span class="string">'加密后的字符串'</span>,<span class="string">'密钥'</span>，<span class="string">'声明算法'</span>)   (<span class="string">'12dcs'</span>,<span class="string">'123'</span>,algorithms=[<span class="string">'HS256'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#声明载荷</span></span><br><span class="line">improt datetime</span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line">过期时间  时间戳  敏感信息</span><br><span class="line">playlod=&#123;</span><br><span class="line">    <span class="string">'exp'</span>:int((datetime.datetime.now()) +datetime.timedelta(seconds=<span class="number">20</span>).timestap()),<span class="string">'data'</span>:&#123;<span class="string">'uid'</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#加密token</span></span><br><span class="line">encode_jwt=jwt.encode(playload,<span class="string">'123'</span>,algorithm=<span class="string">'HS256'</span>)</span><br><span class="line"><span class="comment">#解码</span></span><br><span class="line">algorithms=[<span class="string">'HS256'</span>]</span><br><span class="line"><span class="comment">#判断token过期</span></span><br><span class="line">datetime.datetime.now()</span><br><span class="line">如果当前时间大于过期时间则token过期</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#装饰器就是一个封装的闭包</span></span><br><span class="line"><span class="comment">#自定义装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_de</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decortor</span><span class="params">(view_func)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_wrapped_view</span><span class="params">(request,*args,**kwargs)</span>:</span></span><br><span class="line"><span class="comment">#此处写判断逻辑</span></span><br><span class="line">print(<span class="string">'请求开始'</span>)</span><br><span class="line"><span class="keyword">return</span> view_func(request,*args,**kwargs)</span><br><span class="line"><span class="keyword">return</span> _wrapped_viw</span><br><span class="line"><span class="keyword">return</span> decoror</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_de()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">haha</span><span class="params">(name)</span>:</span></span><br><span class="line">print(<span class="string">'谁是 %s'</span> name)</span><br><span class="line">haha(<span class="string">'张三'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是JWT&quot;&gt;&lt;a href=&quot;#什么是JWT&quot; class=&quot;headerlink&quot; title=&quot;什么是JWT&quot;&gt;&lt;/a&gt;什么是JWT&lt;/h2&gt;&lt;p&gt;​     Json web token（JWT）是为了网络应用环境间传递声明而执行的一种基于JSON的开发标准（RFC 7519），该token被设计为紧凑且安全的，特别适用于分布式站点的单点登陆（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。
    
    </summary>
    
    
      <category term="Python" scheme="https://luckyle.top/categories/Python/"/>
    
    
      <category term="Django" scheme="https://luckyle.top/tags/Django/"/>
    
  </entry>
  
</feed>
